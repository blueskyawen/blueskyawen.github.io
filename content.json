[{"title":"Vue-详细说说异步组件和源码解析","date":"2019-10-25T04:09:53.000Z","path":"2019/10/25/vue-async-component/","text":"vue应用在大部分情况下不用关心模块加载问题，但是当程序规模变得越来越大的时候，就需要考虑性能优化问题了。在这个过程中，你可能使用了拆分代码和延迟加载这两种方法，它们通过将代码块的加截推迟到需要的时候加载，从而使应用程序的初始包变得更小。在程序中模块的加载方式一般有两种：静态加载和动态加载，像下面这样，1234// 静态加载方式import utils from './utils' // 动态加载方式import('./utils').then(utils =&gt; &#123; ... &#125;); 对于现代的打包器，比如Webpack（从version2开始）会将这种语法理解为自动为该模块创建一个单独的文件，然后在需要时进行加载。在Vue里也提供了按需加载的功能，叫异步组件，下面将从使用方式、源码等几个角度来说明。从组件的使用方式来将，可以有：直接渲染异步组件和路由异步组件；而直接渲染异步组件一般是通过component的 is 属性和v-if来动态切换实现。 一 直接渲染异步组件顾名思义就是在模版直接使用的组件，一般公共组件和应用子组件大都是这种用法，只不是加载的方式是按需加载 使用方法Vue文档里提供了3中使用异步组件的方法，也是核心代码里内置实现的，这个后面再说，这三种方式如下：1234567891011121314151617181920212223242526272829303132333435363738import Vue from 'vue'import asyncLoading from './componentss/async-loading-component.vue'import asyncError from './componentss/async-error-component.vue'Vue.component('async-webpack-example-c', function (resolve) &#123; // 这个特殊的 `require` 语法将会告诉 webpack // 自动将你的构建代码切割成多个包，这些包 // 会通过 Ajax 请求加载 require(['./componentss/async-component-c.vue'], resolve)&#125;)Vue.component( 'async-webpack-example-d', // 这个 `import` 函数会返回一个 `Promise` 对象。 () =&gt; import('./componentss/async-component-d.vue'))const AsyncComponentA = () =&gt; (&#123; // 需要加载的组件 (应该是一个 `Promise` 对象) component: import('./componentss/async-component-a.js'), // 异步组件加载时使用的组件 loading: asyncLoading, // 加载失败时使用的组件 error: asyncError, // 展示加载时组件的延时时间。默认值是 200 (毫秒) // delay时间之后开开始加载并显示loading组件效果 delay: 200, // 如果提供了超时时间且组件加载也超时了， // 则使用加载失败时使用的组件。默认值是：`Infinity` timeout: 15000&#125;)// 也可注册局部组件&#123;... components: &#123; 'aync-component-b': () =&gt; import('./componentss/async-component-b.js') &#125;...&#125; 可以使用v-if和component/is来切换使用，这里使用is特性为例：123456789101112131415161718192021222324252627&lt;template&gt; &lt;div class=\"demo-item-group\"&gt; &lt;ul&gt; &lt;li v-for=\"item of comptIsNames\" :key=\"item\" @click=\"curComponentName = item\" :class=\"&#123;active: curComponentName === item&#125;\"&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;div&gt; &lt;component :is=\"curComponentName\"&gt;&lt;/component&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'basic-async-component', data: function () &#123; return &#123; showCcc: false, comptIsNames: ['async-webpack-example-c', 'async-webpack-example-d', 'aync-component-b','aync-component-a'], curComponentName: 'global-compt-1' &#125; &#125;, components: &#123; 'aync-component-b': () =&gt; import('./componentss/async-component-b.js'), 'aync-component-a': AsyncComponentA &#125;&#125;&lt;/script&gt; 想查看loading效果可以打开devTools-network-presets改为slow 3G，查看加载错误可设置为Offline。 看源码看源码能更好的理解异步组件的内部实现，从而更好的使用它们。异步组件实现的本质是 2 次渲染，除了 0 delay 的高级异步组件第一次直接渲染成 loading 组件外，其它都是第一次渲染生成一个注释节点，当异步获取组件成功后，再通过 forceRender 强制重新渲染，这样就能正确渲染出异步加载的组件了。异步组件也要create组件实例，但是由于其定义形式是工厂函数而不是对象，不会直接extend实例构造函数，而是走异步工厂那一套，如下，源文件在：vue/src/core/vdom/create-component.js,12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849export function createComponent ( Ctor: Class&lt;Component&gt; | Function | Object | void, data: ?VNodeData, context: Component, children: ?Array&lt;VNode&gt;, tag?: string): VNode | Array&lt;VNode&gt; | void &#123; if (isUndef(Ctor)) &#123; return &#125; const baseCtor = context.$options._base // plain options object: turn it into a constructor if (isObject(Ctor)) &#123; Ctor = baseCtor.extend(Ctor) &#125; // if at this stage it's not a constructor or an async component factory, // reject. if (typeof Ctor !== 'function') &#123; if (process.env.NODE_ENV !== 'production') &#123; warn(`Invalid Component definition: $&#123;String(Ctor)&#125;`, context) &#125; return &#125; // async component 异步组件处理 // Ctor不是对象，不会走上面那一套，Ctor.cid未定义 let asyncFactory if (isUndef(Ctor.cid)) &#123; asyncFactory = Ctor Ctor = resolveAsyncComponent(asyncFactory, baseCtor) if (Ctor === undefined) &#123; // return a placeholder node for async component, which is rendered // as a comment node but preserves all the raw information for the node. // the information will be used for async server-rendering and hydration. return createAsyncPlaceholder( asyncFactory, data, context, children, tag ) &#125; &#125; ... return vnode&#125; 这里resolveAsyncComponent是处理异步组件的主函数，createAsyncPlaceholder就是第一次渲染生成一个注释节点，在高级异步组件形式的delay=0的情况下直接渲染Ctor返回undefined不生成注释节点，其他情况下都会先生成诸事节点然后再执行resolveAsyncComponent根据加载情况不同进行组件的渲染。来看一下resolveAsyncComponent，源码位置：vue/src/core/vdom/helpers/resolve-async-component.js,123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129export function resolveAsyncComponent ( factory: Function, baseCtor: Class&lt;Component&gt;): Class&lt;Component&gt; | void &#123; // 处理加载error，一般在再次执行次方法式会实际处理到 if (isTrue(factory.error) &amp;&amp; isDef(factory.errorComp)) &#123; return factory.errorComp &#125; // 处理加载成功resolved，一般在再次执行次方法式会实际处理到 if (isDef(factory.resolved)) &#123; return factory.resolved &#125; // 处理多个vm实例加载一个异步组件的情况，只加载实例化一次 const owner = currentRenderingInstance if (owner &amp;&amp; isDef(factory.owners) &amp;&amp; factory.owners.indexOf(owner) === -1) &#123; // already pending factory.owners.push(owner) &#125; // 处理加载loading，一般在再次执行次方法式会实际处理到 if (isTrue(factory.loading) &amp;&amp; isDef(factory.loadingComp)) &#123; return factory.loadingComp &#125; if (owner &amp;&amp; !isDef(factory.owners)) &#123; const owners = factory.owners = [owner] let sync = true let timerLoading = null let timerTimeout = null ;(owner: any).$on('hook:destroyed', () =&gt; remove(owners, owner)) // 通知组件所属的实例更新渲染 const forceRender = (renderCompleted: boolean) =&gt; &#123; for (let i = 0, l = owners.length; i &lt; l; i++) &#123; (owners[i]: any).$forceUpdate() &#125; if (renderCompleted) &#123; owners.length = 0 if (timerLoading !== null) &#123; clearTimeout(timerLoading) timerLoading = null &#125; if (timerTimeout !== null) &#123; clearTimeout(timerTimeout) timerTimeout = null &#125; &#125; &#125; // 包装异步组件加载成功resolve方法 // 存储实例对象，下一次执行次函数便可获得 const resolve = once((res: Object | Class&lt;Component&gt;) =&gt; &#123; // cache resolved factory.resolved = ensureCtor(res, baseCtor) // invoke callbacks only if this is not a synchronous resolve // (async resolves are shimmed as synchronous during SSR) if (!sync) &#123; forceRender(true) &#125; else &#123; owners.length = 0 &#125; &#125;) // 包装异步组件加载成功reject方法 // 标记出错，下一次执行次函数便可处理error，如有error组件可获得实例 const reject = once(reason =&gt; &#123; process.env.NODE_ENV !== 'production' &amp;&amp; warn( `Failed to resolve async component: $&#123;String(factory)&#125;` + (reason ? `\\nReason: $&#123;reason&#125;` : '') ) if (isDef(factory.errorComp)) &#123; factory.error = true forceRender(true) &#125; &#125;) // 执行异步组件工厂函数 const res = factory(resolve, reject) if (isObject(res)) &#123; if (isPromise(res)) &#123; // () =&gt; Promise // 处理() =&gt; Promise形式异步组件 if (isUndef(factory.resolved)) &#123; res.then(resolve, reject) &#125; &#125; else if (isPromise(res.component)) &#123; // 处理高级异步组件 res.component.then(resolve, reject) // 处理高级异步组件的err组件 if (isDef(res.error)) &#123; factory.errorComp = ensureCtor(res.error, baseCtor) &#125; // 处理高级异步组件的loading组件 if (isDef(res.loading)) &#123; factory.loadingComp = ensureCtor(res.loading, baseCtor) // 处理高级异步组件的加载延时delay if (res.delay === 0) &#123; factory.loading = true &#125; else &#123; timerLoading = setTimeout(() =&gt; &#123; timerLoading = null if (isUndef(factory.resolved) &amp;&amp; isUndef(factory.error)) &#123; factory.loading = true forceRender(false) &#125; &#125;, res.delay || 200) &#125; &#125; // 处理高级异步组件的timeout if (isDef(res.timeout)) &#123; timerTimeout = setTimeout(() =&gt; &#123; timerTimeout = null if (isUndef(factory.resolved)) &#123; reject( process.env.NODE_ENV !== 'production' ? `timeout ($&#123;res.timeout&#125;ms)` : null ) &#125; &#125;, res.timeout) &#125; &#125; &#125; sync = false // return in case resolved synchronously return factory.loading ? factory.loadingComp : factory.resolved &#125;&#125; 这个方法比较复杂，它处理了上文说到的3 种异步组件的创建方式，具体直接看上面的代码中已标好的注释。 封装动态异步组件封装一个可以根据配置动态加载任意组件的公共组件，这是在某些时候是有需要的。在vue中动态组件的典型方式是通过该component和is属性来实现，而动态异步组件就是动态+异步，就是这个思路实现而来。示例如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105// vc-async-component.vue&lt;template&gt; &lt;transition v-if=\"transition &amp;&amp; keepAlive\" mode=\"out-in\" :enter-class=\"transitionClass.enter\" :enter-active-class=\"transitionClass.enterActive\" :enter-to-class=\"transitionClass.enterTo\" :leave-class=\"transitionClass.leave\" :leave-active-class=\"transitionClass.leaveActive\" :leave-to-class=\"transitionClass.leaveTo\"&gt; &lt;keep-alive&gt; &lt;component :is=\"componentName\" v-bind=\"$attrs\" v-on=\"$listeners\"&gt;&lt;/component&gt; &lt;/keep-alive&gt; &lt;/transition&gt; &lt;transition v-else-if=\"transition &amp;&amp; !keepAlive\" mode=\"out-in\" :enter-class=\"transitionClass.enter\" :enter-active-class=\"transitionClass.enterActive\" :enter-to-class=\"transitionClass.enterTo\" :leave-class=\"transitionClass.leave\" :leave-active-class=\"transitionClass.leaveActive\" :leave-to-class=\"transitionClass.leaveTo\"&gt; &lt;component :is=\"componentName\" v-bind=\"$attrs\" v-on=\"$listeners\"&gt;&lt;/component&gt; &lt;/transition&gt; &lt;keep-alive v-else-if=\"!transition &amp;&amp; keepAlive\"&gt; &lt;component :is=\"componentName\" v-bind=\"$attrs\" v-on=\"$listeners\"&gt;&lt;/component&gt; &lt;/keep-alive&gt; &lt;component v-else :is=\"componentName\" v-bind=\"$attrs\" v-on=\"$listeners\"&gt;&lt;/component&gt;&lt;/template&gt;&lt;script&gt;import vcAsyncLoading from './vc-async-loading'import vcAsyncError from './vc-async-error'export default &#123; inheritAttrs: false, name: 'vc-async-component', props: &#123; path: &#123; type: String, required: true &#125;, keepAlive: &#123; type: Boolean, default: false &#125;, transition: &#123; type: Boolean, default: false &#125;, delay: &#123; type: Number, default: 200 &#125;, timeout: &#123; type: Number, default: 3000 &#125;, transitionClass: &#123; type: Object, default: function () &#123; return &#123; enter: 'v-enter', enterTo: 'v-enter-to', enterActive: 'v-enter-active', leave: 'v-leave', leaveTo: 'v-leave-to', leaveActive: 'v-leave-active' &#125; &#125; &#125; &#125;, data: function () &#123; return &#123; componentName: () =&gt; (&#123; component: import(`@/$&#123;this.path&#125;`), loading: vcAsyncLoading, error: vcAsyncError, delay: this.delay, timeout: this.timeout &#125;) &#125; &#125;, watch: &#123; path: function () &#123; this.componentName = () =&gt; (&#123; component: import(`@/$&#123;this.path&#125;`), loading: vcAsyncLoading, error: vcAsyncError, delay: this.delay, timeout: this.timeout &#125;) &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;.v-enter,.v-leave-to &#123; opacity: 0;&#125;.v-enter-to,.v-leave &#123; opacity: 1;&#125;.v-enter-active,.v-leave-active &#123; transition: opacity .5s;&#125;&lt;/style&gt; 使用方式：1234567891011121314151617181920212223242526272829&lt;template&gt; &lt;div&gt; &lt;vc-async-component :path=\"comptName\" :timeout=\"timeoutLen\" :keep-alive=\"isKeepAlive\" :transition=\"isTransition\" :transition-class=\"asyncClass\"&gt; &lt;/vc-async-component&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Vue from 'vue'export default &#123; name: 'basic-async-component', data: function () &#123; return &#123; comptName: 'components/basic/componentss/async-component-c.vue', isKeepAlive: false, isTransition: false, asyncClass: &#123; enter: 'async-enter', enterActive: 'async-enter-active', enterTo: 'async-enter-to', leave: 'async-leave', leaveActive: 'async-leave-active', leaveTo: 'async-leave-to' &#125; &#125; &#125;, ...&#125;&lt;/script&gt; 实例效果可进入vc-async-component的异步组件-动态异步组件，组件名目前就下面几个有效组件，可随意切换加载查看 components/basic/componentss/async-component-a components/basic/componentss/async-component-b components/basic/componentss/async-component-c components/basic/componentss/async-component-d 输入其他不可识别的组件名就会加载错误，显示error-component 二 路由异步组件在vue-router中同样需要路由组件的懒加载，把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样更加高效。结合上面说的Vue的异步组件和Webpack的代码分割功能，可以轻松实现路由组件的懒加载。 普通异步组件的路由懒加载1234567const routes = [ &#123; path: '/', redirect: '/hello' &#125;, &#123; path: '/hello', component: () =&gt; import('@/components/hello') &#125;] 高级异步组件的路由懒加载12345678910111213141516171819202122232425import asyncLoading from '@/components/vc-cat/vc-async-loading.vue'import asyncError from '@/components/vc-cat/vc-async-error.vue'function lazyLoadView () &#123; const asyncComponentForm = () =&gt; (&#123; component: import('@/components/hello/hello-form'), loading: asyncLoading, error: asyncError, delay: 200, timeout: 8000 &#125;) return Promise.resolve(&#123; functional: true, render (h, &#123;data, children&#125;) &#123; return h(asyncComponentForm, data, children) &#125; &#125;)&#125;const routes = [ &#123; path: '/form', component: () =&gt; lazyLoadView() &#125;] 参考文档：https://blog.csdn.net/refreeom/article/details/90437394","tags":[{"name":"Vue","slug":"Vue","permalink":"http://blueskyawen.com/tags/Vue/"}]},{"title":"Javascipt-深入理解闭包","date":"2019-09-06T11:49:05.000Z","path":"2019/09/06/js-deep-read-scope-function/","text":"网上关于闭包的文章很多，各种专业文献上的“闭包”定义非常抽象，很难看懂。官方对闭包的解释是：一个拥有许多变量和绑定了这些变量的环境的表达式，还是看不懂？不着急，引用《JavaScript权威指南》英文原版对闭包的定义如下: This combination of a function object and a scope (a set of variable bindings) in which the function’s variables are resolved is called a closure in the computer science literature. 个人翻译为：闭包指的是一个函数和该函数能访问和引用的所有变量对象（也叫作用域对象）的集合。我觉的也可以这么理解：一个闭包就是当一个函数被其包含作用域外部引用时，一个没有释放资源的栈区，栈区包含该函数本身和函数所引用的作用域链上的变量对象。所以，在Javascript中，从不同角度看有两种形式：1）从理论角度看，所有的函数都是闭包，包括全局函数，因为他们都有自己的变量对象和作用域链，访问全局变量就相当于访问最外层的作用域对象2）从实践角度看，闭包函数一般有以下特点的：创建它们的上下文（比如父函数执行环境）已经销毁，它们仍然存在并被引用，而且还引用了其作用域链里其他作用域对象的变量。最简单的就像这样：12345678function F_func() &#123; var num = 42; var S_func = functio() &#123; return ++num; &#125; return S_func;&#125;var add = F_func(); 当一个或多个内部函数被包含函数返回，而内部函数引用了其他作用域的变量，当内部函数在包含函数之外被调用，我们就可以称它们构成了闭包。 一、闭包的原理1、外部函数在调用时会创建自身的执行环境、变量对象和作用域链，调用结束后这些回收，但是函数的变量对象若有变量被闭包函数调用，则基于Js的垃圾回收机制，函数调用结束后其执行环境、作用域链将销毁，变量对象却不会立即回收，而是在闭包函数的调用链里；2、每调用一次外部函数就会创建自身的执行环境、变量对象等操作，便产生一个新的闭包，以前的闭包依旧存在且互不影响；3、同一个闭包会保留上一次的状态，当它被再次调用时会在同一作用域链上进行；还是用上面的例子说明1234567891011121314151617var name = 'scope';function F_func() &#123; var num = 42; function S_func() &#123; var t = 1; num += t; return num; &#125; return S_func;&#125;var a = F_func();a(); // 43a(); // 44var b = F_func(); // 重新调用F_func()，产生新的闭包b(); // 43 a = null; // 通知回收b(); // 44 大概的执行过程(其中作用链以指针关联,vo-指代变量对象)： 作用域链的各个变量对象以指针关联 vo-指代变量对象 1）进入全局上下文，创建全局执行环境、全局变量对象和作用域链，入栈1234567//对应作用域链global ----- global-vo &#123; name: 'scope', F_func: Function, a: undefined, b: undefined &#125; 2）第一次执行F_func函数，创建F_func执行环境、变量对象和作用域链，入栈3）执行F_func函数，初始化上下文、变量对象和内部函数的作用域链1234567891011//对应作用域链F_func ----- F_func-vo &#123; ----- global-vo &#123; num: 42, name: 'scope', S_func F_func, &#125; a: Function, | b: undefined | &#125; | S_func ----- S_func-vo &#123; t: 1 &#125; 4）F_func函数执行完毕，变量a引用返回的内部函数S_func，F_func的执行环境和作用域链出栈并销毁1234567891011//对应作用域链 F_func-vo &#123; ----- global-vo &#123; num: 42, name: 'scope', S_func F_func, &#125; a: Function, | b: undefined | &#125; | a=S_func ----- S_func-vo &#123; t: 1 &#125; 5）再次调用a函数，后续每次调用都在这个作用域链里进行，将会继承变量对象里变量的变化6）第二次执行F_func函数，重新创建F_func执行环境…重复上述过程，b也将获得一个自己的执行环境、变量对象和作用域链，同a是一样的1234567891011//对应作用域链 F_func-vo &#123; ----- global-vo &#123; num: 42, name: 'scope', S_func F_func, &#125; a: Function, | b: undefined | &#125; | b=S_func ----- S_func-vo &#123; t: 1 &#125; 7）最后设置a为null，解除了a和内部函数的引用，垃圾回收机制下一次检查时将回收存储并清除内部函数的作用域链和变量对象8）b不受影响，依然可以调用4、当外部函数中存在多个内部函数时，这些函数构成闭包引用的同一份父函数的变量对象，适合构造对象；举个例子：12345678910111213function F_func() &#123; var num = 42; return &#123; fun1: function() &#123; console.log(num); &#125;, fun2: function() &#123; num++; &#125;, fun3: function() &#123; num--; &#125; &#125;;&#125;var obj = F_func();obj.fun2();obj.fun2();obj.fun3();obj.fun1(); // 43 3个匿名内部函数引用的都是F_func执行完生产的同一份变量对象 二、闭包的用途闭包可以用在许多地方，主要有： 读取函数内部的变量 让这些变量的值始终保持在内存中。 模拟块级作用域变量，构造变量临时性死区，同时也能创建私有作用域，避免向全局作用域添加过多变量，减少与其他开发者产生命名冲突示例： 12345(function() &#123; var num= 10; var add = function(n) &#123;return n + num; &#125; ...&#125;)(); Js里变量是函数级作用域，函数便是变量的私有作用域，函数外不能直接访问，只能通过调用域链，可以封装私有属性和私有方法，并开发共有接口，一般用与面向对象的构造示例： 1234567891011function Person(name) &#123; var age = 18; getAge = function() &#123; return age; &#125;; this.getName = function() &#123; return name + getAge; &#125;;&#125;var lucy = new Person('Lucy');lucy.getName(); // Lucy18 三、注意事项1）由闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题和内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部设置为null2）闭包增加的变量查找的作用域链的长度，会在一定程度上影响查找速度 四、实例分析（1）修改前123456789101112function buildArr(arr) &#123; var result = []; for (var i = 0; i &lt; arr.length; i++) &#123; var item = 'item' + i; result.push(function() &#123;console.log(item + ' ' + arr[i])&#125;); &#125; return result;&#125;var fnlist = buildArr([1,2,3]);fnlist[0](); // item2 undefinedfnlist[1](); // item2 undefinedfnlist[2](); // item2 undefined 外部函数buildArr执行完后几个fnlist匿名函数的作用域链为：123456fnlist[n] &#123; ----- buildArr-vo &#123; ----- global-vo &#123;&#125; result:[Function], buildArr: Function, i: 3, fnlist: undefined item: item2 &#125; arr: [1,2,3] &#125; （2）修改后12345678910111213141516function buildArr(arr) &#123; var result = []; for (var i = 0; i &lt; arr.length; i++) &#123; result.push((function(n) &#123; var item = 'item' + n; return function() &#123; console.log(item + ' ' + arr[n]); &#125; &#125;)(i)); &#125; return result;&#125;var fnlist = buildArr([1,2,3]);fnlist[0](); // item0 1fnlist[1](); // item1 2fnlist[2](); // item2 3 外部函数buildArr执行完后几个fnlist匿名函数的作用域链为：123456789101112131415fnlist[0] &#123; ----- 匿名函数-vo &#123; ----- buildArr-vo &#123; ----- global-vo &#123;&#125; n: 0 result: [Function], buildArr: Function, item: item0 i: 3, fnlist: undefined &#125; arr: [1,2,3] &#125; &#125; |fnlist[1] &#123; ----- 匿名函数-vo &#123; ---------------- &#125; n: 1 | item: item1 | &#125; |fnlist[2] &#123; ----- 匿名函数-vo &#123; ---------------&#125; n: 2 item: item2 &#125; ` 五、实现闭包的方法闭包主要依靠外部和内部函数来构造，而函数可以又有多种使用方式，比如：一般函数、对象方法等，所以可以很多实现闭包的方法，只要满足闭包的特点即可。（1）作为普通函数使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960611.1 最简单闭包：var myFunc = (function() &#123; var num = 10; return function() &#123; return num++; &#125;;&#125;)();1.2 返回对象或数组：也可叫模块模式或增强单例对象var myArr = (function() &#123; var num = 10; function add() &#123; return num++; &#125;; return [add];&#125;)();var myObj = (function() &#123; var num = 10; function add() &#123; return num++; &#125;; return &#123; add1: add, getNum: function() &#123;return num;&#125; // 公共接口 &#125;;&#125;)();1.3 多级作用域链var myObj = (function() &#123; var num = 10; var arr = []; for (var i = 0;i &lt; num;i++) &#123; arr.push((function(n) &#123; return function() &#123; return n + 1;&#125;; &#125;)(i)); &#125; return &#123; funs: arr &#125;;&#125;)();1.4 闭包函数以其他方式被引用var $dom = document.querySelector(\"#id\")function() &#123; var num = 10; $dom.onclick = function() &#123; console.log(num); &#125;;&#125;function() &#123; var num = 10; setInterval(function() &#123; console.log(num); &#125;,2000);&#125;function() &#123; var num = 10; clickMe = function() &#123; console.log(num); &#125;;&#125; （2）作为对象属性方法使用1234567var circle = &#123; \"PI\":3.14159, \"area\": function(r) &#123; return this.PI * r * r; &#125; &#125;; console.log(circle.area(2)); （3）作为构造函数和面向对象 广泛用于面向对象编程方式中1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162633.1 实例方法function Person(name) &#123; var age = 18; getAge = function() &#123; return age; &#125;; this.getName = function() &#123; return name + getAge; &#125;;&#125;var lucy = new Person('Lucy');lucy.getName(); // Lucy183.2 静态方法和变量，静态共享(function() &#123; var name = 'lilei'; var age = 18; Person = function(name) &#123; name = name; &#125;; Person.prototype.getName = function() &#123; return name + age; &#125;;&#125;)();var lucy = new Person('Lucy');lucy.getName(); // Lucy18var lilei = new Person('Lilei');lucy.getName(); // Lilei18lilei.getName(); // Lilei183.3 原始对象var Circle = new Object(); Circle.PI = 3.14159; Circle.Area = function( r ) &#123; return this.PI * r * r; &#125; alert( Circle.Area( 1.0 ) );3.3 工厂模式生产对象var Circle = function() &#123; var obj = new Object(); obj.PI = 3.14159; obj.area = function( r ) &#123; return this.PI * r * r; &#125; return obj; &#125; var c = new Circle(); alert( c.area( 1.0 ) );3.3 原型模式生产对象function Circle(r) &#123; this.r = r; &#125; Circle.PI = 3.14159; Circle.prototype.area = function() &#123; return Circle.PI * this.r * this.r; &#125; var c = new Circle(1.0); alert(c.area());其他...","tags":[{"name":"js","slug":"js","permalink":"http://blueskyawen.com/tags/js/"}]},{"title":"Vue-应用的typescript支持","date":"2019-07-28T04:09:53.000Z","path":"2019/07/28/vue-app-use-typescript/","text":".ts-lizi { margin-top: -30px; } .ts-lizi figure { max-height: 600px; } vue默认使用js作为开发语言，但通过配置和插件也在vue中支持typescript，通过ts的强类型系统可以防止许多的错误，提高开发效率。vue-cli已经在创建应用提供了是否支持ts的选项， vue create my-app 选择自定义选项 ? Please pick a preset: default (babel, eslint) ❯ Manually select features 在选项中选择支持Typescript ? Please pick a preset: Manually select features ? Check the features needed for your project: ◉ Babel ❯◉ TypeScript ◯ Progressive Web App (PWA) Support ◉ Router ◯ Vuex ◉ CSS Pre-processors ◉ Linter / Formatter ◯ Unit Testing ◯ E2E Testing 悬着是否使用class类的component语法 ? Check the features needed for your project: Babel, TS ? Use class-style component syntax? (Y/n) Y 按照选择的配置，创建的应用便可支持ts 引入vue-class-componentvue-class-component是官方维护的装饰器，可基于类的形式来声明和开发组件，使用angular的开发人员是比较熟悉的引入装饰器之后，便可像下面这样基于类的API来书写组件了。12345678910import Vue from 'vue'import Component from 'vue-class-component'// @Component 修饰符注明了此类为一个 Vue 组件@Component(&#123; // 所有的组件选项都可以放在这里&#125;)export default class MyComponent extends Vue &#123; // class component提供的相关成员&#125; 基本使用方式从上面可以看到，使用component开发组件最简单的方式就是把组件的所有选项放在装饰器函数里，这和js的写法类似，但是也有一些坑下面看个例子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163&lt;template&gt; &lt;div class=\"hello\"&gt; &lt;h2 @click=\"clickMsg\" v-local-direc&gt;msg: &#123;&#123; msg &#125;&#125;&lt;/h2&gt; &lt;h3&gt;name: &#123;&#123;myName&#125;&#125; &#123;&#123;myYear | transY&#125;&#125;&lt;/h3&gt; &lt;div class=\"opers\"&gt; &lt;span @click=\"addYear\"&gt;Add Year&lt;/span&gt; &lt;/div&gt; &lt;h4&gt;For-List&lt;/h4&gt; &lt;ul&gt; &lt;li v-for=\"num in numList\" :key=\"num\"&gt;&#123;&#123;num&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;h4&gt;Component-insert&lt;/h4&gt; &lt;div&gt; &lt;local-compt :num=\"500\"&gt;&lt;/local-compt&gt; &lt;global-compt v-bind:num=\"1000\"&gt;&lt;/global-compt&gt; &lt;local-compt02 :num=\"100\"&gt;&lt;/local-compt02&gt; &lt;vue-compt :num=\"66\"&gt;&lt;/vue-compt&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=\"ts\"&gt;import Vue from 'vue'import Component from 'vue-class-component'import vueCompt from './compt.vue'let localDirec = &#123; inserted: function (el : any, binding : any) &#123; el.style.backgroundColor = '#ccffff' &#125;&#125;Vue.component('global-compt', &#123; template: '&lt;div&gt;&lt;h4&gt;&#123;&#123;name&#125;&#125;: &#123;&#123;num&#125;&#125;&lt;/h4&gt;&lt;/div&gt;', props: ['num'], data () &#123; return &#123; name: '全局组件' &#125; &#125;&#125;)@Component(&#123; template: '&lt;div&gt;&lt;h4&gt;&#123;&#123;name&#125;&#125;: &#123;&#123;num&#125;&#125;&lt;/h4&gt;&lt;/div&gt;', props: ['num'], data () &#123; return &#123; name: '局部组件' &#125; &#125;&#125;)class localCompt extends Vue &#123;&#125;let localCompt02 = &#123; props: ['num'], data () &#123; return &#123; name: '局部组件02' &#125; &#125;, template: '&lt;div&gt;&lt;h3&gt;&#123;&#123;name&#125;&#125;: ##&#123;&#123;num&#125;&#125;&lt;/h3&gt;&lt;/div&gt;'&#125;// 全局混入Vue.mixin(&#123; data () &#123; return &#123; msg2: '全局混入', numList: [2, 3], site: &#123; name: '腾讯' &#125; &#125; &#125;, created: function () &#123; console.log('全局混入 --- created') &#125;, methods: &#123; startMix2: function () &#123; console.log('全局混入 --- startMix') &#125; &#125;&#125;)var localMix2 = &#123; data () &#123; return &#123; msg2: 'localMix2', msg3: 'localMix2-msg3', msg4: 'localMix2-msg4', msg5: 'localMix2-msg5', numList: [4, 5, 9], site: &#123; name: '阿里巴巴', url: 'www.alibaba.com', title: '我是阿里巴巴', haha: 'haha localMix2' &#125; &#125; &#125;, created: function () &#123; console.log('实例混入: localMix2 --- created') &#125;, methods: &#123; startMix: function () &#123; console.log('实例混入: localMix2 --- startMix') &#125;, hello: function () &#123; console.log('实例混入: localMix2 --- hello') &#125; &#125;&#125;@Component(&#123; props: &#123; msg: &#123; type: String &#125; &#125;, directives: &#123; localDirec &#125;, components: &#123; 'local-compt': localCompt, localCompt02, vueCompt &#125;, mixins: [localMix2], data: function () &#123; return &#123; name: 'vue-ts-HelloWorld', city: 'shanghai', year: 50, date: new Date(), numList: [1, 2, 3], myYear: 1000 &#125; &#125;, methods: &#123; clickMsg: function () &#123; alert('click - msg - ' + (this as any).msg) &#125;, addYear: function () &#123; (this as any).year = (this as any).year + 5 this.$emit('yearChange', (this as any).year); (this as any).startMix(); (this as any).startMix2() &#125; &#125;, computed: &#123; myName: &#123; get: function () &#123; return this.name + 'haha!!' &#125; &#125; &#125;, watch: &#123; year: function () &#123; this.myYear += this.year &#125; &#125;, filters: &#123; transY: function (value: string) &#123; return value + ' Coco' &#125; &#125;&#125;)export default class HelloWorld extends Vue &#123;&#125;&lt;/script&gt; 可以看到，组件选项的写法和使用js基本一致，但是在methods/computed里访问data数据的时候，使用this可能会导致编译报错，在tsconfig.json加下面字段可消除 &quot;noImplicitThis&quot;: false, 如果发现还有地方报此错误消息，可以使用(this as any)代替了this，可消除从物告警在ts里也可以注册指令，全局组件和局部组件，并且可以基于component来声明局部组件12345678910111213141516@Component(&#123; template: '&lt;div&gt;&lt;h4&gt;&#123;&#123;name&#125;&#125;: &#123;&#123;num&#125;&#125;&lt;/h4&gt;&lt;/div&gt;', props: ['num'], data () &#123; return &#123; name: '局部组件' &#125; &#125;&#125;)class localCompt extends Vue &#123;&#125;@Component(&#123; ... directives: &#123; localDirec &#125;, components: &#123; 'local-compt': localCompt, localCompt02&#125;&#125;) 但是你会发现注册的组件并不能成功渲染，这是因为子组件的模版不可用，这时要将应用从“运行模式”修改为“运行编译模式”，修改vue.config.js即可 runtimeCompiler: true, 类成员使用上面把组件选项放进装饰器函数的写法虽然方便和简单，但和使用js开发基本无异，不能体现ts的特点，使用vue-class-component是可以把一部分的选项“变成”类成员的，只是在使用上与一些限制，下面部分介绍是从vue-class-component的github上翻译扒过来的 当前版本只支持ECMAScript第1阶段装饰器，不支持第二阶段装饰器如果使用Babel，需要安装babel-plugin-transform-decorators-legacy。如果使用TypeScript，需要在tsconfig.json设置experimentalDecorators为true 1）组件选项可以把部分组件选项声明为雷的成员，并不是所有，目前支持情况如下： methods，可直接声明为类成员方法 computed，可声明为类属性访问器 初始initdata，可声明为类属性 data/render/生命周期钩子，可直接声明为类成员方法，但是不能在实例本身上调用它们 对于其他不支持的选项，将它们传递给装饰器函数即可下面看个例子，说明下使用限制和注意的地方：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;template&gt; &lt;div class=\"aboutMe\"&gt; &lt;h2 @click=\"clickFunc\"&gt;msg = &#123;&#123; msg &#125;&#125;&lt;/h2&gt; &lt;h2 @click=\"makeH\"&gt;name = &#123;&#123; name &#125;&#125;&lt;/h2&gt; &lt;h2 @click=\"setNameNum\"&gt;msg2 = &#123;&#123;msg2&#125;&#125;&lt;/h2&gt; &lt;h2 @click=\"makeClassVar\"&gt;get msgNameNum = &#123;&#123;msgNameNum&#125;&#125;&lt;/h2&gt; &lt;h2&gt;get nameNum = &#123;&#123;nameNum&#125;&#125;&lt;/h2&gt; &lt;p&gt;getData: &#123;&#123;getData&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=\"ts\"&gt;import Vue from 'vue'import &#123; Component，mixins &#125; from 'vue-class-component'import MyMixin from './mixin.js'@Component(&#123; props: &#123; msg: &#123; type: String &#125; &#125;, data: function () &#123; return &#123; name: 'name-in-component', num: 10 &#125; &#125;, created () &#123; console.log('AboutMe -- created in-component') &#125;, methods: &#123; makeH: function () &#123; alert('click - makeH - 2') &#125;, makeClassVar: function () &#123; alert('click - makeClassVar - ' + (this as any).msg2) &#125; &#125;, computed: &#123; getData () &#123; return this.$data &#125; &#125;&#125;)export default class AboutMe extends Vue &#123; name: string = 'name-in-class' msg2: string = (this as any).msg + '**' + this.name created () &#123; console.log('AboutMe -- created') &#125; clickFunc (): void &#123; alert('clickFunc--' + this.name) &#125; makeH () &#123; alert('click - makeH - in - class') &#125; get msgNameNum () &#123; return (this as any).msg + '@' + this.name + '@' + (this as any).num + '@' + this.msg2 + '@' + (this as any).me &#125; get nameNum () &#123; return this.name + '@@@' + (this as any).num &#125; set nameNum (str: string) &#123; let stes = str.split('@@@') this.name = stes[0]; (this as any).num = +stes[1] &#125; setNameNum () &#123; this.nameNum = 'new Name set@@@20' &#125;&#125;&lt;/script&gt; 结果输出， msg = hello about name = name-in-component msg2 = hello about**name-in-class get msgNameNum = hello about@name-in-component@10@hello about**name-in-class@undefined get nameNum = name-in-component@@@10 getData: { &quot;name&quot;: &quot;name-in-component&quot;, &quot;num&quot;: 10, &quot;msg2&quot;: &quot;hello about**name-in-class&quot;} 可以看到，装饰器函数里声明的data和class里声明的initData数据成员将合并，此外，还有许多需要注意的问题： class里声明的data函数会覆盖装饰器函数里声明的data data函数里声明的同名属性优先级大于class里声明的initData，如：name class里声明的method，computed，声明钩子方法会覆盖装饰器函数里声明的同名选项，如:makeH() class的initData在初始化使用的this.xx优先使用class的initData成员xx，找不到再取data里的同名数据，如：msg2的name class里可以直接使用this访问class成员,但要访问装饰器函数里声明组件属性，比如：data属性，方法等，则需要使用(this as any)，否则编译器里会报错； 同理，装饰器函数里的方法等也需要使用(this as any)来访问class成员 class只能有一个extends成员 2）mixins混入插件提供mixins辅助函数，以类继承的方式使用mixins，TypeScript可以推断mixin类型并在组件类型上继承它们在上个例子加上混入，先声明混入：1234567891011121314151617181920212223242526272829303132333435//mixin.jsimport Vue from 'vue'import Component from 'vue-class-component'@Componentexport class MyMixin extends Vue &#123; mixinValue = 'I am MyMixin' created () &#123; console.log('MyMixin -- created') &#125; makeH () &#123; alert('click - makeH - in - YourMixin') &#125; makeMyMixin () &#123; alert('click - makeMyMixin - in - MyMixin') &#125;&#125;@Componentexport class YourMixin extends Vue &#123; mixinValue = 'I am YourMixin' mixinMsg = 'love your Mixin !' created () &#123; console.log('YourMixin -- created') &#125; makeH () &#123; alert('click - makeH - in - YourMixin') &#125; makeMyMixin () &#123; alert('click - makeMyMixin - in - YourMixin') &#125; makeYourMixin () &#123; alert('click - makeYourMixin - in - YourMixin') &#125;&#125; 在组件中使用12345678910111213141516171819202122232425262728&lt;template&gt; &lt;div class=\"aboutMe\"&gt; &lt;h2 @click=\"clickFunc\"&gt;msg = &#123;&#123; msg &#125;&#125;&lt;/h2&gt; &lt;h2 @click=\"makeH\"&gt;name = &#123;&#123; name &#125;&#125;&lt;/h2&gt; &lt;h2 @click=\"setNameNum\"&gt;msg2 = &#123;&#123;msg2&#125;&#125;&lt;/h2&gt; &lt;h2 @click=\"makeClassVar\"&gt;get msgNameNum = &#123;&#123;msgNameNum&#125;&#125;&lt;/h2&gt; &lt;h2 @click=\"makeMyMixin\"&gt;get nameNum = &#123;&#123;nameNum&#125;&#125;&lt;/h2&gt; &lt;p @click=\"makeYourMixin\"&gt;getData: &#123;&#123;getData&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=\"ts\"&gt;import &#123; Component, Prop, Vue &#125; from 'vue-property-decorator'import &#123; mixins &#125; from 'vue-class-component'import &#123; MyMixin, YourMixin &#125; from './mixin.js'@Component(&#123; ...&#125;)export default class AboutMe extends mixins(YourMixin, MyMixin) &#123; name: string = 'name-in-class' msg2: string = (this as any).msg + '**' + this.name created () &#123; console.log('AboutMe -- created') &#125; ...&#125;&lt;/script&gt; 可以看到，mixin也可以通过component的形式书写，而通过mixins(YourMixin, MyMixin)可以将多个mixin混入到组件中，效果同在组件中直接这么写相同： mixins(MyMixin，YourMixin) 可以看到使用类继承形式的书写顺序刚好相反，即在选项合并的时候，MyMixin为parent，YourMixin为child，具体的合并策略可查看前面的文章Vue-源码详解mixin混入和合并策略 3）自定义装饰器您可以通过创建自己的装饰器来扩展此库的功能，插件提供createDecorator帮助器来创建自定义装饰器。createDecorator期望将回调函数作为第一个参数，并且回调将接收以下参数： options：Vue组件选项对象，此对象的更改将影响提供的组件。 key：应用装饰器的属性或方法键。 parameterIndex：如果自定义装饰器用于参数，则为装饰参数的索引 1234567891011121314151617181920// decorators.jsimport &#123; createDecorator &#125; from 'vue-class-component'export const NoCache = createDecorator((options, key) =&gt; &#123; // 组件options选项必须传入这个回调函数 // 更新了配置，它可使用于任何component里 options.computed[key].cache = false&#125;)// MyComp.jsimport &#123; NoCache &#125; from './decorators'@Componentclass MyComp extends Vue &#123; // 加上次装饰器后，该计算属性不再缓存 @NoCache get random () &#123; return Math.random() &#125;&#125; 4）添加自定义钩子如果您使用某些Vue插件，如VueRouter，您可能希望类组件解决它们提供的钩子。 对于这种情况，Component.registerHooks允许你这样注册和使用钩子 1234567891011121314151617181920212223242526272829303132333435363738// class-component-hooks.jsimport Component from 'vue-class-component'// 使用钩子名称来注册Component.registerHooks([ 'beforeRouteEnter', 'beforeRouteLeave', 'beforeRouteUpdate' // for vue-router 2.2+])// MyComp.jsimport Vue from 'vue'import Component from 'vue-class-component'@Componentclass MyComp extends Vue &#123; beforeRouteEnter (to, from, next) &#123; console.log('beforeRouteEnter') next() &#125; beforeRouteLeave (to, from, next) &#123; console.log('beforeRouteLeave') next() &#125;&#125;// main.js// 注意必须在使用之前注册他们import './class-component-hooks'import Vue from 'vue'import MyComp from './MyComp'new Vue(&#123; el: '#app', components: &#123; MyComp &#125;&#125;) 5）注意事项1）箭头函数不能访问类实例里初始化的属性由于插件是利用Vue的原始构造函数来将类属性实例化成vue实例数据的，因此不能在箭头函数中使用this访问类属性，因为在初始化时会将this替代为Vue实例对象，而原Vue不存在这些数据1234567@Componentclass MyComp extends Vue &#123; foo = 123 bar = () =&gt; &#123; this.foo = 456 &#125;&#125; 2）类属性初始化不要使用undefined当声明类的属性为undefined，将得不到响应式数据特性，请务必初始化为null1234567891011121314@Componentclass MyComp extends Vue &#123; // 非响应式 foo = undefined // 响应式 bar = null data () &#123; return &#123; // 响应式 baz: undefined &#125; &#125;&#125; 引入vue-property-decorator vue-class-component对组件选择的支持度不够，且限制较多；而vue-property-decorator在vue-class-component的基础上进行了增强版，支持更多的选项和装饰器，先安装它 npm i -S vue-property-decorator 插件目前支持以下装饰器，配合上一节介绍的component，几乎能够支持大部分的组件选项: @Prop，声明props输入参数 @PropSync，声明类似v-bind:prop.sync的双向绑定 @Model，声明类似v-model双向绑定 @Watch，声明观察器 @Provide/@Inject，声明依赖注入 @ProvideReactive/@InjectReactive，声明@Provide/@Inject的响应式版本 @Emit，声明事件的发射，若无指定事件名，将使用函数名作为事件名 @Ref，支持子组件的直接引用 关于这些装饰器的介绍和用法在vue-property-decorator里有详细的描述，可以进去学习下面是个例子，应用了绝大部分装饰器：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;template&gt; &lt;div class=\"capLock\"&gt; &lt;h3&gt;name: &#123;&#123;name&#125;&#125;, age: &#123;&#123;age&#125;&#125;, isMan: &#123;&#123;isMan&#125;&#125;, country: &#123;&#123;country&#125;&#125;&lt;/h3&gt; &lt;div&gt; &lt;button class=\"oper-butn\" @click=\"changeCity\"&gt;syncedCity&lt;/button&gt; &lt;button class=\"oper-butn\" @click=\"changeWeight\"&gt;changeWeight&lt;/button&gt; &lt;/div&gt; &lt;h3&gt;syncedCity: &#123;&#123;syncedCity&#125;&#125;; weight: &#123;&#123;weight&#125;&#125;kg&lt;/h3&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=\"ts\"&gt;import &#123; Component, Prop, Vue, PropSync, Model, Watch, Emit &#125; from 'vue-property-decorator'import &#123; mixins &#125; from 'vue-class-component'@Component(&#123; props: &#123; age: &#123; type: Number, default: 20 &#125;, country: &#123; type: String, default: 'China' &#125; &#125;&#125;)export default class CapLock extends Vue &#123; @Prop(String) readonly name: string | undefined @Prop(&#123; type: Number, default: 18 &#125;) readonly age: number | undefined @Prop([String, Boolean]) readonly isMan: string | boolean | undefined @PropSync('city', &#123; type: String &#125;) syncedCity!: string // use !: allow initializer and not definitely assign in the constructor @Model('change', &#123; type: Number &#125;) readonly weight!: number changeCity () &#123; let citys = ['北京', '上海', '广州', '深圳', '成都', '杭州', '苏州', '西安', '天津'] this.syncedCity = citys[Math.floor(Math.random() * 10)] &#125; changeWeight () &#123; // this.$emit('change', Math.round(Math.random() * 100)) this.sendWeight(Math.round(Math.random() * 100)) // equire to above &#125; @Emit('change') sendWeight (val: number) &#123; &#125; @Watch('city') onChildChanged (val: string, oldVal: string) &#123; console.log('curCity: ' + val + '** oldCity: ' + oldVal) &#125; @Watch('weight', &#123; immediate: true &#125;) onPersonChanged1 (val: number, oldVal: number) &#123; console.log('curWeight: ' + val + '** oldWeight: ' + oldVal) &#125;&#125;&lt;/script&gt; 例子的效果查看property decorator实例 注意事项： @Prop设置的同名参数值优先级高于component装饰器函数里设置的props","tags":[{"name":"vue","slug":"vue","permalink":"http://blueskyawen.com/tags/vue/"}]},{"title":"Vue-源码详解mixin混入和合并策略","date":"2019-07-16T04:09:53.000Z","path":"2019/07/16/vue-learn-in-minix/","text":".mixin-lizi { margin-top: -30px; } .mixin-lizi figure { max-height: 500px; } 在vue里面，混入（mixin）是一种特殊的使用方式。一个混入对象可以包含任意的组件选项，可根据需求随意“封装”组件的可复用单元，并在使用时根据一定的策略合并到组件的选项当中，使用时与组件自身选项无异。官方文档对mixin介绍比较少，不能了解甚少，于是便想研究下源码对它混入做个研究和总结 本文基于Vue源码2.x版本 说在前面在分析mixin之前，先看看两个方法，它们在混入的合并过程中扮演着重要的角色 （1） Vue.extend()Vue.extend()是基础Vue构造器，参数是一个包含组件选项的对象，可用于显式的扩展组件和混入对象，如123var Component = Vue.extend(&#123; mixins: [myMixin]&#125;) 其实，在组件内部的混入合并也是通过它来完成的 （2） extend()extend()是对象合并方法，参数是源和目标两个对象，用于对象的合并操作1extend(target, source) 其中source对象将合并到target对象，如果source和target的key值相同，则直接覆盖，否则属性添加；作用类似于Object.assgin()和underscore的_.extend(destination, *sources) 合并图示通过对vue源码的研究，我发现混入对于选项的“合并”并不是一步到位的，而是两两合并，并通过合并策略和优先级向一定的方向逐步进行合并操作，最终才得到合并的结果，就像默认的选项合并策略：12345const defaultStrat = function (parentVal: any, childVal: any): any &#123; return childVal === undefined ? parentVal : childVal&#125; 其中childVal和parentVal是每一次合并中的两个源和目标对象，比如：vm.options.xx和mixin.options.xx，下面用一个例子和图示进行说明示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222import Vue from 'vue'Vue.mixin(&#123; data () &#123; return &#123; msg: '全局混入-msg', msg1: '全局混入1-msg-1', msg2: '全局混入1-msg-2', msg4: '全局混入1-msg4', msg5: '全局混入1-msg5', site: &#123; name: '腾讯', url: 'www.tenant.com', hahaList: [3, 4], city: 'shenzhen' &#125; &#125; &#125;, created: function () &#123; console.log('全局混入1 --- created') &#125;, methods: &#123; startMix: function () &#123; console.log('全局混入1 --- startMix') &#125; &#125;, computed: &#123; getMsg: function () &#123; return 'getMsg 全局混入1!!' &#125;, getMsg2: function () &#123; return 'getMsg2 全局混入1!!' &#125;, getMsg5: function () &#123; return 'getMsg5 全局混入1!!' &#125; &#125;&#125;)Vue.mixin(&#123; data () &#123; return &#123; msg: '全局混入2-msg', msg1: '全局混入2-msg-1', msg4: '全局混入2-msg4', numList: [4, 5], site: &#123; name: 'alibaba', hahaList: [3, 4], url: 'www.alibaba.com', people: 30000 &#125; &#125; &#125;, created: function () &#123; console.log('全局混入2 --- created') &#125;, methods: &#123; startMix: function () &#123; console.log('全局混入2 --- startMix') &#125;, hello: function () &#123; console.log('全局混入2 --- hello') &#125; &#125;, computed: &#123; getMsg: function () &#123; return 'getMsg 全局混入2!!' &#125;, getMsg2: function () &#123; return 'getMsg2 全局混入2!!' &#125; &#125;&#125;)var localMix3 = &#123; data () &#123; return &#123; msg: '实例混入3', msg1: '实例混入3-msg1', msg2: '实例混入3-msg2', msg3: '实例混入3-msg3', site: &#123; name: '淘宝111', url: 'www', country: 'China' &#125; &#125; &#125;, created: function () &#123; console.log('实例混入3 --- created') &#125;, methods: &#123; startMix: function () &#123; console.log('实例混入3 --- startMix') &#125;, hello: function () &#123; console.log('实例混入3 --- hello') &#125; &#125;, computed: &#123; getMsg: function () &#123; return 'getMsg 实例混入3!!' &#125;, getMsg2: function () &#123; return 'getMsg2 实例混入3!!' &#125;, getMsg3: function () &#123; return 'getMsg3 实例混入3!!' &#125;, getMsg4: function () &#123; return 'getMsg4 实例混入3!!' &#125; &#125;&#125;var localMix2 = &#123; data () &#123; return &#123; msg: '实例混入2', msg1: '实例混入2-msg1', msg2: '实例混入2-msg2', site: &#123; name: '淘宝', url: 'www.taobao.com', title: 'I am 淘宝' &#125; &#125; &#125;, created: function () &#123; console.log('实例混入2 --- created') &#125;, methods: &#123; startMix: function () &#123; console.log('实例混入2 --- startMix') &#125;, hello: function () &#123; console.log('实例混入2 --- hello') &#125; &#125;, computed: &#123; getMsg: function () &#123; return 'getMsg 实例混入2!!' &#125;, getMsg2: function () &#123; return 'getMsg2 实例混入2!!' &#125;, getMsg3: function () &#123; return 'getMsg3 实例混入2!!' &#125; &#125;&#125;var localMix1 = &#123; data () &#123; return &#123; msg: '实例混入1', msg1: '实例混入1-msg1', numList: [2, 3], site: &#123; name: '淘宝', url: 'www.taobao.com', hahaList: [3, 4] &#125; &#125; &#125;, mixins: [localMix2], created: function () &#123; console.log('实例混入1 --- created') &#125;, methods: &#123; startMix: function () &#123; console.log('实例混入1 --- startMix') &#125;, hello: function () &#123; console.log('实例混入1 --- hello') &#125; &#125;, filters: &#123; capitalize2: function (value) &#123; if (!value) return '' return value + ' 实例混入1!!' &#125; &#125;, computed: &#123; getMsg: function () &#123; return 'getMsg 实例混入1!!' &#125;, getMsg2: function () &#123; return 'getMsg2 实例混入1!!' &#125; &#125;&#125;export default &#123; name: 'basicExtend', data () &#123; return &#123; msg: 'basicExtend', numList: [1, 2], site: &#123; name: '百度', hahaList: [1, 2] &#125; &#125; &#125;, mixins: [localMix3, localMix1], created: function () &#123; console.log('basicExtend --- created') &#125;, methods: &#123; startMix: function () &#123; console.log('basicExtend --- startMix') &#125; &#125;, computed: &#123; showData: function () &#123; return JSON.stringify(this.$data) &#125;, getMsg: function () &#123; return this.msg + ' !!!' &#125; &#125;&#125; 其中合并后的data和输出如下，1234567891011121314151617181920212223242526vm.$data:&#123; \"msg\":\"basicExtend\", \"numList\":[1,2], \"site\":&#123; \"name\":\"百度\", \"hahaList\":[1,2], \"url\":\"www.taobao.com\", \"title\":\"I am 淘宝\", \"country\":\"China\", \"people\":30000, \"city\":\"shenzhen\" &#125;, \"msg1\":\"实例混入1-msg1\", \"msg2\":\"实例混入2-msg2\", \"msg3\":\"实例混入3-msg3\", \"msg4\":\"全局混入2-msg4\", \"msg5\":\"全局混入1-msg5\"&#125;computed计算属性:getMsg: basicExtend !!!getMsg2: getMsg2 实例混入1!!getMsg3: getMsg3 实例混入2!!getMsg4: getMsg4 实例混入3!!getMsg5: getMsg5 全局混入1!! 下面根据这个例子整理的“合并父子图示”，根据后面的讲解再反过来看为什么合并的结果会是这样。 图示描述了源代码中选项合并方法的入参”父子”关系，其中， 全局注册的混入最先完成混入，并按注册的顺序来逐个合并，先注册的先完成混入合并，依次类推 局部注册的混入次之，并按mixins数组里声明的顺序依次完成合并 每个混入也可以包含mixins局部混入数组，mixins先完成合并，本混入的options再进行合并 组件options最后完成混入合并 先合并的”优先级”低，后合并的”优先级”高，也就是组件的options合并优先级最高 不同的选项根据自身的混入策略合并方向不一样，这个在下面会有说 选项合并混入对象的混入是每个对象选项和组件选项的“混入合并”，比如：options.data、options.props等，根据不同选项合并策略的不同，各类选项会以不同的方式和方向进行“合并”操作（1） el，propsData 合并方向: parent –&gt; child 源码：1234567891011121314151617181920212223 src/core/util/options.jsconst strats = config.optionMergeStrategiesif (process.env.NODE_ENV !== 'production') &#123; strats.el = strats.propsData = function (parent, child, vm, key) &#123; if (!vm) &#123; warn( `option \"$&#123;key&#125;\" can only be used during instance ` + 'creation with the `new` keyword.' ) &#125; return defaultStrat(parent, child) &#125;&#125;/** * Default strategy. */const defaultStrat = function (parentVal: any, childVal: any): any &#123; return childVal === undefined ? parentVal : childVal&#125; 可见，el , propsData使用的是默认合并策略，默认策略比较简单干脆，以child选项为主，若无则使用parent选项 （2） 生命周期钩子 合并方向: parent –&gt; child 源码：123456789101112131415161718192021222324252627282930313233export const LIFECYCLE_HOOKS = [ 'beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeUpdate', 'updated', 'beforeDestroy', 'destroyed', 'activated', 'deactivated', 'errorCaptured', 'serverPrefetch']LIFECYCLE_HOOKS.forEach(hook =&gt; &#123; strats[hook] = mergeHook&#125;)function mergeHook ( parentVal: ?Array&lt;Function&gt;, childVal: ?Function | ?Array&lt;Function&gt;): ?Array&lt;Function&gt; &#123; const res = childVal ? parentVal ? parentVal.concat(childVal) // 合并为一个数组 : Array.isArray(childVal) ? childVal : [childVal] : parentVal return res ? dedupeHooks(res) : res&#125; 可见，LIFECYCLE_HOOKS会将每个hook合并成一个数组，按照图示从父到子开始一步步链接合并成数组，parent在前，child在后。在钩子触发时，按照数组从头顺序调用触发，所以我们看到调用顺序是这样的，与图示一致： 全局混入hook --&gt; 实例混入hook ... --&gt; 组件实例hook （3） data 合并方向: parent –&gt; child 源码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293strats.data = function ( parentVal: any, childVal: any, vm?: Component): ?Function &#123; if (!vm) &#123; if (childVal &amp;&amp; typeof childVal !== 'function') &#123; process.env.NODE_ENV !== 'production' &amp;&amp; warn( 'The \"data\" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm ) return parentVal &#125; return mergeDataOrFn(parentVal, childVal) &#125; return mergeDataOrFn(parentVal, childVal, vm)&#125;export function mergeDataOrFn ( parentVal: any, childVal: any, vm?: Component): ?Function &#123; if (!vm) &#123; // in a Vue.extend merge, both should be functions if (!childVal) &#123; return parentVal &#125; if (!parentVal) &#123; return childVal &#125; // when parentVal &amp; childVal are both present, // we need to return a function that returns the // merged result of both functions... no need to // check if parentVal is a function here because // it has to be a function to pass previous merges. return function mergedDataFn () &#123; // parentVal作为from，childVal作为to，parent-&gt;child方向合并 return mergeData( typeof childVal === 'function' ? childVal.call(this, this) : childVal, typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal ) &#125; &#125; else &#123; return function mergedInstanceDataFn () &#123; // instance merge const instanceData = typeof childVal === 'function' ? childVal.call(vm, vm) : childVal const defaultData = typeof parentVal === 'function' ? parentVal.call(vm, vm) : parentVal if (instanceData) &#123; // parentVal作为from，childVal作为to，parent-&gt;child方向合并 return mergeData(instanceData, defaultData) &#125; else &#123; return defaultData &#125; &#125; &#125;&#125;function mergeData (to: Object, from: ?Object): Object &#123; if (!from) return to let key, toVal, fromVal const keys = hasSymbol ? Reflect.ownKeys(from) : Object.keys(from) for (let i = 0; i &lt; keys.length; i++) &#123; key = keys[i] // in case the object is already observed... if (key === '__ob__') continue toVal = to[key] // child fromVal = from[key] // parent if (!hasOwn(to, key)) &#123; set(to, key, fromVal) //若to没有此key，添加它 &#125; else if ( toVal !== fromVal &amp;&amp; isPlainObject(toVal) &amp;&amp; isPlainObject(fromVal) ) &#123; //若to有此key，且不等 //若to有此key，值非对象，否则进行深度合并 mergeData(toVal, fromVal) &#125; &#125; return to&#125; 这里set（）方法操作添加key并创建响应属性值可以看到，data的合并比较复杂，按照图示从父到子开始递归合并，以child为主，比较key规则如下： 若child无此key，parent有，直接合并此key 若child和parent都有此key，且非object类型，忽略不作为 若child和parent都有此key，且为object类型，则递归合并对象 （4） components，directives，filters 合并方向: parent &lt;– child 源码：1234567891011121314151617181920212223export const ASSET_TYPES = [ 'component', 'directive', 'filter']ASSET_TYPES.forEach(function (type) &#123; strats[type + 's'] = mergeAssets&#125;)function mergeAssets ( parentVal: ?Object, childVal: ?Object, vm?: Component, key: string): Object &#123; const res = Object.create(parentVal || null) // 原型委托 if (childVal) &#123; process.env.NODE_ENV !== 'production' &amp;&amp; assertObjectType(key, childVal, vm) return extend(res, childVal) // child合并到parent &#125; else &#123; return res &#125;&#125; 可以看到，components, directives,filters的合并策略比较简单，使用extend方法合并为一个对象，按照图示从子到父进行合并。其实这是采用原型链委托的方式在合并时把child的属性委托在parent上，这样在使用的时候，在child上查找，没有的再从parent上找，以此类推，所以child的优先级的更高的。 （5） watch 合并方向: parent –&gt; child 源码：123456789101112131415161718192021222324252627282930strats.watch = function ( parentVal: ?Object, childVal: ?Object, vm?: Component, key: string): ?Object &#123; // work around Firefox's Object.prototype.watch... if (parentVal === nativeWatch) parentVal = undefined if (childVal === nativeWatch) childVal = undefined /* istanbul ignore if */ if (!childVal) return Object.create(parentVal || null) if (process.env.NODE_ENV !== 'production') &#123; assertObjectType(key, childVal, vm) &#125; if (!parentVal) return childVal const ret = &#123;&#125; extend(ret, parentVal) //获取parent选项 for (const key in childVal) &#123; let parent = ret[key] //获取parent选项值 const child = childVal[key] //获取child选项值 if (parent &amp;&amp; !Array.isArray(parent)) &#123; parent = [parent] &#125; //每个wather选项合并为数组 ret[key] = parent ? parent.concat(child) : Array.isArray(child) ? child : [child] &#125; return ret&#125; 可见，watch会将每个watcher合并成一个数组，按照图示从父到子顺序合并。在同名wather属性触发时，按照数组从头顺序调用触发，所以我们看到触发顺序是这样的，与图示一致： 全局混入 --&gt; 实例混入 ... --&gt; 组件实例 （6） props，methods，computed，inject 合并方向: parent &lt;– child 源码：123456789101112131415161718strats.props =strats.methods =strats.inject =strats.computed = function ( parentVal: ?Object, childVal: ?Object, vm?: Component, key: string): ?Object &#123; if (childVal &amp;&amp; process.env.NODE_ENV !== 'production') &#123; assertObjectType(key, childVal, vm) &#125; if (!parentVal) return childVal const ret = Object.create(null) extend(ret, parentVal) //合并parent if (childVal) extend(ret, childVal) //合并child return ret&#125; 可以看到，props，methods，computed，inject的合并策略和components比较相似，都是使用extend方法合并为一个对象，按照图示从子到父进行合并，所以在调用查找时child优先级更高。 （7） provide 合并方向: parent –&gt; child 源码：1strats.provide = mergeDataOrFn provide的合并策略和data类似 选项合并策略如上，对于mixin和组件的每个选项都有对应的合并策略，你可以像下面这样改变默认的合并策略12const strats = Vue.config.optionMergeStrategiesstrats.methods = strats.data 但是对于默认选项不建议这么做，会引起合并错误，虽然提供了手段对于新增的选项，比如vuex，myVOption，也需要什么合并策略，可以使用现有的策略，比如：1Vue.config.optionMergeStrategies.myVOption = strats.methods 也可以自定义策略12345678Vue.config.optionMergeStrategies.myVOption = function( parentVal: ?Object, childVal: ?Object,): ?Object &#123; if (!parentVal) return childVal if (!childVal) return parentVal return extend(parentVal, childVal)&#125; 注意：全局混入将对所有的vue实例有效，尽量不要使用；但可以用于插件的发布，比如发布一个画图插件，并提供若干绘画方法","tags":[{"name":"Vue","slug":"Vue","permalink":"http://blueskyawen.com/tags/Vue/"}]},{"title":"Vue-双向绑定的几种支持方式","date":"2019-07-08T04:09:53.000Z","path":"2019/07/08/vue-shuangxiang-bind/","text":"与angular一样，vue也可以进行数据的双向绑定并拥有多种实现形式，可用于基础组件的封装。下面以Switch基础组件为例介绍vuejs里面双向绑定的几种方式，组件实现的基本效果像这样，可点击查看 一 使用value-inputvue的绑定指令v-model本质上的是value输入和input事假组成的语法糖， 绑定数据值到value的props上 通过input事件，触发发射新的值 比如：1&lt;input v-model=\"searchText\"&gt; 等价于： 12&lt;input v-bind:value=\"searchText\" v-on:input=\"searchText = $event.target.value\"&gt; 类似地，可以讲其他适用到普通的元素和组件中，通过props和自定义事件来实现组件的双向绑定，如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;template&gt; &lt;div class=\"vc-switch\"&gt; &lt;div class=\"switch-container\" :class=\"switchClasses\" @click=\"changeSwitch\"&gt; &lt;div class=\"switch\" :class=\"spinClasses\"&gt;&lt;/div&gt; &lt;span v-if=\"isHasLabel\"&gt;&#123;&#123;label&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'vc-switch', props: &#123; type: &#123; type: String, default: 'max' &#125;, tipLabels: &#123; type: Array, default: function () &#123; return [] &#125; &#125;, value: &#123; type: Boolean, default: true &#125;, disabled: &#123; type: Boolean, default: false &#125; &#125;, data () &#123; return &#123; isHasLabel: false, label: '' &#125; &#125;, created: function () &#123; this.isHasLabel = this.tipLabels.length !== 0 this.label = !this.isHasLabel ? '' : this.value ? this.tipLabels[0] : this.tipLabels[1] &#125;, computed: &#123; switchClasses: function () &#123; return &#123;'switch-start': !this.isHasLabel &amp;&amp; !this.value, 'switch-end': !this.isHasLabel &amp;&amp; this.value, 'switch-row': this.isHasLabel &amp;&amp; !this.value, 'switch-reverse': this.isHasLabel &amp;&amp; this.value, 'container-max': this.type === 'max', 'container-min': this.type === 'min', 'disabled': this.disabled&#125; &#125;, spinClasses: function () &#123; return &#123;'switch-max': this.type === 'max', 'switch-min': this.type === 'min'&#125; &#125; &#125;, methods: &#123; changeSwitch: function () &#123; if (this.disabled) return if (!this.value) &#123; this.label = this.tipLabels[0] &#125; else &#123; this.label = this.tipLabels[1] &#125; this.$emit('input', !this.value) &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt; ...&lt;/style&gt; 使用它： 1&lt;vc-switch v-model=&quot;isAggre&quot;&gt;&lt;/vc-switch&gt; 二 自定义v-model虽然可以通过value和input来实现双向绑定，但是这两个属性用在普通元素上仍然怪异，可以自定义v-model来实现新的语法糖，比如 绑定数据值到switch 通过change事件触发发射新的值 只修改了部分js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;script&gt;export default &#123; name: 'vc-switch', model: &#123; prop: 'switch', event: 'change' &#125;, props: &#123; ... switch: &#123; type: Boolean, default: true &#125;, ... &#125;, ... created: function () &#123; this.isHasLabel = this.tipLabels.length !== 0 this.label = !this.isHasLabel ? '' : this.switch ? this.tipLabels[0] : this.tipLabels[1] &#125;, computed: &#123; switchClasses: function () &#123; return &#123;'switch-start': !this.isHasLabel &amp;&amp; !this.switch, 'switch-end': !this.isHasLabel &amp;&amp; this.switch, 'switch-row': this.isHasLabel &amp;&amp; !this.switch, 'switch-reverse': this.isHasLabel &amp;&amp; this.switch, 'container-max': this.type === 'max', 'container-min': this.type === 'min', 'disabled': this.disabled&#125; &#125;, spinClasses: function () &#123; return &#123;'switch-max': this.type === 'max', 'switch-min': this.type === 'min'&#125; &#125; &#125;, methods: &#123; changeSwitch: function () &#123; if (this.disabled) return if (!this.switch) &#123; this.label = this.tipLabels[0] &#125; else &#123; this.label = this.tipLabels[1] &#125; this.$emit('change', !this.switch) &#125; &#125;&#125;&lt;/script&gt; 三 使用.sync通过新增的.sync修饰符和update:propName一样实现双向绑定的语法糖，虽然官方文档比较推荐这个，且陈述了理由，但真正用下来区别不大下面还是以switch组件为例，只修改js即可 12345678910111213141516171819202122232425&lt;script&gt;export default &#123; name: 'vc-switch', props: &#123; ... switch: &#123; type: Boolean, default: true &#125;, ... &#125;, ... methods: &#123; changeSwitch: function () &#123; if (this.disabled) return if (!this.switch) &#123; this.label = this.tipLabels[0] &#125; else &#123; this.label = this.tipLabels[1] &#125; this.$emit('update:switch', !this.switch) &#125; &#125;&#125;&lt;/script&gt; 使用时 1&lt;vc-switch v-bind:switch.sync=&quot;isAggre&quot;&gt;&lt;/vc-switch&gt; 和v-bind可以绑定对像并且对象每个属性建立响应一样，使用.sync同样可以与对象进行双向绑定，并且给每个对象属性建立双向绑定，与给每个属性字段分别绑定效果一样","tags":[{"name":"Vue","slug":"Vue","permalink":"http://blueskyawen.com/tags/Vue/"}]},{"title":"Angular中引入百度地图","date":"2019-05-02T17:37:37.000Z","path":"2019/05/03/add-baidu-map-in-angular/","text":"最近做项目需要在页面嵌入地图类，好多网站都类似的需求，有使用谷歌地图的，也有使用高德地图的。由于在国内，于是考虑引入百度地图，研究了一下使用方式，记录下来。 百度地图有开放的开放平台，只要获取到对应的应用AK即可方便使用，几个步骤可完成： 首先，进入百度地图开放平台，注册并登录百度帐号 进入控制台，选择“创建应用”，获取AK，这是使用百度地图的关键；创建应用时可以选择应用类型，只在浏览器端使用的话请选择“浏览器端”，白名单一定要设置，不限制访问域名的话可填“**” 查看创建的应用，应用的AK码串就是之后要使用的 有了AK，我们便可以在在我们的应用中使用百度地图了，根据需求可以参考平台的开发文档进行开发使用，本次我们使用的javascript api在web端引入百度地图。但是在angular项目中引如百度地图却有几个不同的使用方式，有原生API调用和模块化使用方式。 原生API引入地图首先在index.html引入百度地图API，在head里添加 &lt;script type=&quot;text/javascript&quot; src=&quot;http://api.map.baidu.com/api?v=3.0&amp;ak=your_ak&quot;&gt;&lt;/script&gt; 在组建中使用 //map.html &lt;div id=&quot;map-container&quot; class=&quot;map-content&quot;&gt;&lt;/div&gt; //map.ts import { Component, OnInit } from &apos;@angular/core&apos;; declare var BMap: any; declare var BMAP_ANIMATION_BOUNCE: any; declare var BMAP_NAVIGATION_CONTROL_SMALL: any; declare var BMAP_MAPTYPE_CONTROL_MAP: any; declare var BMAP_ANCHOR_TOP_LEFT: any; declare var BMapLib: any; @Component({ selector: &apos;app-baidu-map-for-js&apos;, templateUrl: &apos;./baidu-map-for-js.component.html&apos;, styleUrls: [&apos;./baidu-map-for-js.component.less&apos;] }) export class BaiduMapForJsComponent implements OnInit { map: any; point: any; scrollZoom: boolean = false; bDragg: boolean = true; overviewMap: any; openOverview: boolean = false; cityControl: any; showCityControl: boolean = false; marker: any; circle: any; showMarker: boolean = true; myDis: any; isCeju: boolean = false; constructor() { } ngOnInit() { // 创建地图实例 this.map = new BMap.Map(&quot;map-container&quot;); // 初始化地图，设置中心点坐标和地图级别 this.point = new BMap.Point(121.5097199, 31.2425584); this.map.centerAndZoom(this.point, 15); //添加地图控件 this.addNavigationControl(); this.addOverviewMap(); this.map.addControl(new BMap.MapTypeControl({type: BMAP_MAPTYPE_CONTROL_MAP})); //添加标记和信息框 this.addMaker(); this.addInfoWindow(); } addNavigationControl() { let opts = {type: BMAP_NAVIGATION_CONTROL_SMALL,enableGeolocation: true}; this.map.addControl(new BMap.NavigationControl(opts)); } addOverviewMap() { this.overviewMap = new BMap.OverviewMapControl({isOpen:this.openOverview }); this.map.addControl(this.overviewMap); this.overviewMap.addEventListener(&quot;viewchanged&quot;, (e) =&gt; { this.openOverview = e.isOpen; }); } addMaker() { this.circle = new BMap.Circle(this.point,500,{strokeColor:&quot;blue&quot;, strokeWeight:2, strokeOpacity:0.3}); //创建圆 this.map.addOverlay(this.circle); this.marker = new BMap.Marker(this.point); // 创建标注 this.map.addOverlay(this.marker); // 将标注添加到地图中 this.marker.setAnimation(BMAP_ANIMATION_BOUNCE); //跳动的动画 } addInfoWindow() { var opts = { width : 150, // 信息窗口宽度 height: 80, // 信息窗口高度 title : &quot;陆家嘴&quot; // 信息窗口标题 //enableMessage:true,//设置允许信息窗发送短息 //message:&quot;亲耐滴，晚上一起吃个饭吧？戳下面的链接看下地址喔~&quot; }; var infoWindow = new BMap.InfoWindow(&quot;上海金融中心！！&quot;, opts); // 创建信息窗口对象 this.marker.addEventListener(&quot;click&quot;, () =&gt; { this.map.openInfoWindow(infoWindow,this.point); //开启信息窗口 }); } } 效果如： 百度地图-使用原生API 需要更多地图API可参考: 百度地图JavaScript API 模块化组件引入地图angular有个已封装的百度地图使用模块angular2-baidu-map，首先安装模块包， npm install angular2-baidu-map --save-dev 在根模块中引入module， import { BrowserModule } from &apos;@angular/platform-browser&apos; import { NgModule } from &apos;@angular/core&apos; import { AppComponent } from &apos;./app.component&apos; import { BaiduMapModule } from &apos;angular2-baidu-map&apos; @NgModule({ declarations: [AppComponent], imports: [BrowserModule, BaiduMapModule.forRoot({ ak: &apos;your_ak&apos; })], providers: [], bootstrap: [AppComponent] }) export class AppModule {} 在组件画地图， //map.component.html &lt;baidu-map [options]=&quot;options&quot; (loaded)=&quot;mapLoaded($event)&quot;&gt;&lt;/baidu-map&gt; //map.component.ts import { Component, OnInit, ElementRef, AfterViewInit } from &apos;@angular/core&apos;; import {ControlAnchor, MapOptions, MapTypeControlOptions, MapTypeControlType,NavigationControlOptions, NavigationControlType, OverviewMapControlOptions,ScaleControlOptions, BNavigationControl, BOverviewMapControl, MarkerOptions, Animation,MapTypeEnum, GeolocationControlOptions, CircleOptions, Point, BCircle, BMarker, BMapInstance} from &apos;angular2-baidu-map&apos; @Component({ selector: &apos;app-baidu-map-for-module&apos;, templateUrl: &apos;./baidu-map-for-module.component.html&apos;, styleUrls: [&apos;./baidu-map-for-module.component.less&apos;] }) export class BaiduMapForModuleComponent implements OnInit { options: MapOptions; constructor() { } ngOnInit() { this.options = { centerAndZoom: { lat: 30.241628, lng: 120.138121, zoom: 13 }, enableKeyboard: true }; } } 添加控件和标记， //map.component.html &lt;baidu-map [options]=&quot;options&quot; (loaded)=&quot;mapLoaded($event)&quot;&gt; &lt;control type=&quot;navigation&quot; [options]=&quot;controlOpts&quot;&gt;&lt;/control&gt; &lt;control type=&quot;maptype&quot; [options]=&quot;mapTypeOpts&quot;&gt;&lt;/control&gt; &lt;control type=&quot;scale&quot; [options]=&quot;scaleOpts&quot;&gt;&lt;/control&gt; &lt;control type=&quot;overviewmap&quot; [options]=&quot;overviewmapOpts&quot; (loaded)=&quot;overviewLoaded($event)&quot;&gt;&lt;/control&gt; &lt;circle [center]=&quot;center&quot; radius=&quot;1200&quot; [options]=&quot;circleOptions&quot; (loaded)=&quot;circleLoaded($event)&quot;&gt;&lt;/circle&gt; &lt;marker *ngFor=&quot;let marker of markers&quot; [point]=&quot;marker.point&quot; [options]=&quot;marker.options&quot; (clicked)=&quot;showWindow($event)&quot; (loaded)=&quot;markerLoaded($event)&quot; &gt;&lt;/marker&gt; &lt;/baidu-map&gt; //map.component.ts public controlOpts: NavigationControlOptions; public overviewmapOpts: OverviewMapControlOptions; public scaleOpts: ScaleControlOptions; public mapTypeOpts: MapTypeControlOptions; public geolacOpts: GeolocationControlOptions; private BMAP_NAVIGATION_CONTROL_SMALL: any; public center: Point; public circleOptions: CircleOptions; public markers: Array&lt;{ point: Point; options?: MarkerOptions }&gt;; ngOnInit() { //添加控件 this.addNavigationControl(); this.addMapTypes(); this.addOverviewMap(); //添加标记 this.addCircle(); this.addMarker(); } addNavigationControl() { this.controlOpts = { anchor: ControlAnchor.BMAP_ANCHOR_TOP_LEFT, type: NavigationControlType.BMAP_NAVIGATION_CONTROL_SMALL, enableGeolocation: true }; } addMapTypes() { this.mapTypeOpts = { type: MapTypeControlType.BMAP_MAPTYPE_CONTROL_MAP, mapTypes: [MapTypeEnum.BMAP_NORMAL_MAP, MapTypeEnum.BMAP_SATELLITE_MAP] } } addOverviewMap() { this.overviewmapOpts = { anchor: ControlAnchor.BMAP_ANCHOR_BOTTOM_RIGHT, isOpen: this.showFlagss.overview } } mapLoaded(emap: any) { this.mapInstance = emap; } addCircle() { this.center = { lat: 30.241628, lng: 120.138121 }; this.circleOptions = { strokeColor: &apos;blue&apos;, strokeWeight: 2, strokeOpacity:0.3 }; } addMarker() { this.markers = [ { point: { lat: 30.241628, lng: 120.138121 } }, { options: { icon: { imageUrl: &apos;***.jpg&apos;, size: { height: 80, width: 50 }, imageSize: { height: 80, width: 50 }, imageOffset: { height: 0, width: 0 } } }, point: { lat: 30.3006, lng: 120.200 } } ] } circleLoaded(circle: BCircle) { this.circleIntance = circle; if(!this.showFlagss.maker) { this.circleIntance.hide(); } } 效果如： 百度地图-使用模块包 需要更多地图效果可参考: angular2-baidu-map angular2-baidu-map封装了常用的百度地图的接口，但与百度原生API相比，少了很多的使用api，比如城市列表，热力图等，可根据需求选择使用","tags":[{"name":"angular","slug":"angular","permalink":"http://blueskyawen.com/tags/angular/"}]},{"title":"PWA与angular中的Service Worker","date":"2019-02-15T11:14:09.000Z","path":"2019/02/15/PWA-and-service-worker-in-angular/","text":"PWA是什么PWA，全称Progressive Web Apps，是一种接近原生用户体验的渐进增强的 Web 应用，利用现代浏览器特性从安全、性能和体验三个方面，优化我们的Web AppPWA不是某一项技术,而是一系列Web技术与标准的集合与应用,由Google在2015年提出，旨在渐进增强，不是替代现有的移动App，而是让web应用有媲美原生应用的体验，更加对移动环境友好 应用场景PWA主要应用于移动应用的开发，当前APP对设备内存等资源的需求量越来越大，PWA是颠覆者，旨解决移动设备的硬件限制，以及网络状况不佳下的服务访问 技术特点PWA之所以能够成为未来的趋势，被广大开发者推崇，还是因为其具有一些优秀的技术特点： 安全，通过 HTTPS 来提供服务来防止网络窥探，保证内容不被篡改 渐进式，适用于任何设备，无论用户使用什么浏览器 响应式，适应任何环境：桌面电脑、智能手机、平板电脑，或者其他设备 轻量，web应用更加轻量级，整个APP都在KB占用内，这是原生APP无法比及的 离线支持，支持资源缓存，可以在离线或者低质量网络下工作 类APP体验，有像原生应用般的体验，可将应用添加到主屏，甚至可以提供没有地址栏的全屏体验 可安装，设备浏览器可提示用户安装web应用或添加到主屏上，不需要通过应用商店下载 持续更新，受益于service worker的更新进程，应用能够始终保持更新 可发现，可识别为“应用程序”，让搜索引擎能够找到 web 应用 可再次访问，通过 URL 可以轻松分享应用，不用复杂的安装即可运行 可链接，通过 HTTPS 来提供服务来防止网络窥探，保证内容不被篡改 这些技术特点足以让PWA媲美任何一种原生技术开发的移动app，甚至体验更好。除了优秀的使用特点之外，由于PWA属于web应用，对于开发者也带来极大的好处，降低了开发门槛 PWA的核心技术PWA的几个关键技术的应用，保证了PWA能够提供期望的性能体验 Manifest，定义APP图标、标题栏颜色和主题等信息 Service Worker，管理缓存，离线开发，地理位置信息处理以及app更新等 App Shell，先显示APP的主结构，再填充主数据，更快显示更好体验 Push &amp; Notification – 消息推送和通知 ManifestManifest是一个JSON文件，定义了此Web应用的基本配置、主题颜色等，甚至可以设置横/竖屏、全屏显示 { &quot;name&quot;: &quot;PWA Website&quot;, &quot;short_name&quot;: &quot;PWA&quot;, &quot;description&quot;: &quot;An example PWA website&quot;, &quot;start_url&quot;: &quot;/&quot;, &quot;display&quot;: &quot;standalone&quot;, &quot;orientation&quot;: &quot;any&quot;, &quot;background_color&quot;: &quot;#fff&quot;, &quot;theme_color&quot; : &quot;#fff&quot;, &quot;icons&quot;: [ { &quot;src&quot; : &quot;/images/logo/logo072.png&quot;, &quot;sizes&quot; : &quot;72x72&quot;, &quot;type&quot; : &quot;image/png&quot; }, { &quot;src&quot; : &quot;/images/logo/logo152.png&quot;, &quot;sizes&quot; : &quot;152x152&quot;, &quot;type&quot; : &quot;image/png&quot; }, { &quot;src&quot; : &quot;/images/logo/logo192.png&quot;, &quot;sizes&quot; : &quot;192x192&quot;, &quot;type&quot; : &quot;image/png&quot; }, { &quot;src&quot; : &quot;/images/logo/logo256.png&quot;, &quot;sizes&quot; : &quot;256x256&quot;, &quot;type&quot; : &quot;image/png&quot; }, { &quot;src&quot; : &quot;/images/logo/logo512.png&quot;, &quot;sizes&quot; : &quot;512x512&quot;, &quot;type&quot; : &quot;image/png&quot; } ] } 应该要在头中引用这个文件 &lt;link rel=&quot;manifest&quot; href=&quot;/manifest.json&quot;&gt; 其中， name，应用名称 short_name，应用短名称。 description，应用描述。 start_url，应用起始路径，相对路径，默认为/ scope，URL范围 background_color，欢迎页面的背景颜色和浏览器的背景颜色（可选） theme_color，应用的主题颜色，一般都会和背景颜色一样 orientation，优先旋转方向，可选的值有：any, natural, landscape等 display，显示方式，fullscreen（无Chrome），standalone（和原生应用一样），minimal-ui（最小的一套UI控件集）或者 browser（最古老的使用浏览器标签显示） icons，所有图片的数组，每个元素包含了图片的URL，大小和类型 通过manifest.json文件配置，可以设置应用的启动画面、背景图、应用名称，还可以支持应用在主屏桌面上添加一个快捷方式，以方便用户快速访问，用户访问web应用时，直接在界面中提示添加到主屏桌面，但是目前支持此功能的浏览器不多，安卓手机上须使用57版本以上的谷歌浏览器可以支持该功能，而移动端IOS系统的支持并不好参考可访问pwa-demo Service WorkerService Worker是PWA中必不可少的一个服务，主要提供资源缓存、离线访问等功能，并可动态进行数据更新简单来说，Service Worker 就是一段运行在 Web 浏览器中，并为应用管理缓存的脚本，会拦截所有由应用发出的 HTTP 请求，并选择如何给出响应下图展示普通Web App与添加了Service Worker的Web App的差异: 其中,Service Worker充当了一个“客户端代理”角色 Service Worker是可编程的，我们可以注册他 window.addEventListener(&apos;DOMContentLoaded&apos;, function() { if(&apos;serviceWorker&apos; in navigator) { navigator.serviceWorker.register(&apos;/service-worker.js&apos;) .then(registration =&gt; { ... }).catch(error =&gt; { ... }); } }); 注册了Service Worker后，它会经历生命周期的各个阶段，同时会触发相应的事件。整个生命周期包括： installing --&gt; installed --&gt; activating --&gt; activated --&gt; redundant。 用户可以介入周期过程，比如使用event.waitUntil()方法在install事件前处理一些事情，并返回Primise通知服务继续下一阶段；此外，SW还有事件fetch，使用它可以方便的拦截请求和访问缓存具体不详述，这里有一篇比较详细的文章介绍SW的Service Worker全面进阶参考可访问pwa-demo Push &amp; NotificationPush 和 Notification 是两个不同的功能，涉及到两个 API， 不过将两者相结合是一种常见的使用模式。 Push：服务器端将更新的信息传递给 SW Notification： SW 将更新的信息推送给用户。 这个能力让我们可以从服务端向用户推送各类消息并引导用户触发相应交互 1. Push根据Web Push协议草案描述，整个Push流程是这样的 其中，“UA”就是我们的用户客户端，也就是浏览器；“Application Server”是后端服务；“Push Service”作为中间代理商，扮演着核心角色。Push Service接收客户端的消息订阅，维护管理“客户端url-公钥”对的列表，并将订阅和私钥信息发送给服务器进行存储；此外，它后续还得接收服务端的推送消息，校验并发送给对象的客户端进行展示。Push Service还有一个非常重要的功能：当用户离线时，可以帮我们保存消息队列，直到用户联网后再发送给他们。目前，不同的浏览器厂商使用了不同的Push Service，chrome使用了自家的FCM，firefox也是使用自家的服务，不同push服务遵循共同的Web Push协议，具有标准的调用方式。但是，目前chrome的FCM在国内不可访问，因此我是使用firefox来调试demo的，在 firefox开发者工具的“service workers”里可以看到对应的Push Service 点“start”启动，“调试”进去开发调试，可以试用这个图书搜索demo,通过restclient模拟后端发送推送消息，最后的效果是这样的 通过消息推送API能实现跟原生APP一样消息的体验，但是，国内的PWA应用还不支持这种即时推送，在国外像Facebook、Twitter就做的非常好。 2. NotificationNotification通知的功能与消息push类似，但更为简单，只要设置好通知消息，调用sw的相同通知接口即可，甚至可以可以带操作，但目前浏览器的支持并不好，火狐支持部分功能，不支持操作action可以试用图书搜索demo，通过页面按钮添加提醒通知Notification api可以单独使用，也可以和push一块使用，两者虽然相似，并不矛盾 3. 后台同步后台同步是Service Worker的一个子功能，用于在终端弱网或无王情况下同步后台的数据或继续前端的请求消息由于SW在浏览器关闭后仍然运行着，所以即使用户没有网络或关闭客户端，SW仍会存储相应的请求，并在有可用网络连接时发起数据同步，同步的浏览大概是这样的 可以看到，当浏览器触发了sync事件后，剩下的就交给SW了，比较常用的一个场景：当用户离开时页面（unload）时在client端触发sync事件。详细的文章介绍SW的Service Worker全面进阶试用这个图书搜索demo,目前支持后台的客户端很少，只有chorme支持 APP ShellApp Shell架构是构建 PWA 应用的一种方式，它通常提供了一个最基本的 Web App 框架，包括应用的头部、底部、菜单栏等结构顾名思义，我们可以把它理解成应用的一个「空壳」，这个「空壳」仅包含页面框架所需的最基本的 HTML 片段，CSS 和 javaScript，这样一来，用户重复打开应用时就能迅速地看到 Web App 的基本界面，只需要从网络中请求、加载必要的内容。我们使用 Service Worker 对 App Shell 做离线缓存，以便它可以在离线时正常展现，达到类似 Native App 的体验。开发一个 App Shell, 我们通常要注意以下几点： 将动态内容与 Shell 分离 尽可能使用较少的数据，实现快速加载 使用本地缓存中的静态资源 PWA的发展现状及挑战PWA由谷歌和W3C强力推广，在国外已经是百花齐放，众多的公共应用和知名APP都提供了PWA的版本，比如：推特，Instagram，Flipboard等，并且据说用户体验与原生App相差不大但是目前在国内的发展并不明显，主要有几个原因 作为谷歌的竞争者，苹果态度不明确，支持力度不够 国内互联网巨头BAT的挑战，比如：微信小程序，支付宝小程序，凭借强大的用户群体，推广起来非常顺畅 移动硬件设备的升级，网络的完善以及随处可见的wifi，使得用户对PWA的需求并没有那么的强烈 虽然在国内知名网站和APP已经陆续有了PWA版本，但是根据个人的使用来讲，真正的PWA应用很少，大部分也只是实现了部分的PWA技术，比如service worker,大家在访问一些网站是可以在开发者工具看到一些运行中的service worker 但是,只有service worker,没有支持Manifest,消息推送通知等，而且大部分浏览器对即时通知等技术的支持并不好目前支持最好最全的应该是新浪微博，而且在使用上个人感觉和APP还是有一点差距的,总之，在国内的发展仍然挑战很大 应用体验- 手机登录 https://pwa.rocks/，这个网址有很多pwa应用 - 国内大厂的APP：阿里巴巴 http://m.alibaba.com，新浪微博 https://m.weibo.cn/beta?pwa=1 PWA的实现实现一个PWA主要是实现它所需的特性，实现Service Workers基于事件的cache 系统和消息推送的一套新的API，此外还需要定义 manifest.json 来定义安装行为或是样式等个人在学习中输出了一些demo: pwa-demo2 PWA-demo book-pwa-demo 此外，还把boot-shadow插件库的demo网页进行了PWA改造，支持离线访问boot-shadow(pwa) 以上均可以再移动端和桌面客户端访问 Angular的Service Worker实现Service Worker是PWA中必不可少的一部分，可提供资源缓存、离线访问等功能,Service Worker会在首次访问时加载，之后可直接访问，即使关闭了浏览器标签使用Service Worker主要是为了改善应用对网络的依赖，提高用户体验 应用Angular的Service Worker会从服务器上下载一个manifest文件，这个 文件描述了要缓存的资源，并包含每个文件内容的哈希值。 当发布了应用的一个新版本时，manifest的内容就会改变，通知 Service Worker 应该下载并缓存应用的一个新版本了Angular使用文件ngsw-config.json来配置Service Worker，指定需呀缓存那些资源以及其它的行为设定，而本应该最终要缓存的资源会记录到生成的ngsw.json文件里 使用在Angular中使用Service Worker像引入一个 NgModule 一样简单 import { BrowserModule } from &apos;@angular/platform-browser&apos;; import { NgModule } from &apos;@angular/core&apos;; import { AppComponent } from &apos;./app.component&apos;; import { ServiceWorkerModule } from &apos;@angular/service-worker&apos;; import { environment } from &apos;../environments/environment&apos;; @NgModule({ declarations: [ AppComponent ], imports: [ BrowserModule, ServiceWorkerModule.register(&apos;/ngsw-worker.js&apos;, { enabled: environment.production }) ], providers: [], bootstrap: [AppComponent] }) export class AppModule { } 除此之外，ServiceWorkerModule还提供了一些其他的服务来与 Service Worker 进行通信交互， 比如SwUpdate 服务就可以用来要求Service Worker检查和激活更新，并接收响应的版本更新和激活成的通知 import { interval } from &apos;rxjs&apos;; @Injectable() export class LogUpdateService { constructor(updates: SwUpdate) { this.registerUpEvent(); this.startUpdateCheck(); } registerUpEvent() { this.updates.available.subscribe(event =&gt; { console.log(&apos;current version is&apos;, event.current); console.log(&apos;available version is&apos;, event.available); if (promptUser(event)) { this.updates.activateUpdate().then(() =&gt; document.location.reload()); } }); this.updates.activated.subscribe(event =&gt; { console.log(&apos;old version was&apos;, event.previous); console.log(&apos;new version is&apos;, event.current); }); } startUpdateCheck() { interval(6 * 60 * 60).subscribe(() =&gt; updates.checkForUpdate()); } } 更新由于Service Worker使得应用是可以离线运行的，即使本地停止了服务，故应用的版本和清单文件可以随时更新变动。而当用户打开或刷新应用程序时，通过查看清单（manifest）文件 “ngsw.json” 的更新来检查该应用程序的更新。如果找到了更新，就会自动下载并缓存这个版本，并在下次加载应用程序时提供。此外，用户也手动可以新版本的检查和激活，或定时进行类似操作，确保更新的内容能及时获得，就像上面做的一样 ngsw-config配置Angular使用文件ngsw-config.json来管理应用的缓存，可以配置它来处理相应的资源存储，详细参考官网Service Worker 配置","tags":[{"name":"angular","slug":"angular","permalink":"http://blueskyawen.com/tags/angular/"}]},{"title":"angular-http拦截","date":"2019-01-29T13:27:00.000Z","path":"2019/01/29/angular-http-interface/","text":"在客户端和服务器进行http交互，人们能够对过程进行一定程度的干预，也希望这么做，比如：对http的响应进行修缮，或者对请求头设置维护等。这很有用，XSRF攻击的通用防范手段就是通过增加头部的token来和服务器进行访问验证的实现这种目的最简单的方式就是在每次http请求的前后增加预处理，比如： const httpOptions = { headers: new HttpHeaders({ &apos;Content-Type&apos;: &apos;application/json&apos;, &apos;Authorization&apos;: &apos;my-auth-token&apos; }) }; this.http.post(url,data,httpOptions).pipe( map(...) //响应处理 ); 这个对于有特殊处理方式的请求可以的，但是对于那些通用的处理太繁琐了，维护困难，于是边有了更加通用的处理手段：代理服务和http拦截器 代理服务基于设计里的代理模式，这是包装原有http服务的一种手段，通过提供一个新服务来处理http请求和响应结果，接口和原http服务一致下面是典型的代理http服务 import { Injectable } from &apos;@angular/core&apos;; import { Headers, Http, ResponseContentType,HttpErrorResponse } from &apos;@angular/http&apos;; import { AuthService } from &apos;./AuthService.service&apos;; import { Router } from &apos;@angular/router&apos;; import { Observable } from &apos;rxjs/Observable&apos;; import &apos;./rxjs-operators&apos;; @Injectable({ providedIn: &apos;root&apos; }) export class HttpApiService { token: any; headers: any = null; lang: any; constructor(private http: Http, private authService: AuthService, private router: Router) { this.token = this.authService.getToken(); this.lang = this.authService.getLang(); this.headers = new Headers({ &apos;token&apos;:this.token, &apos;language&apos;:this.lang }); } get(url: any, params?: any) { let paramOption = params ? new HttpParams(params) : {}; return this.http.get(url,paramOption).pipe( catchError(this.handleError) ); } post(url: any, data: any, params?: any) { let paramOption = params ? new HttpParams(params) : {}; return this.http.post(url,data,paramOption).pipe( catchError(this.handleError) ); } delete(url: any) { return this.http.delete(url).pipe( catchError(this.handleError) ); } put(url: any, data: any, params?: any) { let paramOption = params ? new HttpParams(params) : {}; return this.http.put(url,data,paramOption).pipe( catchError(this.handleError) ); } handleError(error: HttpErrorResponse,result ?: any) { let errorMsg : string; if (error.error instanceof ErrorEvent) { errorMsg = &apos;An error occurred:&apos; + error.error.message; } else { switch (error.status) { case 500: errorMsg = &apos;内部服务错误,错误信息:&apos; + error.error; break; case 401: errorMsg = &apos;无访问权限,错误信息:&apos; + error.error; break; case 404: errorMsg = &apos;页面不存在,错误信息:&apos; + error.error; break; default: errorMsg = &apos;其他错误,错误信息:&apos; + error.error; } } return result ? Observable.of(result) : Observable.throwError(errorMsg); } } 使用http代理服务 import { HttpApiService as Http } from &apos;../../apiResource.service&apos;; constructor(private http : Http) {} getItems() { this.http.get(url).subscribe(res =&gt; { this.items = res; },error =&gt; { this.error = error; }); } addItem() { this.http.post(url,this.data).subscribe(res =&gt; { this.items = res; },error =&gt; { this.error = error; }); } deleteItem() { this.http.delete(url).subscribe(); } 拦截器HTTP 拦截机制是angular的主要特性之一，使用这种拦截机制，你可以声明一些拦截器，用它们监视和转换从应用发送到服务器的 HTTP 请求，还可以用监视和转换从服务器返回到本应用的那些响应所以，利用好这个特性，便可以使用原始http的情况下也能进行预处理和响应转换了 编写拦截器拦截器的实现很简单，就要实现一个HttpInterceptor接口中的intercept() 方法即可 import { Injectable } from &apos;@angular/core&apos;; import {HttpEvent, HttpInterceptor,HttpHandler, HttpRequest,HttpResponse} from &apos;@angular/common/http&apos;; @Injectable() export class LoggingInterceptor implements HttpInterceptor { constructor() {} intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler):Observable&lt;HttpEvent&lt;any&gt;&gt; { ...doing something before send req... return next.handle(req).pipe( ..doing something width response.. ); } } 可以看到： 拦截器一般以Interceptor结尾命名，继承接口HttpInterceptor，实现intercept方法 拦截器在拿到req之后可以做一些预处理，然后再交给下一个拦截器或后端服务器 使用next.handle()方法将请求交给下一个拦截器或服务器，next指的就是下个拦截器对象，handle方法的最后一个next是后端服务器 拦截器在得到响应之后可以做数据处理，然后再把响应信息交给用户 下面是实现上面代理服务功能的一些拦截器： 添加请求头 import { Injectable } from &apos;@angular/core&apos;; import {HttpEvent, HttpInterceptor, HttpHandler, HttpRequest} from &apos;@angular/common/http&apos;; @Injectable() export class AuthInterceptor implements HttpInterceptor { constructor(private authService: AuthService) {} intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; { let token = this.authService.getToken(); let lang = this.authService.getLang(); let tmpHeaders = req.headers.set(&apos;token&apos;,token) .set(&apos;language&apos;,this.lang); let authReq = req.clone({ headers: tmpHeaders}); return next.handle(req); } } 注意: Headers是不可变的，不能直接修改它，可复制修改后再赋值 修改请求体 import { Injectable } from &apos;@angular/core&apos;; import {HttpEvent, HttpInterceptor, HttpHandler, HttpRequest} from &apos;@angular/common/http&apos;; @Injectable() export class ReqModifyInterceptor implements HttpInterceptor { intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; { const secureReq = req.clone({ url: req.url.replace(&apos;http://&apos;, &apos;https://&apos;) }); return next.handle(secureReq); } } HttpReques和HttpResponse是不可变的，不能直接修改它，可复制修改后再赋值 耗时记录 import { Injectable } from &apos;@angular/core&apos;; import {HttpEvent, HttpInterceptor, HttpHandler, HttpRequest, HttpResponse} from &apos;@angular/common/http&apos;; import { finalize, tap } from &apos;rxjs/operators&apos;; import { Observable } from &apos;rxjs&apos;; @Injectable() export class TimingInterceptor implements HttpInterceptor { intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; { let started = Date.now(); let state: string; return next.handle(req).pipe( tap(event =&gt; ok = event instanceof HttpResponse ? &apos;succeeded&apos; : &apos;&apos;, error =&gt; ok = &apos;failed&apos;), finalize(() =&gt; { let elapsed = Date.now() - started; const msg = `${req.method} &quot;${req.urlWithParams}&quot; ${ok} in ${elapsed} ms.`; console.log(msg); }) ); } } 错误捕获 import { Injectable } from &apos;@angular/core&apos;; import {HttpEvent, HttpInterceptor, HttpHandler, HttpErrorResponse, HttpRequest, HttpResponse} from &apos;@angular/common/http&apos;; import { finalize, tap } from &apos;rxjs/operators&apos;; import { Observable } from &apos;rxjs&apos;; @Injectable() export class ErrorCatchInterceptor implements HttpInterceptor { let errorMsg : string; intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; { return next.handle(req).pipe( catchError((error: HttpErrorResponse) =&gt; { if (error.error instanceof ErrorEvent) { errorMsg = &apos;An error occurred:&apos; + error.error.message; } else { switch (error.status) { case 500: errorMsg = &apos;内部服务错误,错误信息:&apos; + error.error; break; case 401: errorMsg = &apos;无访问权限,错误信息:&apos; + error.error; break; case 404: errorMsg = &apos;页面不存在,错误信息:&apos; + error.error; break; default: errorMsg = &apos;其他错误,错误信息:&apos; + error.error; } } return result ? Observable.of(result) : Observable.throwError(errorMsg); }) ); } } 注册拦截器拦截器也是服务，需要将其注册到注入器以后才能使用，而且由于他们是和http配和使用的，所以必须在httpClient服务注册的同一级提供这些拦截器服务，否则不生效。比如，当httpClient注入到根注入器后，拦截器也应该注入到根注入器，下面都注入根 //interceptor-index.ts import { HTTP_INTERCEPTORS } from &apos;@angular/common/http&apos;; import { AuthInterceptor } from &apos;./auth-interceptor&apos;; import { ReqModifyInterceptor } from &apos;./req-modify-interceptor&apos;; import { TimingInterceptor } from &apos;./timing-interceptor&apos;; import { ErrorCatchInterceptor } from &apos;./error-catch-interceptor&apos;; export const httpInterceptorProviders = [ { provide: HTTP_INTERCEPTORS, useClass: AuthInterceptor, multi: true }, { provide: HTTP_INTERCEPTORS, useClass: ReqModifyInterceptor, multi: true }, { provide: HTTP_INTERCEPTORS, useClass: TimingInterceptor, multi: true }, { provide: HTTP_INTERCEPTORS, useClass: ErrorCatchInterceptor, multi: true } ]; //core.module.ts import { NgModule } from &apos;@angular/core&apos;; import { CommonModule } from &apos;@angular/common&apos;; import { HttpClientModule } from &apos;@angular/common/http&apos;; import { httpInterceptorProviders } from &apos;./interceptor-index&apos;; @NgModule({ declarations: [], imports: [ CommonModule ], exports: [HttpClientModule], providers: [httpInterceptorProviders] }) export class CoreModule { } 可以看到： 拦截器是以数组形式提供的，multi: true代表一个多重提供商的令牌，即一个令牌注入注入多数组 多个拦截器按顺序从上往下进行注册，一次请求过程中拦截器的处理顺序也是从上往下传递的，响应的方向正好相反，如下示意图 示例头配置Txt文档下载文件上传npm包搜索","tags":[{"name":"angular","slug":"angular","permalink":"http://blueskyawen.com/tags/angular/"}]},{"title":"angular-新特性","date":"2019-01-23T15:30:11.000Z","path":"2019/01/23/angular-new-fetures/","text":"依赖注入在新版本中，注入提供了providedIn字段，可以指定某个服务属于根注入器，下面两种方式效果是一样的：像下面这样写标记服务注入根注入器： @Injectable({ providedIn: &apos;root&apos;, }) 但是要注意的几点是： 1) providedIn主要应用于懒加载模块，由于懒加载模块存在自己的子注入器，有时候服务的实例会存在多份，providedIn可用于将懒加载模块内的服务声明为注入到根注入器，从而全局单实例，及时服务本身是懒加载的2) providedIn也可以用在懒加载模块内的服务的供应商的声明，比如：providedIn: UserModule,和在@NgModule的providers数组声明效果一样3) 非懒加载模块，即直接import进根模块的特性模块，服务的供应商不能使用：providedIn：模块名 来声明，否则会报错找不到provider;原因是这种模块的供应商天然是注入懂啊根注入器的，所以应该像下面这样写： 理论上，通过“providedIn”服务可以指定限制模块内，比如下面两种写法效果是一致的： //方式一 providedIn: &apos;root&apos; 或 在@NgModule的providers数组声明 import { Injectable } from &apos;@angular/core&apos;; import { UserModule } from &apos;./user.module&apos;; @Injectable({ providedIn: UserModule, }) export class UserService { } //方式二 import { Injectable } from &apos;@angular/core&apos;; import { UserModule } from &apos;./user.module&apos;; @Injectable() export class UserService { } import { NgModule } from &apos;@angular/core&apos;; import { UserService } from &apos;./user.service&apos;; @NgModule({ providers: [UserService], }) export class UserModule { } 官方推荐采用方法一，是因为指定了固定模块生效，当没有人注入它时，该服务就可以被摇树优化掉。但是在实践试用的过程中，这样使用极易出现模块的循环引入，导致出错，不推荐使用！ RXJSpipe()pipe函数可以组合observer的各自操作符的链式调用，下面两种方式效果相同 const squareOdd = Observer.of(1, 2, 3, 4, 5) .pipe( filter(n =&gt; n % 2 !== 0), map(n =&gt; n * n) ); const squareOdd = Observer.of(1, 2, 3, 4, 5) .filter(n =&gt; n % 2 !== 0) .map(n =&gt; n * n); catchError()新版使用catchError方法来捕捉错误，使用retry来重试 ajax(&apos;/api/data&apos;).pipe( retry(3), map(res =&gt; { if (!res.response) { throw new Error(&apos;Value expected!&apos;); } return res.response; }), catchError(err =&gt; of([])) ); 组件样式CSS 标准中用于 “刺穿 Shadow DOM” 的组合器已经被废弃，并将这个特性从主流浏览器和工具中移除，Angular将移除对它们的支持（包括 /deep/、&gt;&gt;&gt; 和 ::ng-deep）。 目前，建议先统一使用 ::ng-deep，以便兼容将来的工具。 单例导入static forRoot(config: UserServiceConfig): ModuleWithProviders { return { ngModule: CoreModule, providers: [ {provide: UserServiceConfig, useValue: config } ] }; } 8.模仿路由模块，实现模块的单例导入 static forRoot(config: UserServiceConfig): ModuleWithProviders { return { ngModule: CoreModule, providers: [ {provide: UserServiceConfig, useValue: config } ] }; } 安全访问操作符和非空断言操作符 安全访问操作符 ?. 保护出现在属性路径中 null 和 undefined 值,比如：hero?.name 非空断言操作符 !. 明确告诉类型检查器，访问的属性它不会为空，比如：hero!.name 类型转换函数 $any使用方式： $any(&lt;表达式&gt;）绑定表达式可能会报类型错误，并且它不能或很难指定类型。要消除这种报错，你可以使用 $any 转换函数来把表达式转换成 any 类型 &lt;div&gt; The hero&apos;s marker is {{$any(hero).marker}} &lt;/div","tags":[{"name":"angular","slug":"angular","permalink":"http://blueskyawen.com/tags/angular/"}]},{"title":"自定义元素","date":"2019-01-20T09:29:14.000Z","path":"2019/01/20/angular-custom-element/","text":"angular支持自定义标签元素，也就是组件。之前我们说过，组件是注册在注入器中的，由注入器在使用时自动注入实例。同样的，我们也可以手动的注册他们，在引用时得到实例并添加到视图中，便是所谓的“自定义元素”。 自定义元素创建 使用createCustomElement()方法把 Angular 组件及其依赖转换成自定义元素，该方法会收集该组件的 Observable 型属性，提供浏览器创建和销毁实例时所需的 Angular 功能，并对变更进行检测并做出响应；同时，在这个转换过程实现了NgElementConstructor 接口，并创建了一个构造器类，用于生成该组件的一个自举型实例 使用customElements.define() 函数把这个配置好的构造器和相关的自定义元素标签注册到浏览器的 CustomElementRegistry 中， 当浏览器遇到这个已注册元素的标签时，就会使用该构造器来创建一个自定义元素的实例 为组件元素添加事件处理 设置组件素元属性 添加组件元素到模板中 下面是一个简单代码段： import { Component,ApplicationRef, ComponentFactoryResolver, Injector } from &apos;@angular/core&apos;; import { createCustomElement,NgElement, WithProperties } from &apos;@angular/elements&apos;; import { PopupComponent } from &apos;./popup.component&apos;; @Component({ selector: &apos;app-custom-element&apos;, templateUrl: &apos;./custom-element.component.html&apos;, styleUrls: [&apos;./custom-element.component.less&apos;] }) export class CustomElementComponent { message : string = &apos;AAAAA&apos;; show : boolean = false; constructor(public injector: Injector, private applicationRef: ApplicationRef, private componentFactoryResolver: ComponentFactoryResolver) { //把组件转换成web元素 const PopupElement = createCustomElement(PopupComponent, {injector: this.injector}); //把自定义元素注册到浏览器，popup-element就是可识别自定义标签 customElements.define(&apos;popup-element&apos;, PopupElement); } } 自定义元素使用在使用自定义元素之前，首首先在项目目录执行下面命令 ng add @angular/elements 这会为项目安装为elements和document-register-element.js，以及其他依赖项 由于web component是es6的特性，还要修改tsconfig.json文件，否则会报错 { ... &quot;compilerOptions&quot;: { ... &quot;target&quot;: &quot;es6&quot;, ... } } 1) 手动创建元素并添加到文档//custom-element.component.html &lt;nc-input [type]=&quot;&apos;text&apos;&quot; [(modelValue)]=&quot;message&quot; [required]=&quot;true&quot;&gt; &lt;nc-button (click)=&quot;showAsElement()&quot;&gt;自定义元素&lt;/nc-button&gt; &lt;div id=&quot;customEle&quot;&gt;&lt;/div&gt; //custom-element.component.ts import { Component,ApplicationRef, ComponentFactoryResolver, Injectable, Injector } from &apos;@angular/core&apos;; import { createCustomElement,NgElement, WithProperties } from &apos;@angular/elements&apos;; import { PopupComponent } from &apos;./popup.component&apos;; @Component({ selector: &apos;app-custom-element&apos;, templateUrl: &apos;./custom-element.component.html&apos;, styleUrls: [&apos;./custom-element.component.less&apos;] }) export class CustomElementComponent { message : string = &apos;AAAAA&apos;; constructor(public injector: Injector, private applicationRef: ApplicationRef, private componentFactoryResolver: ComponentFactoryResolver) { const PopupElement = createCustomElement(PopupComponent, {injector: this.injector}); customElements.define(&apos;popup-element&apos;, PopupElement); } showAsElement() { const popupEl: NgElement &amp; WithProperties&lt;PopupComponent&gt; = document.createElement(&apos;popup-element&apos;) as any; popupEl.addEventListener(&apos;closed&apos;, () =&gt; document.getElementById(&apos;customEle&apos;).removeChild(popupEl)); popupEl.message = &apos;Popup by 自定义元素: &apos; + this.message; document.getElementById(&apos;customEle&apos;).appendChild(popupEl); } } 2) 使用注册的自定义标签我们知道使用组件的selector标识符可以在html文档中使用它里创建组件实例，这一切都是angular自动做的。同样，既然我们这里也创建了自定义元素，并把标签注册到了浏览器，我们也可以直接使用这个标签，要想在整个模块里都能只有该自定义元素，就应该在模块里创建和注册它 import { NgModule,Injector } from &apos;@angular/core&apos;; import { createCustomElement} from &apos;@angular/elements&apos;; @NgModule({ ... }) export class BasicCookModule { constructor(public injector: Injector) { const PopupElement = createCustomElement(PopupComponent, {injector: this.injector}); customElements.define(&apos;popup-element&apos;, PopupElement); } } 如果要直接使用自定义元素标签的话，还需要在模块引入CUSTOM_ELEMENTS_SCHEMA到@NgModule.schema中，否则会报找不到该标签的错 import { CUSTOM_ELEMENTS_SCHEMA } from &apos;@angular/core&apos;; @NgModule({ ... schemas: [ CUSTOM_ELEMENTS_SCHEMA ] }) 其中@NgModule.schema， schemas : Array&lt;SchemaMetadata|any[]&gt; 代表声明在Angular中使用的非组件，CUSTOM_ELEMENTS_SCHEMA表示任意元素（元素标签）和属性 这个自定义元素的标签就是customElements.define()里注册的第一个参数，上边例子就是popup-element，于是就可以子模板中直接使用它 &lt;popup-element&gt;&lt;/popup-element&gt; 点击这里查看自定义元素的一个例子 浏览器支持由于自定义元素要求浏览器有web component特性，目前支持的有：Chrome/Opera/Safari，Firefox在63版本以上支持如果使用中出现以下错误，请检查下浏览器版本 ERROR TypeError: this.ngElementStrategy is undefined","tags":[{"name":"angular","slug":"angular","permalink":"http://blueskyawen.com/tags/angular/"}]},{"title":"深入理解box-shadow","date":"2019-01-17T17:55:32.000Z","path":"2019/01/18/go-detail-to-box-shadow/","text":"之前有介绍过box-shadow这个属性，目的为框盒子添加阴影，也了解一些使用方式，使用起来也不是十分复杂。但是最近在开展单位的前端cop项目时，发现此属性不简单，还可以这样用，而且会发现一些看似复杂好玩的东西竟然是用box-shadow实现的。网上介绍这个属性的大部分文章都是介绍怎么使用，各个属性值怎么设置会有如何的效果之类的，少有深入探讨，感觉读完之后知其然，却不知所以然，无法清晰融会。于是下来好好研究了一下，记录如下。 使用语法： box-shadow: x-shadow y-shadow blur-radius spread-radius color type; 各属性值含义： x-shadow：水平阴影的偏移，当值为正时，阴影往x轴正向偏移,即水平向右；反之，值为负时，阴影往x轴反向偏移，即水平向左 y-shadow：垂直阴影的偏移，当值为正时，阴影往y轴正向偏移,即垂直向下；反之，值为负时，阴影往y轴反向偏移，即垂直向上 blur-radius：模糊距离，不能为负值；为0表示不模糊，值越大，阴影的边缘就越大，也就越模糊 spread-radius：阴影的尺寸，参数可选，不设置为0；正值表示阴影扩展，负值表示阴影反向缩小，可抵消偏移和模糊距离的尺寸 color：阴影的颜色，参数可选，不设置便使用浏览器的默认色，因为各浏览器的默认色不同，推荐还是设置一下 type：阴影类型，参数可选，不设置默认outset（外部阴影）， 还有inset（内部阴影） 外部阴影当type不设置或设置为outset时，是为外部阴影，例如： box-shadow: 5px 5px 5px 5px #ccc; box-shadow: 5px 5px 5px 5px #ccc outset; 外部阴影在浏览器渲染时一般是如下几步实现的， 根据color克隆一个和原始元素相同尺寸的元素“覆盖”其上 根据spread-radius向四周增加对应颜色的阴影，类似于“边框” 然后根据指定的x-shadow 和 x-shadow 将克隆出来的元素进行偏移 根据指定的blur-radius设置模糊半径，一般是依据高斯算法进行模糊处理，本质上是在阴影边缘将阴影色往纯透明色之间进行颜色过渡，所以看到是模糊是逐渐变淡的；而且据了解blur是沿边缘线两边各一半距离，并从里向外扩散 最后，将克隆元素与原始原属的交集“剪切”去，剩余部分便是最终阴影效果 各步大概的图示如下： 为了更加方便的观察这个原理，图中特意设置了透明度，可进入外部阴影观察动态效果 最终的阴影尺寸为： top阴影: spread-radius - y-shadow + blur-radius/2 left阴影: spread-radius - x-shadow + blur-radius/2 bottom阴影: spread-radius + y-shadow + blur-radius/2 right阴影: spread-radius + x-shadow + blur-radius/2 当模糊距离为0，只有spread-radius时，效果相当于border，但这并不是真正的border，盒子模型计算时宽高不会被计算在内 内部阴影当type设置为inset时，是为内部阴影，例如： box-shadow: 5px 5px 5px 5px #ccc inset; 个人理解，内部阴影在浏览器渲染时一般是如下几步实现的， 根据color克隆一个比原始元素相同尺寸大的元素“覆盖”其上 根据spread-radius向四周沿着border向内切割掉部分克隆的元素，留下对应尺寸的spread 然后根据指定的x-shadow 和 x-shadow 将克隆出来的元素进行偏移 根据指定的blur-radius设置模糊半径，一般是依据高斯算法进行模糊处理，本质上是在阴影边缘将阴影色往纯透明色之间进行颜色过渡，所以看到是模糊是逐渐变淡并向外扩散的 最后，将克隆元素在原始原始边框外面的部分“剪切”去，剩余部分便是最终阴影效果 各步大概的图示如下： 为了更加方便的观察这个原理，图中特意设置了透明度，可进入内部阴影观察动态效果 最终的阴影尺寸为： top阴影: spread-radius + y-shadow + blur-radius/2 left阴影: spread-radius + x-shadow + blur-radius/2 bottom阴影: spread-radius - y-shadow + blur-radius/2 right阴影: spread-radius - x-shadow + blur-radius/2 多个阴影及层级关系1） 多个阴影当多个阴影重叠时，声明在前面会覆盖后面的，比如： box-shadow: 0px 0px 5px 10px blue, 0px 0px 5px 20px red; 其中前面的蓝色阴影会覆盖后面的红色阴影 2） 层级关系有了框阴影，便有了内外阴影，元素边框，背景和内容等的呈现层级关系，一般为如下层级关系：border &gt; 内阴影 &gt; background-image &gt; background-color &gt; 外阴影 可以点击此处试一试： 内部阴影 附：box-shadow的demo","tags":[{"name":"CSS","slug":"CSS","permalink":"http://blueskyawen.com/tags/CSS/"}]},{"title":"元素的层叠","date":"2019-01-14T13:50:06.000Z","path":"2019/01/14/dom-and-stack/","text":"多个元素在一起难免出现先后和堆叠呈现问题，最近编写相关控件时遇到了类似的问题，查阅了许多资料理解了一些，顺便记录下来。 层叠说到元素的层叠，就不得不提到两个概念，叫堆叠上下文(Stacking Context)和堆叠水平，规范一点的解释可以参见下面的文档：z-index的工作原理我的理解，简单来讲： 堆叠上下文就是元素相对于用户的呈现平面，每个元素都有自己的堆叠平面 堆叠水平就是元素堆叠上下文的级别，每个元素都有上下文级别，可以和其他元素相同，也可以不同，这是决定元素是否“胜出”的关键，即哪些元素能够呈现在用户面前 普通元素拥有一个零级的上下文，而通过某些CSS属性可以为元素重新创建上下文，在其他资料里也都提过，主要有： 元素 被定位了的元素，并且拥有一个z-index值（不为auto） 元素被设置了opacity，transform, transform3d,filter, css-regions, paged media,motion-path,mix-blend-mode,will-change,-webkit-overflow-scrolling等属性 父元素的display设置了flex或者inline-flex值的子元素 父元素的display设置了grid或者inline-grid值的子元素 元素被设置了isolation:isolate 元素的mix-blend-mode值不为normal 元素的overflow-scrolling值不为touch 一旦多个元素设置了这些属性，页面变回创建出多个新的堆叠上下文平面，每个元素的上下文是独立存在的，并影响其中子元素的呈现效果，包括子元素建的“堆叠竞争”虽然页面里可以有许多的堆叠上下文元素，当由于呈现平面只有一个，最后只能有一个或者几个元素能够出现在用户面前，于是就有了规则顺序： 有明显的层叠水平标示的时候，比如由定位和z-index创建上下文的元素，则值越大越有机会胜出 对于层叠水平一样的几个元素，位置在后面的覆盖前面的，即所谓的“后来居上” 每个元素层叠上下文独立成型，子元素的层级显示手父元素的层级限制，子元素只会在父元素的层叠平面和水平上进行规则判决，即：如果父元素的层叠水平和其他元素一致，则子元素可和其他同级别元素的子元素竞争；否则，如果父元素创建了层叠上下文，子元素将只能在父元素层叠上下文平面内进行“内部竞争”，如果父元素层叠水平较低，子元素的z-index再高也是枉然 有层叠上下文的元素层叠水平要比普通元素高 这里有个例子， &lt;div&gt;&lt;span class=&quot;red&quot;&gt;Red&lt;/span&gt; &lt;/div&gt;&lt;div&gt; &lt;span class=&quot;green&quot;&gt;Green&lt;/span&gt; &lt;/div&gt;&lt;div&gt; &lt;span class=&quot;blue&quot;&gt;Blue&lt;/span&gt;&lt;/div&gt; div:nth-child(1) { background:red; position:absolute; //transform:scale(4); z-index:-1; } div:nth-child(2) { background:green; position:absolute; } div:nth-child(3) { background:blue; position:absolute; } div span { display:inline-block; height:60px; width:100px; background:#fff; } div { height:100px; display:block; width:200px; } .red { position:absolute; z-index:100; } 可以进去修改样式来查看效果：例子 关于层叠元素的显示顺序，张鑫旭的博客有个清晰的图片，可以直接查看深入理解CSS中的层叠上下文和层叠顺序 层叠带来的问题 z-index和定位的滥用导致页面元素层级混乱，普通元素单独设置z-index是没有用的,建议使用translateZ() 或者translate3d()来替代z-index transform变换的时候会让 z-index “临时失效”，其实并非 z-index 失效了，在变换的transform时创建了新的层叠上下，z-index生效在了一个新的不同的上下文平面上，当然等结束后又能回到正常的状态；至于怎么解决这个问题，张同学也给了参考意见：任意父级（非body级别）设置overflow:hidden 或者使用transform3d 通过z-index配合伪元素::before或者::after时让其z轴在元素的底部，特别是碰到大的元素渲染(比如全屏背景图)，会直接影响性能，特别是在移动端，会造成客户端闪退，也就是大家所说的Crash","tags":[{"name":"CSS","slug":"CSS","permalink":"http://blueskyawen.com/tags/CSS/"}]},{"title":"ng-template,ng-container和ng-content","date":"2018-12-17T13:57:49.000Z","path":"2018/12/17/ng-template-ng-container-and-ng-content/","text":"ng-template是一类html标签，是angular用来解释渲染结构性指令的一种方式，不会直接显示在html,最后会替换成同意义的注释；比如ngif中，当条件为false，angular将移除相应分支元素，取而代之的时一段注释这个标签直接单独使用的时候也有次效果，比如： &lt;ng-template&gt;&lt;p&gt;AA&lt;/p&gt;&lt;/ng-template&gt; 包裹的元素内容在渲染时会消失，而代之的是注释 （1）ng-template元素的访问可以使用viewChild装饰器来获取视图元素内容 &lt;ng-template #temp&gt;&lt;p&gt;AA&lt;/p&gt;&lt;/ng-template&gt; @ViewChild(&apos;temp&apos;) templ: TemplateRef&lt;any&gt;; @ViewChild(&apos;temp&apos;) temp2: ElementRef; this.templ.elementRef.nativeElement... ViewChild可使用模板引用变量、组件类型或查询条件来获取元素对象，详细可参考如下文章：Angular 2 ViewChild &amp; ViewChildren ng-container是一种不影响当前样式/布局的组合元素,angular只是用它来包裹控制内部元素的显示不显示，最后是不会添加渲染到DOM树上的，也不会有注释，使用起来就像普通语言中的if条件一样；它可直接包裹任何元素，包括文本 &lt;p&gt; I turned the corner &lt;ng-container *ngIf=&quot;hero&quot;&gt; and saw {{hero.name}}. I waved &lt;/ng-container&gt; and continued on my way. &lt;/p&gt; 有些元素不能直接使用其他标签包裹，比如select中的option，必须和select挨着，否则会出问题；这是不能使用ngif或ng-template，但可以使用ng-container，它不会有副作用，因为最后都会移除掉 &lt;select [(ngModel)]=&quot;hero&quot;&gt; &lt;ng-container *ngFor=&quot;let h of heroes&quot;&gt; &lt;ng-container *ngIf=&quot;showSad || h.emotion !== &apos;sad&apos;&quot;&gt; &lt;option [ngValue]=&quot;h&quot;&gt;{{h.name}} ({{h.emotion}})&lt;/option&gt; &lt;/ng-container&gt; &lt;/ng-container&gt; &lt;/select&gt; 会根据heros动态显示option,而所有的ng-container标签最后都会移除，否则会影响option显示 ng-contentng-content即内容投影，可以将外部的自定义内容投影到指定位置显示，常用于组件封装，比如： import { Component,OnInit,Input } from &apos;@angular/core&apos;; @Component({ selector: &apos;nc-form-group&apos;, template: `&lt;div class=&quot;nc-form-group&quot;&gt; &lt;ng-content select=&quot;nc-form-label&quot;&gt;&lt;/ng-content&gt; &lt;ng-content select=&quot;nc-form-control&quot;&gt;&lt;/ng-content&gt; &lt;ng-content select=&quot;.nc-form-error&quot;&gt;&lt;/ng-content&gt; &lt;/div&gt;` }) export class NcFormGroupComponent implements OnInit { @Input() width : string = &apos;470px&apos;; groupStyle : any = {}; constructor() {} ngOnInit() { this.groupStyle = {&apos;width&apos;: this.width}; } } 使用方式： &lt;nc-form-group&gt; &lt;nc-form-label&gt;用户名&lt;/nc-form-label&gt; &lt;nc-form-control&gt; &lt;input type=&quot;&apos;text&apos;&quot; [(modelValue)]=&quot;value&quot; /&gt; &lt;/nc-form-control&gt; &lt;div class=&quot;nc-form-error&quot;&gt;用户名&lt;/div&gt; &lt;/nc-form-group&gt; 注意： select可以使用任意可标识元素的选择器来指定 当不指定select或select书写错误的时候，元素将自动匹配到最后一个无select的ng-content 不会 “产生” 内容，它只是投影现有的内容，可以认为它等价于 appendChild(el)，节点不被克隆，它被简单地移动到它的新位置。因此，投影内容的生命周期将被绑定到它被声明的地方，而不是显示在地方 （1）与ng-container一起使用 &lt;nc-form-group&gt; &lt;nc-form-label&gt;用户名&lt;/nc-form-label&gt; &lt;ng-container ngProjectAs=&quot;nc-form-control&quot;&gt; &lt;nc-form-control&gt; &lt;input type=&quot;&apos;text&apos;&quot; [(modelValue)]=&quot;value&quot; /&gt; &lt;/nc-form-control&gt; &lt;/ng-container&gt; &lt;div class=&quot;nc-form-error&quot;&gt;用户名&lt;/div&gt; &lt;/nc-form-group&gt; 由于ng-container包裹内容默认是不显示的，因此需要使用ngProjectAs标记他是一个投影项目 （2）ng-content元素的访问使用ContentChild和ContentChildren能获取到投影的组件内容并操作读取其中的属性和方法 import { Component,OnInit,Input，AfterContentInit } from &apos;@angular/core&apos;; @Component({ selector: &apos;nc-form&apos;, template: ` &lt;nc-form-group&gt; &lt;nc-form-label&gt;用户名&lt;/nc-form-label&gt; &lt;nc-form-label&gt;用户名&lt;/nc-form-label&gt; &lt;ng-container ngProjectAs=&quot;nc-form-control&quot;&gt; &lt;nc-form-control&gt; &lt;input type=&quot;&apos;text&apos;&quot; [(modelValue)]=&quot;value&quot; /&gt; &lt;/nc-form-control&gt; &lt;/ng-container&gt; &lt;div class=&quot;nc-form-error&quot;&gt;用户名&lt;/div&gt; &lt;/nc-form-group&gt; ` }) export class NcFormComponent implements OnInit，AfterContentInit { @ContentChildren(NcFormLabelComponent) labels: QueryList&lt;NcFormLabelComponent&gt;; @ContentChild(NcFormControlComponent) contorl: NcFormControlComponent; constructor() {} ngOnInit() { this.groupStyle = {&apos;width&apos;: this.width}; } }","tags":[{"name":"angular","slug":"angular","permalink":"http://blueskyawen.com/tags/angular/"}]},{"title":"动态组件","date":"2018-12-14T14:11:54.000Z","path":"2018/12/14/custom-element-and-dynamic-component/","text":"在介绍正式内容之前先了解一下angular里支持的几种视图类型：模板元素和组件 模板元素，即Embedded Views，可以使用TemplateRef类型的createEmbeddedView()方法来创建，这在结构型指令中可以看到 组件，即Host View，包括应用中的所有类型的组件以及动态创建的组件 动态组件是更加自由的组件使用方式，不需要再模板中直接书写标签，只需要预留位置，然后通过脚本动态加载组件实例即可，非常适合于变化情况多的广告组件显示动态组件创建步骤： 创建待插入文档的组件元素，如果已经预留的位置的话这一步可以略过，比如：使用了ng-template预留了元素位置 使用 ComponentFactoryResolver 来为组件解析ComponentFactory， 它会为组件创建一个实例 为组件添加变更检测和事件处理 设置组件属性 添加组件到模板中，对于ng-template的情况只需要关联组件实例即可 下面是一个简单代码段 import { Component, Injector，ApplicationRef, ComponentFactoryResolver, Injectable, Injector } from &apos;@angular/core&apos;; import { PopupComponent } from &apos;./popup.component&apos;; @Component({ selector: &apos;app-root&apos;, template: ` &lt;input #input value=&quot;Message&quot;&gt; &lt;button (click)=&quot;showAsComponent(input.value)&quot;&gt;Show as component&lt;/button&gt; ` }) export class AppComponent { constructor(injector: Injector) { } showAsComponent(value : any) { //创建元素 const popup = document.createElement(&apos;popup-component&apos;); //创建组件实例 const factory = this.componentFactoryResolver.resolveComponentFactory(PopupComponent); const popupComponentRef = factory.create(this.injector, [], popup); //添加变更检测 this.applicationRef.attachView(popupComponentRef.hostView); //添加事件 popupComponentRef.instance.closed.subscribe(() =&gt; { document.body.removeChild(popup); this.applicationRef.detachView(popupComponentRef.hostView); }); //设置组件属性 popupComponentRef.instance.message = message; document.body.appendChild(popup); } } 点击这里查看动态组件的一个例子,广告的动态推送","tags":[{"name":"angular","slug":"angular","permalink":"http://blueskyawen.com/tags/angular/"}]},{"title":"ElementRef和Renderer","date":"2018-12-13T14:49:36.000Z","path":"2018/12/13/angular-elementRef-and-renderer/","text":"在自定义属性指令的时候，我们看到了ElementRef的概念，通过它可获得应用了此属性指令的Dom元素，可使用Dom元素的相关属性和方法。实际上在angular中，也可以直接使用js操作dom树来改变元素的内容和行为，但是为了能够支持跨平台，减少应用层与渲染层之间强耦合，Angular 通过抽象层封装了不同平台的差异，统一了 API 接口。定义了一系列与元素访问和操作有关的类型，比如：TemplateRef，ViewRef，及下面要说的ElementRef和Renderer，这些在一般组件库的封装经常用于改变元素的行为。 ElementRef在angular中可以使用ElementRef直接获取Dom元素并操作他们，看下源码： export class ElementRef { public nativeElement: any; constructor(nativeElement: any) { this.nativeElement = nativeElement; } } 其中的nativeElement属性就是该元素的Dom对象，可作为一般的Dom元素对象来调用方法来改变他们的呈现和行为，比如： import { Directive, ElementRef } from &apos;@angular/core&apos;; @Directive({ selector: &apos;[appHighlight]&apos; }) export class HighlightDirective { constructor(el: ElementRef) { el.nativeElement.style.backgroundColor = &apos;yellow&apos;; } } 这是修改元素背景属性的实例 除了直接使用ElementRef之外，只要能获取到ElementRef变量的地方就都可以访问操作对应的dom元素，比如：TemplateRef】 当然，这样直接使用dom的属性来设置并不好，于是angular提供Renderer类型来操作他们 RendererRenderer封装了dom元素的原始操作，减少应用层与渲染层之间强耦合关系，看看他的类型定义： export abstract class Renderer { // 创建元素 abstract createElement(parentElement: any, name: string, debugInfo?: RenderDebugInfo): any; // 创建文本元素 abstract createText(parentElement: any, value: string, debugInfo?: RenderDebugInfo): any; // 设置文本 abstract setText(renderNode: any, text: string): void; // 设置元素Property abstract setElementProperty(renderElement: any, propertyName: string, propertyValue: any): void; // 设置元素Attribute abstract setElementAttribute(renderElement: any, attributeName: string, attributeValue: string): void; // 设置元素的Class abstract setElementClass(renderElement: any, className: string, isAdd: boolean): void; } 在angular4以后，使用Renderer2 export abstract class Renderer2 { abstract createElement(name: string, namespace?: string|null): any; abstract createComment(value: string): any; abstract createText(value: string): any; abstract setAttribute(el: any, name: string, value: string, namespace?: string|null): void; abstract removeAttribute(el: any, name: string, namespace?: string|null): void; abstract addClass(el: any, name: string): void; abstract removeClass(el: any, name: string): void; abstract setStyle(el: any, style: string, value: any, flags?: RendererStyleFlags2): void; abstract removeStyle(el: any, style: string, flags?: RendererStyleFlags2): void; abstract setProperty(el: any, name: string, value: any): void; abstract setValue(node: any, value: string): void; abstract listen( target: &apos;window&apos;|&apos;document&apos;|&apos;body&apos;|any, eventName: string, callback: (event: any) =&gt; boolean | void): () =&gt; void; } 可以看到Renderer提供了大部分常用的dom操作方法，下面改造上面指令的实现 import { Directive, ElementRef，Renderer2 } from &apos;@angular/core&apos;; @Directive({ selector: &apos;[appHighlight]&apos; }) export class HighlightDirective { constructor(el: ElementRef，renderer: Renderer2) { this.renderer.setStyle(this.el.nativeElement, &apos;backgroundColor&apos;, &apos;yellow&apos;); } }","tags":[{"name":"angular","slug":"angular","permalink":"http://blueskyawen.com/tags/angular/"}]},{"title":"templateRef和viewContainerRef","date":"2018-12-12T12:55:59.000Z","path":"2018/12/12/angular-templateRef-and-viewContainerRef/","text":"在结构型指令中我们看到她们都是template标签来实现，也看到了TemplateRef和ViewContainerRef两个概念template标签是html的新标签，在文档中直接直接使用是不显示的，最后会是一段注释，比如： &lt;template&gt; &lt;span&gt;I am span in template&lt;/span&gt; &lt;/template&gt; 只有通过js手动处理才会有内容显示，而angular的结构指令的实现正式基于这种原理 TemplateRef用于表示内嵌的 template 模板元素，通过 TemplateRef 实例，我们可以方便创建内嵌视图(Embedded Views)，且可以轻松地访问到通过 ElementRef 封装后的 nativeElement。需要注意的是组件视图中的 TemplateRef_ // @angular/core/src/linker/template_ref.d.ts export declare class TemplateRef_&lt;C&gt; extends TemplateRef&lt;C&gt; { private _parentView; private _nodeIndex; private _nativeElement; constructor(_parentView: AppView&lt;any&gt;, _nodeIndex: number, _nativeElement: any); createEmbeddedView(context: C): EmbeddedViewRef&lt;C&gt;; elementRef: ElementRef; } TemplateRef // @angular/core/src/linker/template_ref.d.ts // 用于表示内嵌的template模板，能够用于创建内嵌视图(Embedded Views) export declare abstract class TemplateRef&lt;C&gt; { elementRef: ElementRef; abstract createEmbeddedView(context: C): EmbeddedViewRef&lt;C&gt;; } 通过源码可以看到createEmbeddedView方法来给创建内嵌视图，即embedview，它的返回值就是一个embedview对象，这才是在template元素需要显示的内容但是这只是创建了实例，没有插入到视图中依然没有效果，于是便有了下面这个概念 ViewContainerRef用于表示一个视图容器，可添加一个或多个视图。通过 ViewContainerRef 实例，我们可以基于 TemplateRef 实例创建内嵌视图，并能指定内嵌视图的插入位置，也可以方便对视图容器中已有的视图进行管理。简而言之，ViewContainerRef 的主要作用是创建和管理内嵌视图或组件视图。简单点讲，ViewContainerRef就是创建内嵌视图实例，并指定将内嵌视图插入到哪个位置或者销毁它，于是便有了内容的动态呈现和消失，ViewContainerRef创建实例内部调用的就是TemplateRef的方法，看下源码： export declare class ViewContainerRef_ implements ViewContainerRef { ... length: number; // 返回视图容器中已存在的视图个数 element: ElementRef; injector: Injector; parentInjector: Injector; // 基于TemplateRef创建内嵌视图，并自动添加到视图容器中，可通过index设置 // 视图添加的位置 createEmbeddedView&lt;C&gt;(templateRef: TemplateRef&lt;C&gt;, context?: C, index?: number): EmbeddedViewRef&lt;C&gt;; // 基 ComponentFactory创建组件视图 createComponent&lt;C&gt;(componentFactory: ComponentFactory&lt;C&gt;, index?: number, injector?: Injector, projectableNodes?: any[][]): ComponentRef&lt;C&gt;; insert(viewRef: ViewRef, index?: number): ViewRef; move(viewRef: ViewRef, currentIndex: number): ViewRef; indexOf(viewRef: ViewRef): number; remove(index?: number): void; detach(index?: number): ViewRef; clear(): void; } 最后总结一下： embedview,内嵌视图 TemplateRef，内嵌视图创建模板，存有指令宿主元素模板 viewContainer,视图容器,view列表 viewcontainerRef,描绘视图容器，用于管理container,可同时创建内嵌view和组件视图，类里有不同的方法来创建，还有一个container的锚点，用于指定容器，可当做列表的头地址，新创建的view一个个作为兄弟成员存放，方便管理；类中injector存有TemplateRef 几个概念的大概关系如下： 参考文献：angular修仙","tags":[{"name":"angular","slug":"angular","permalink":"http://blueskyawen.com/tags/angular/"}]},{"title":"Ng-Shadow-Cat","date":"2018-11-10T15:04:55.000Z","path":"2018/11/10/ng-shadow-cat-readme/","text":"Ng-Shadow-Cat是一套前端组件库的Angular实现，封装了常用的一些UI组件,珊格系统和模式,中文名叫“幻影猫”，取名源于超级英雄电影«X战警»中的幻影猫，寓意是变幻莫测组件库安装方便，使用简单，只要了解一点html,css和jquery的知识即可使用 特性 开箱即用的Angular组件 适配移动端，不同尺寸屏幕均额适用的组件。 使用 TypeScript 构建，提供完整的类型定义文件。 支持环境现代浏览器和 IE11 及以上（需要 polyfills）。 支持 Angular 版本目前支持 Angular ^6.0.0 版本。 项目github地址ng-shadow-cat 库文档和示例ng-shadow-cat文档-示例 下载方式npm install ng-shadow-cat-d --save-dev 使用方式1. 安装Clinpm install -g @angular/cli 请务必确认Node.js的版本是v8.10或以上，建议升级至最新版本的@angular/cli 查看cli脚手架版本，有版本信息呈现则安装成功 ng -v 2. 新建angular项目ng new my-app 3. 下载Ng-Shadow-Cat库npm install ng-shadow-cat-d --save-dev 4. 配置模块在app.module.ts配置ng-shadow-cat-d import { BrowserModule } from &apos;@angular/platform-browser&apos;; import { NgModule } from &apos;@angular/core&apos;; import { AppRoutingModule } from &apos;./app-routing.module&apos;; import { LibModule } from &apos;ng-shadow-cat-d&apos;; import { AppComponent } from &apos;./app.component&apos;; @NgModule({ imports: [ BrowserModule,AppRoutingModule,LibModule ], declarations: [ AppComponent ], providers: [], bootstrap: [AppComponent] }) export class AppModule {} 5. 配置样式更新.angular-cli.json配置 &quot;styles&quot;: [ &quot;./node_modules/ng-shadow-cat-d/ng-shadow-cat-d.css&quot; ], &quot;scripts&quot;: [ ],","tags":[{"name":"angular，plugin","slug":"angular，plugin","permalink":"http://blueskyawen.com/tags/angular，plugin/"}]},{"title":"前端插件包-BootShadow","date":"2018-09-26T15:04:55.000Z","path":"2018/09/26/jq-plugin-dev2/","text":"Boot-Shadow是一款自己编写的开源前端插件包，包含了在前端开发中常用的一些组件，可方便应用与项目开发当中插件包安装方便，使用简单，只要了解一点html,css和jquery的知识即可使用 特性 使用webpack/npm打包发布，下载方便 引用脚本后直接使用 常用插件，使用方式多样 文档-Demohttp://blueskyawen.com/boot-shadow/ 项目仓库github地址 支持环境现代浏览器和 IE9 及以上（需要 polyfills） 下载方式npm install boot-shadow --save-dev 使用方式直接引用脚本和CSS样式文件&lt;script src=&quot;https://cdn.bootcss.com/jquery/2.1.1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;node_modules/boot-shadow/dist/bootshadow.min.css&quot;&gt; &lt;script src=&quot;node_modules/boot-shadow/dist/bootshadow.min.js&quot;&gt;&lt;/script&gt; 在Angular-cli中使用npm install jquery --save npm install @types/jquery --save npm install boot-shadow --save-dev 更新.angular-cli.json配置 &quot;styles&quot;: [ &quot;../node_modules/boot-shadow/dist/bootshadow.min.css&quot; ], &quot;scripts&quot;: [ &quot;../node_modules/jquery/dist/jquery.js&quot;, &quot;../node_modules/boot-shadow/dist/bootshadow.min.js&quot; ], 在对应component中的ngOnInit()使用 declare var $: any; ngOnInit() { $(&quot;#switch2&quot;).bootSwitch(); }","tags":[{"name":"Jquery，plugin","slug":"Jquery，plugin","permalink":"http://blueskyawen.com/tags/Jquery，plugin/"}]},{"title":"JQuery-自写插件集","date":"2018-09-12T15:04:55.000Z","path":"2018/09/12/jq-plugins-dev/","text":"在熟悉了jquery和插件写法之后，作者将之前使用原生js和jquery写的一些组件，封装成插件 switch开关插件代码 使用方式： &lt;div id=&quot;switch1&quot;&gt;&lt;/div&gt; &lt;div id=&quot;switch2&quot;&gt;&lt;/div&gt; $(function() { $(&quot;#switch1&quot;).bootSwitch({titles: [], defalutCheck: true}); $(&quot;#switch2&quot;).bootSwitch({titles:[&apos;开&apos;,&apos;关&apos;], defalutCheck: true}); $(&quot;.tips button&quot;).click(function() { $(&quot;.tips span&quot;).text($(&quot;#switch1&quot;).bootSwitch(&apos;getChecked&apos;)); }); //获取开关状态 $(&quot;#switch1&quot;).bootSwitch(&apos;getChecked&apos;); //添加自定义事件 $(&quot;#switch1&quot;).on(&quot;change.bc.switch&quot;,function() { console.log(&apos;switch1 change&apos;); }); }); 效果：switch开关 select下拉选择插件代码 使用方式： &lt;div id=&quot;select-normal&quot;&gt;&lt;/div&gt; //正常下拉选择 &lt;div id=&quot;select-small&quot;&gt;&lt;/div&gt; //正常下拉选择--小尺寸 &lt;div id=&quot;select-disable&quot;&gt;&lt;/div&gt; //禁止下拉选择 $(function() { var options1 = [ {value: &apos;paletxUI&apos;,name: &apos;paletxUI&apos;}, {value: &apos;Iaas&apos;,name: &apos;Iaas&apos;}, {value: &apos;Paas&apos;,name: &apos;Paas&apos;}, {value: &apos;Saas&apos;,name: &apos;Saas&apos;}, {value: &apos;CMS&apos;,name: &apos;CMS&apos;} ]; $(&quot;#select-normal&quot;).bootSelect({id: &apos;select-normal&apos;, options: options1, defalutChecked: &apos;&apos;, placeholder: &apos;请选择&apos;}); $(&quot;#select-small&quot;).bootSelect({id: &apos;select-normal&apos;, options: options1, defalutChecked: &apos;&apos;, placeholder: &apos;请选择&apos;, width: 220}); $(&quot;#select-disable&quot;).bootSelect({id: &apos;select-disable&apos;, options: options1, defalutChecked: &apos;&apos;, placeholder: &apos;请选择&apos;, disable: true}); }); 效果：下拉选择 multilSelect多选下拉选择插件代码 使用方式： &lt;div id=&quot;mutil-select01&quot;&gt;&lt;/div&gt; //多选下拉选择框 &lt;div id=&quot;mutil-select02&quot;&gt;&lt;/div&gt; //禁止多选下拉选择 &lt;div id=&quot;mutil-select03&quot;&gt;&lt;/div&gt; //带复选框的下拉选择 &lt;div id=&quot;mutil-select04&quot;&gt;&lt;/div&gt; //带全选的下拉选择 &lt;div id=&quot;mutil-select05&quot;&gt;&lt;/div&gt; //显示选择个数的-带复选框 &lt;div id=&quot;mutil-select06&quot;&gt;&lt;/div&gt; //显示选择个数的-普通 &lt;div id=&quot;mutil-small&quot;&gt;&lt;/div&gt; //多选下拉选择框-小尺寸 &lt;div id=&quot;mutil-big&quot;&gt;&lt;/div&gt; //多选下拉选择框-大尺寸 $(function() { var optionsss = [ {value: &apos;paletxUI-paletxUI-paletxUI-paletxUI-paletxUI-paletxUI-paletxUI-paletxUI&apos;, name: &apos;paletxUI-paletxUI-paletxUI-paletxUI-paletxUI-paletxUI-paletxUI-paletxUI&apos;}, {value: &apos;Paas-Paas&apos;,name: &apos;Paas-Paas&apos;}, {value: &apos;Iaas-Iaas&apos;,name: &apos;Iaas-Iaas&apos;}, {value: &apos;Saas-Saas&apos;,name: &apos;Saas-Saas&apos;}, {value: &apos;CMS-CMS&apos;,name: &apos;CMS-CMS&apos;} ]; var defaultSelects = [ {value: &apos;Iaas-Iaas&apos;,name: &apos;Iaas-Iaas&apos;}, {value: &apos;CMS-CMS&apos;,name: &apos;CMS-CMS&apos;} ]; var disableOptions = [ {value: &apos;CMS-CMS&apos;,name: &apos;CMS-CMS&apos;} ]; $(&quot;#mutil-select01&quot;).bootMultilSelect({options: optionsss, defalutSelected: defaultSelects, disable: disableOptions}); $(&quot;#mutil-select02&quot;).bootMultilSelect({options: optionsss, defalutSelected: defaultSelects, disable: disableOptions, disabled:true}); $(&quot;#mutil-select03&quot;).bootMultilSelect({options: optionsss, defalutSelected: defaultSelects, disable: disableOptions, checkbox:true}); $(&quot;#mutil-select04&quot;).bootMultilSelect({options: optionsss, defalutSelected: defaultSelects, disable: disableOptions, checkbox:true, allcheck:true}); $(&quot;#mutil-select05&quot;).bootMultilSelect({options: optionsss, defalutSelected: defaultSelects, disable: [], checkbox:true, allcheck:true, showNum:true}); $(&quot;#mutil-select06&quot;).bootMultilSelect({options: optionsss, defalutSelected: defaultSelects, disable: [], showNum:true}); $(&quot;#mutil-small&quot;).bootMultilSelect({options: optionsss, defalutSelected: defaultSelects, disable: [], width: 220}); $(&quot;#mutil-big&quot;).bootMultilSelect({options: optionsss, defalutSelected: defaultSelects, disable: [], checkbox:true, width: 620}); //添加选择变更事件 $(&quot;#mutil-select01&quot;).on(&quot;change.bc.multilselect&quot;,function() { console.log(&apos;multilselect change&apos;); }); //获取已选记录 var selection = $(&quot;#mutil-select01&quot;).bootMultilSelect(&apos;getSelection&apos;); }); 效果：multil多选下拉框 transfer穿梭框插件代码 使用方式： &lt;div id=&quot;myTranfer&quot;&gt;&lt;/div&gt; $(function() { var sourceItems = [{value:&apos;content01&apos;,name:&apos;content01&apos;}, {value:&apos;content02&apos;,name:&apos;content02&apos;}, {value:&apos;content03&apos;,name:&apos;content03&apos;}, {value:&apos;content04&apos;,name:&apos;content04&apos;}, {value:&apos;content05&apos;,name:&apos;content05&apos;}, {value:&apos;content06&apos;,name:&apos;content06&apos;}, {value:&apos;content07&apos;,name:&apos;content07&apos;}, {value:&apos;content08&apos;,name:&apos;content08&apos;}]; var targetItems = [{value:&apos;content09&apos;,name:&apos;content09&apos;}, {value:&apos;content10&apos;,name:&apos;content10&apos;}]; $(&quot;#myTranfer&quot;).bootTransfer({sourOptions: sourceItems, targOptions: targetItems, disableItems: [], itemText:&apos;项目&apos;, sourceText:&apos;源&apos;, targetText:&apos;目标&apos;}); //获取源记录 $(&quot;#myTranfer&quot;).bootTransfer(&apos;getSource&apos;); //获取目标记录 $(&quot;#myTranfer&quot;).bootTransfer(&apos;getTarget&apos;); }); 效果：transfer穿梭框 Info通知插件代码 使用方式： &lt;div id=&quot;success&quot;&gt;&lt;/div&gt; &lt;div id=&quot;error&quot;&gt;&lt;/div&gt; &lt;div id=&quot;warn&quot;&gt;&lt;/div&gt; $(function() { var $successInfo = $(&quot;#success&quot;).bootInfo({type: &apos;success&apos;, title: &apos;操作成功,2s后自动消失&apos;, timelen: 2000}); var $warnInfo = $(&quot;#warn&quot;).bootInfo({type: &apos;warn&apos;, title: &apos;我是警告消息!&apos;}); var $errorInfo = $(&quot;#error&quot;).bootInfo({type: &apos;error&apos;, title: &apos;我是错误消息!&apos;}); //展现通知 $successInfo.bootInfo(&apos;show&apos;); $warnInfo.bootInfo(&apos;show&apos;); $errorInfo.bootInfo(&apos;show&apos;); //隐藏通知 $warnInfo.bootInfo(&apos;hide&apos;); $errorInfo.bootInfo(&apos;hide&apos;); }); 效果：Info通知 Collapse折叠面板插件代码 使用方式： &lt;div class=&quot;collapseset&quot; id=&quot;collapset1&quot;&gt; &lt;div class=&quot;collapse&quot;&gt; &lt;header&gt;&lt;span&gt;&lt;/span&gt; 杨过&lt;/header&gt; &lt;article&gt;杨过，名过，字改之，是金庸武侠小说《神雕侠侣》[1] 中的主人公，前作《射雕英雄传》中杨康与穆念慈之子，西毒欧阳锋的义子。名字为郭靖、黄蓉所取，取“有过则改之”之意。&lt;/article&gt; &lt;/div&gt; &lt;div class=&quot;collapse&quot;&gt; &lt;header&gt;&lt;span&gt;&lt;/span&gt; 小龙女&lt;/header&gt; &lt;article&gt;小龙女，是金庸小说《神雕侠侣》的女主角，金庸笔下广受读者喜爱的女角之一。容貌秀美若仙、清丽绝俗。性格宽容恬淡、天真可爱。武功轻灵飘逸，于婀娜妩媚中击敌制胜。&lt;/article&gt; &lt;/div&gt; &lt;div class=&quot;collapse&quot;&gt; &lt;header&gt;&lt;span&gt;&lt;/span&gt; 黄药师&lt;/header&gt; &lt;article&gt;黄药师，外号“东邪”，天下“五绝”之一，是金庸武侠小说《射雕英雄传》和《神雕侠侣》中的角色。是黄蓉之父，对其妻冯氏（小字阿衡）一往情深。。 &lt;/article&gt; &lt;/div&gt; &lt;/div&gt; $(function() { $(&quot;#collapset1&quot;).bootCollapse({type: &apos;normal&apos;}); $(&quot;#collapset2&quot;).bootCollapse({type: &apos;eachOne&apos;}); }); 效果：折叠面板 轮播图插件代码 使用方式： &lt;div id=&quot;carousel-fade&quot;&gt;&lt;/div&gt; //渐变 &lt;div id=&quot;carousel-slide&quot;&gt;&lt;/div&gt; //滑动 &lt;div id=&quot;carousel-slide-data-api&quot;&gt;&lt;/div&gt; //使用data-api $(function() { var optionss = [ {name: &apos;fuzhi&apos;, url: &apos;http://dimg04.c-ctrip.com/images/t1/vacations/203000/202469/ef1ae815bbef4a0698d4fa2ac15614e0.jpg&apos;}, {name: &apos;qingshuisi&apos;, url: &apos;http://upload.shunwang.com/2014/0625/1403670070972.JPG&apos;}, {name: &apos;xiaodao&apos;, url: &apos;http://digitalphoto.cocolog-nifty.com/photos/uncategorized/2008/08/02/dsc_d300_0006950_2.jpg&apos;}, {name: &apos;xiaodao2&apos;, url: &apos;http://f4.topitme.com/4/b3/e5/1118294546054e5b34o.jpg&apos;}, {name: &apos;xiaodao3&apos;, url: &apos;http://img17.3lian.com/d/file/201701/19/fd92ea2409b6b157c247b78ce4eda95a.jpg&apos;} ]; $(&quot;#carousel-fade&quot;).bootCarousel({options: optionss,type: &apos;fade&apos;}); $(&quot;#carousel-slide&quot;).bootCarousel({options: optionss,type: &apos;slide&apos;， interval:5000,pause:true}); $(&quot;#carousel-slide-data-api&quot;).bootCarousel({options: optionss, type: &apos;fade&apos;, dataApi:true}); //手动切换项目 $(&quot;#carousel-fade&quot;).bootCarousel(&apos;prev&apos;); $(&quot;#carousel-fade&quot;).bootCarousel(&apos;next&apos;); $(&quot;#carousel-fade&quot;).bootCarousel(Num); //手动启停自动循环播放 $(&quot;#carousel-slide&quot;).bootCarousel(&apos;cycle&apos;); //启动 $(&quot;#carousel-slide&quot;).bootCarousel(&apos;pause&apos;); //停止 //自定义事件 $(&quot;#carousel-slide&quot;).on(&quot;change.bc.carousel&quot;,function() { count++; }); $(&quot;#carousel-slide&quot;).on(&quot;changed.bc.carousel&quot;,function() { count++; }); 效果：轮播图 dropdown下拉菜单插件代码 使用方式： &lt;div class=&quot;dropdown&quot; id=&quot;dropdown1&quot;&gt; &lt;button class=&quot;dropbtn dropdown-toggle&quot;&gt;下拉菜单 &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt; &lt;/button&gt; &lt;ul class=&quot;dropdown-content menu-width&quot;&gt; &lt;li class=&quot;dropdown-item&quot;&gt; &lt;a tabindex=&quot;-1&quot; href=&quot;javascript:void(0);&quot;&gt;新浪&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;dropdown-item&quot;&gt; &lt;a tabindex=&quot;-1&quot; href=&quot;javascript:void(0);&quot;&gt;搜狐&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;divider&quot;&gt;&lt;/li&gt; &lt;li class=&quot;dropdown-item&quot;&gt; &lt;a tabindex=&quot;-1&quot; href=&quot;javascript:void(0);&quot;&gt;小米&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; $(function() { $(&quot;#dropdown1&quot;).bootDropdown(); $(&quot;#dropdown2&quot;).bootDropdown({place:&apos;right&apos;}); $(&quot;#dropdown3&quot;).bootDropdown({place:&apos;up&apos;}); $(&quot;#dropdown4&quot;).bootDropdown({type: &apos;click&apos;,place:&apos;left&apos;}); $(&quot;#dropdown5&quot;).bootDropdown({type: &apos;hover&apos;,place:&apos;down&apos;}); $(&quot;#dropdown6&quot;).bootDropdown({type: &apos;hover&apos;,place:&apos;right&apos;}); $(&quot;#dropdown7&quot;).bootDropdown({type: &apos;hover&apos;,place:&apos;up&apos;}); $(&quot;#dropdown8&quot;).bootDropdown({type: &apos;hover&apos;,place:&apos;left&apos;}); //手动切换菜单 $(&quot;#dropdown1&quot;).bootDropdown(&apos;toggle&apos;); }); 效果：dropdown下拉菜单 TAB选项卡插件代码 使用方式： &lt;div class=&quot;nav-tabs&quot; id=&quot;tab1&quot;&gt; &lt;ul class=&quot;tab-bars&quot;&gt; &lt;li class=&quot;disabled&quot; name=&quot;html&quot;&gt;html&lt;/li&gt; &lt;li name=&quot;css&quot;&gt;css&lt;/li&gt; &lt;li name=&quot;dom&quot;&gt;dom&lt;/li&gt; &lt;li name=&quot;javascript&quot;&gt;javascript&lt;/li&gt; &lt;/ul&gt; &lt;div class=&quot;tab-content&quot; &gt; &lt;div name=&quot;html&quot;&gt;Html&lt;/div&gt; &lt;div name=&quot;css&quot;&gt;Css&lt;/div&gt; &lt;div name=&quot;dom&quot;&gt;Dom&lt;/div&gt; &lt;div name=&quot;javascript&quot;&gt;Javascript&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; $(function() { $(&quot;#tab1&quot;).bootTab(); $(&quot;#tab2&quot;).bootTab({defaultActive: 0}); $(&quot;#tab3&quot;).bootTab({defaultActive: ‘css’}); //手动激活选项卡 $(&quot;#tab3&quot;).bootTab(0); $(&quot;#tab3&quot;).bootTab(&apos;javascript&apos;); }); 效果：TAB选项卡","tags":[{"name":"Jquery","slug":"Jquery","permalink":"http://blueskyawen.com/tags/Jquery/"}]},{"title":"less深入指南三-@import导入（译）","date":"2018-08-22T16:00:30.000Z","path":"2018/08/23/less-import/","text":"@import导入在标准CSS中，@import语句必须在所有其他类型的规则之前声明，但Less并不关心你放置@import语句的位置 .foo { background: #900; } @import &quot;this-is-valid.less&quot;; 识别文件扩展名根据文件扩展名的不同，Less在处理@import导入的时候的方式也有所不同 如果文件具有.css扩展名，则将其视为CSS文件，并将@import语句保留为原样（请参阅下面的内联选项）。 如果它有任何其他扩展名，它将被视为less文件并导入。 如果它没有扩展名，则会附加.less，它将作为导入的Less文件包含在内。例子： @import “foo”; // foo.less is imported @import “foo.less”; // foo.less is imported @import “foo.php”; // foo.php imported as a Less file @import “foo.css”; // statement left in place, as-is 下面要讲到的选项可以覆盖此行为。 导入选项Less为CSS的@import提供了几个扩展，比使用外部文件具有更多的灵活性。语法： @import（keyword）“filename”; 以下是支持的导入选项： reference: 使用Less文件但不输出 inline: 在输出中包含源文件但不处理它 less: 无论文件扩展名是什么，都将文件视为Less文件 css: 无论文件扩展名是什么，都将文件视为CSS文件 once: 只包含文件一次（默认行为） multiple: 多次包含该文件 optional: 在找不到文件时继续编译 每个@import允许使用多个关键字，关键字之间使用逗号分隔，比如： @import (optional, reference) &quot;foo.less&quot;; reference Released v1.5.0 @import（reference）“foo.less”; 导入外部文件，但不将引入的样式添加到已编译的输出，只是引用它们。 想象一下，在导入的文件中，reference使用一个引用来标记每一个at-rule和selector，就像正常导入一样。但是当生成CSS时，却不输出“reference”选择器，甚至是任何仅仅包含引用选择器的媒体查询。除非参考样式被用作mixins或extend，否则引用样式不会显示在生成的CSS中。根据使用的方法（mixin或extend）不同，会产生不同的结果。 extend：当使用扩展选择器时，只有新选择器被标记为未引用，并且它将被引入到@import引用语句的位置。 mixins：当参考样式被用作隐式mixin时，其规则是混合的，标记为“非引用”，并且正常显示在引用的位置。 例子：允许您通过执行以下操作从Bootstrap等库中仅提取特定的，有针对性的样式： .navbar：extend（.navbar all）{} 并且您将仅从Bootstrap中提取.navbar相关样式。 inline Released v1.5.0 @import (inline) &quot;not-less-compatible.css&quot;; 在输出中包含源文件但不处理它当CSS文件可能不兼容时，您将使用此选项; 这是因为虽然Less支持大多数已知标准CSS，但它不支持某些注释，并且不支持所有已知的CSS补丁，它是不修改CSS的。 您可以使用它将文件包含在输出中，以便所有CSS都在一个文件中。 less Released v1.4.0 @import (less) &quot;foo.css&quot;; 将导入的文件视为Less，无论文件扩展名如何。 css Released v1.4.0 @import (css) &quot;foo.less&quot;; //outputs @import &quot;foo.less&quot;; 将导入的文件视为常规CSS，无论文件扩展名如何。 这意味着import语句将保持原样。 once Released v1.4.0 @import语句的默认行为。 这意味着文件仅导入一次，并且将忽略该文件的后续导入语句。 @import (once) &quot;foo.less&quot;; @import (once) &quot;foo.less&quot;; // this statement will be ignored multiple Released v1.4.0 使用@import（multiple）可以导入多个相同名称的文件，这是和once相反的行为。 // file: foo.less .a { color: green; } // file: main.less @import (multiple) &quot;foo.less&quot;; @import (multiple) &quot;foo.less&quot;; 输出 .a { color: green; } .a { color: green; } optional Released v2.3.0 @import (optional) &quot;foo.less&quot;; 使用@import（optional）仅允许在文件存在时导入文件，在没有optional关键字时，Less会抛出FileError并在导入无法找到的文件时停止编译。 @plugin插件 Released v2.5.0 可以通过导入JavaScript插件以添加Less.js函数和功能 编写你的第一个插件使用@plugin的方式类似于使用@import导入.less文件。 @plugin &quot;my-plugin&quot;; // 字段添加.js后缀，如果不带扩展名 由于Less插件是在Less作用域范围内评估的，因此插件定义可以非常简单，比如： registerPlugin({ install: function(less, pluginManager, functions) { functions.add(&apos;pi&apos;, function() { return Math.PI; }); } }) 或者你可以使用module.exports（在浏览器和Node.js中工作）。 module.exports = { install: function(less, pluginManager, functions) { functions.add(&apos;pi&apos;, function() { return Math.PI; }); } }; 请注意，浏览器中不支持其他Node.js库比如CommonJS的使用方式，例如require（）。 编写跨平台插件时请记住这一点。 你能用插件做什么？ 很多，但让我们从基础开始。我们将首先关注您可能放在插件中放置的内容： // my-plugin.js install: function(less, pluginManager, functions) { functions.add(&apos;pi&apos;, function() { return Math.PI; }); } 恭喜！ 你写了一个Less插件！您可以在样式表中这样使用它： @plugin &quot;my-plugin&quot;; .show-me-pi { value: pi(); } 输出： .show-me-pi { value: 3.141592653589793; } 但是，如果您希望将其与其他值相乘或执行其他Less操作，则需要返回正确的Less节点。 否则，在样式表中的输出是纯文本。 functions.add(&apos;pi&apos;, function() { return less.dimension(Math.PI); }); 注意：dimension的参数可以带单位，也可以不带单位，比如：dimension(10) 或 dimension(10,”px”)。 现在您可以在运算操作中使用您的插件： @plugin &quot;my-plugin&quot;; .show-me-pi { value: pi() * 2; } 您可能已经注意到插件文件有可用的全局变量，即函数注册表（函数对象）和较少的对象。 这些都是为了方便起见。 插件作用域范围在使用@plugin添加函数的时候，是遵循Less作用域规则的。 这对于想要在不引入命名冲突的情况下添加函数的Less库作者来说非常有用。例如，假设您有两个来自两个第三方库的插件，这两个插件都有一个名为“foo”的函数。 // lib1.js // ... functions.add(&apos;foo&apos;, function() { return &quot;foo&quot;; }); // ... // lib2.js // ... functions.add(&apos;foo&apos;, function() { return &quot;bar&quot;; }); // ... 没关系！ 您可以选择哪个库的功能创建哪个输出。 .el-1 { @plugin &quot;lib1&quot;; value: foo(); } .el-2 { @plugin &quot;lib2&quot;; value: foo(); } 输出： .el-1 { value: foo; } .el-2 { value: bar; } 对于共享插件的插件作者，这意味着您还可以通过将私有函数放在特定范围内来有效地创建私有函数。 所以，如下的使用方式是错误的： .el { @plugin &quot;lib1&quot;; } @value: foo(); 从Less 3.0开始，函数可以返回任何类型的Node类型，并且可以在任何级别调用。但是，这会在2.x中引发错误，因为在2.x中函数必须是属性或变量赋值的一部分： .block { color: blue; my-function-rules(); } 在3.x中，不再是这种情况，函数可以返回At-Rules，Rulesets，任何其他Less节点，字符串和数字（后两个转换为匿名节点）。 空函数有时您可能想要调用一个函数，但是您不需要任何输出（例如存储值以供以后使用）。 在这种情况下，您只需要从函数返回false。 var collection = []; functions.add(&apos;store&apos;, function(val) { collection.push(val); // imma store this for later return false; }); //输出 @plugin &quot;collections&quot;; @var: 32; store(@var); 或者可以这么写 functions.add(&apos;retrieve&apos;, function(val) { return less.value(collection); }); //输出 .get-my-values { @plugin &quot;collections&quot;; values: retrieve(); } Less.js插件对象Less.js插件应该导出具有一个或多个属性的对象。 { /* Called immediately after the plugin is * first imported, only once. */ install: function(less, pluginManager, functions) { }, /* Called for each instance of your @plugin. */ use: function(context) { }, /* Called for each instance of your @plugin, * when rules are being evaluated. * It&apos;s just later in the evaluation lifecycle */ eval: function(context) { }, /* Passes an arbitrary string to your plugin * e.g. @plugin (args) &quot;file&quot;; * This string is not parsed for you, * so it can contain (almost) anything */ setOptions: function(argumentString) { }, /* Set a minimum Less compatibility string * You can also use an array, as in [3, 0] */ minVersion: [&apos;3.0&apos;], /* Used for lessc only, to explain * options in a Terminal */ printUsage: function() { }, } PluginManager为 install() function作实例化，并且提供了添加访问者，文件管理器和后处理器的方法。以下是一些显示不同插件类型的示例，可分别链接查看。 后处理器 访问者 文件管理器 预加载插件虽然@plugin调用适用于大多数情况，但有时您可能希望在解析开始之前加载插件。请参阅：“使用Less.js”部分中的预加载插件，了解如何执行此操作。 Maps(新) Released v3.5.0-beta.4 使用规则集和mixins作为值的映射通过将命名空间与[]语法相结合，您可以将规则集/ mixin转换为映射，比如： @sizes: { mobile: 320px; tablet: 768px; desktop: 1024px; } .navbar { display: block; @media (min-width: @sizes[tablet]) { display: inline-block; } } 输出： .navbar { display: block; } @media (min-width: 768px) { .navbar { display: inline-block; } } 由于命名空间和重载混合的能力，Mixins比Map更具通用性。 #library() { .colors() { primary: green; secondary: blue; } } #library() { .colors() { primary: grey; } } .button { color: #library.colors[primary]; border-color: #library.colors[secondary]; } 输出： .button { color: grey; border-color: blue; } 此外，你还可以通过别名访问mixins，那是个更容易的方式。 .button { @colors: #library.colors(); color: @colors[primary]; border-color: @colors[secondary]; } 请注意，当存在多个嵌套的规则集的时候，可以使用多个[]来进行查找访问，如下所示： @config: { @options: { library-on: true } } &amp; when (@config[@options][library-on] = true) { .produce-ruleset { prop: val; } } 通过这种方式，规则集和变量调用可以模拟一种类型的“命名空间”，类似于mixins 至于是否将分配给变量的mixins或规则集用作映射，这取决于您。 您可能希望通过重新声明分配给rulset的变量来替换整个Map来使用； 或者您可能想要“合并”单个键/值对，在这种情况下，把mixins作为Map可能更合适。 在[]中使用变量的变量有一件重要的事情需要注意，查找表达式[@lookup]中的@lookup是查找的主键，一般只接受常量，不能使用变量来访问，但是可以使用变量的变量来作为索引键值例子： .foods() { @dessert: ice cream; } @key-to-lookup: dessert; .lunch { treat: .foods[@@key-to-lookup]; } 编译输出: .lunch { treat: ice cream; }","tags":[{"name":"Less","slug":"Less","permalink":"http://blueskyawen.com/tags/Less/"}]},{"title":"详解javascript和jquery里的各种尺寸和偏移","date":"2018-08-21T16:00:40.000Z","path":"2018/08/22/the-offset-of-javascript-and-jquery/","text":"最近在写jquery的滚动监听和附加导航的插件的时候，把元素的尺寸，定位和偏移等各种参数和计算捋了一遍，包括js原生的和jquery的计算方法，以及之间的区别，想总结下来，怕忘记，方便以后翻阅 Dom元素的位置呈现一个Dom元素在页面的位置涉及到多个参数：视口，父包含容器以及元素本身，一般的呈现形式是下面这样的： 可以看到，Dom元素的呈现分为好几个部分，文档的尺寸是任意的，在视口或父包含容器尺寸一定的时候也能正常显示当容器缺失的时候，整个视口就元素的容器，是一般位置的特殊形式 Dom元素的尺寸和偏移从上一节的元素位置图可以看到，要描述一个元素以及其位置需要许多的参数：height,width,offsetTop,offsetLeft…等，以及包含它的每一层级的容器元素，而每一层元素都拥有自己的属性和特性 jquery表示尺寸$(‘targetSelector’).height()/width()元素内容区的宽和高，不包括padding $(‘targetSelector’).innnerHeight()/innnerWidth()元素内边距区的宽和高，包括padding,但不包括border $(‘targetSelector’).outerHeight(false)/outerWidth(false)元素边界区的宽和高，包括padding/border,但不包括margin $(‘targetSelector’).outerHeight(true)/outerWidth(true)元素外边距区的宽和高，包括padding/border/margin 滚动位置$(‘targetSelector’).scrollTop()/scrollLeft()元素相对于视口或者父容器的滚动条的位置的滚动距离，也是父容器的滚动条的位置，即隐藏在视口之外的部分 偏移$(‘targetSelector’).offset()元素相对于视口的偏移，从视口的边界到元素border的偏移距离,距离包含了原书的margin offset().top offset().left $(‘targetSelector’).position()元素相对于上一级position:relative的父元素的偏移，从视口的边界到元素margin的偏移距离,距离不包含了原书的margin当父元素是视口的时候，其数值和offset()相同 position().top position().left 注意，这两个偏移计算值是随着文档的滚动而变化;当文档向上滚动是，偏移的距离是需要减去滚动距离的 比如，在初始没有滚动的时候，offset偏移为： var offset.maxTop = $(&apos;targetSelector&apos;).offset().top; var offset.maxLeft = $(&apos;targetSelector&apos;).offset().left; 当文档进行滚动的时候 $(&apos;targetSelector&apos;).offset().top = offset.maxTop - $(&apos;targetSelector&apos;).scrollTop(); $(&apos;targetSelector&apos;).offset().left = offset.maxLeft - $(&apos;targetSelector&apos;).scrollLeft(); position()和offset()类似 js-dom元素表示var element = $(&apos;targetSelector&apos;).get(0); 尺寸element.offsetHeight/offsetwidth元素边界区的宽和高，包括padding/border和滚动条,但不包括margin element.clientHeight/clientwidth元素内边距区的宽和高，包括padding,但不包括border/margin和滚动条 滚动位置element.scrollTop/scrollLeft元素相对于视口或者父容器的滚动条的位置的滚动距离，也是父容器的滚动条的位置,即隐藏在视口之外的部分 element.scrollHeight/scrollWidth文档元素的滚动尺寸，实际大小，而不论视口有多大，多的部分滚动隐藏在视口之外 偏移element.offsetTop/offsetLeft元素相对于上一级position:relative的父元素的偏移，偏移计算值是不随着文档的滚动而变化,是一定的 jquery-dom元素尺寸的相同参数var $elem = $(&apos;targetSelector&apos;); var element = $elem.get(0); $elem.innerHeight()/innerWidth() 同 element.clientHeight/clientwidth $elem.outerHeight(false)/outerWidth(false) 同 element.offsetHeight/offsetwidth $elem.scrollTop(100)/scrollLeft(100) 同 element.scrollTop/scrollLeft = 100 尺寸和偏移观察测试观察的元素属性，大概是这个样子 各个尺寸css如下 .container { box-sizing: border-box; width: 420px; height: 160px; margin: 20px 10px; padding: 5px 50px; border: solid 1px; } .elem { box-sizing: border-box; height: 40px; width: 150px; margin: 10px; padding: 5px; border: solid 5px blue; } 点击链接可以操作查看各种尺寸和偏移： 尺寸和偏移观察","tags":[{"name":"js","slug":"js","permalink":"http://blueskyawen.com/tags/js/"}]},{"title":"less深入指南二（译）","date":"2018-08-14T16:00:30.000Z","path":"2018/08/15/lessjs-use-depth/","text":"合并合并功能允许将多个属性中的值聚合到单个属性下的逗号或空格分隔列表中。 merge对于背景和变换等属性很有用。 使用逗号附加属性值 Released v1.5.0 .mixin() { box-shadow+: inset 0 0 10px #555; } .myclass { .mixin(); box-shadow+: 0 0 20px black; } 输出 .myclass { box-shadow: inset 0 0 10px #555, 0 0 20px black; } 使用空格附加属性值 Released v1.7.0 .mixin() { transform+_: scale(2); } .myclass { .mixin(); transform+_: rotate(15deg); } 输出 .myclass { transform: scale(2) rotate(15deg); } 为了避免任何无意的连接，merge需要在每个连接挂起声明上使用显式的+或+ _标志。 Mixins混合您可以混合使用类选择器和id选择器，例如： .a, #b { color: red; } .mixin-class { .a(); } .mixin-id { #b(); } 输出 .a, #b { color: red; } .mixin-class { color: red; } .mixin-id { color: red; } 目前和历史上，mixin调用中的括号是可选的，但是不推荐使用可选括号，并且在将来的版本中将需要这些括号。 .a(); .a; // currently works, but deprecated; don&apos;t use 不输出Mixin如果你想创建一个mixin但你不希望mixin以代码形式出现在你的CSS输出中，请在mixin定义之后添加括号。 .my-mixin { color: black; } .my-other-mixin() { background: white; } .class { .my-mixin(); .my-other-mixin(); } 输出 .my-mixin { color: black; } .class { color: black; background: white; } Mixins中的选择器Mixins可以包含的不仅仅是属性，它们也可以包含选择器。 .my-hover-mixin() { &amp;:hover { border: 1px solid red; } } button { .my-hover-mixin(); } 输出 button:hover { border: 1px solid red; } 可以看到编译将my-hover-mixin()的内容仅仅进行了替换，如下： button { &amp;:hover { border: 1px solid red; } } 命名空间如果要在更复杂的选择器中混合属性，可以堆叠多个id或类选择器 #outer() { .inner { color: red; } } .c { #outer &gt; .inner(); } 和空格都是可选的,下面几种形式的效果相同 #outer &gt; .inner(); #outer .inner(); #outer.inner(); 命名空间减少了你的mixins与其他库mixin或用户mixin的冲突，但它也可以是一种“组织”mixins组的方法，比如： #my-library { .my-mixin() { color: black; } } // which can be used like this .class { #my-library.my-mixin(); } 受保护的命名空间如果命名空间是受保护的，则仅在保护条件返回true时才使用由其定义的mixins。 命名空间保护的计算方式与mixin的保护完全相同，因此以下两个mixin的工作方式相同： #namespace when (@mode = huge) { .mixin() { /* */ } } #namespace { .mixin() when (@mode = huge) { /* */ } } 所有嵌套命名空间和mixin的默认函数具有相同的值。以下mixin从未被评估过，其中一名守卫肯定是假的： #sp_1 when (default()) { #sp_2 when (default()) { .mixin() when not(default()) { /* */ } } } !important关键字在mixin调用之后使用！important关键字将其继承的所有属性标记为！important： .foo (@bg: #f5f5f5, @color: #900) { background: @bg; color: @color; } .unimportant { .foo(); } .important { .foo() !important; } 输出 .unimportant { background: #f5f5f5; color: #900; } .important { background: #f5f5f5 !important; color: #900 !important; } 参数混合Mixin如何将参数传递给mixinsMixins也可以接受参数，这些参数是混合在一起时传递给选择器块的变量 .border-radius(@radius) { -webkit-border-radius: @radius; -moz-border-radius: @radius; border-radius: @radius; } 以下是我们如何将其混合到各种规则集中： #header { .border-radius(4px); } .button { .border-radius(6px); } 参数mixin也可以为其参数设置默认值： .border-radius(@radius: 5px) { -webkit-border-radius: @radius; -moz-border-radius: @radius; border-radius: @radius; } 我们现在可以像这样调用它： #header { .border-radius(); } 它将包括5px边界半径。您还可以使用不带参数的参数化mixins。 如果要从CSS输出中隐藏规则集，但希望在其他规则集中包含其属性，这非常有用： .wrap() { text-wrap: wrap; white-space: -moz-pre-wrap; white-space: pre-wrap; word-wrap: break-word; } pre { .wrap() } 输出 pre { text-wrap: wrap; white-space: -moz-pre-wrap; white-space: pre-wrap; word-wrap: break-word; } 具有多个参数的混合 参数可以是分号或逗号分隔，建议使用分号。逗号具有双重含义：它可以解释为mixin参数分隔符或css列表分隔符。使用逗号作为mixin分隔符使得无法将逗号分隔列表创建为参数。另一方面，如果编译器在mixin调用或声明中看到至少一个分号，则它假定参数由分号分隔，并且所有逗号都属于css列表： 两个参数，每个参数都包含以逗号分隔的列表：.name（1,2,3; some，else）， 三个参数，每个包含一个数字：.name（1,2,3）， 使用dummy分号创建mixin调用，其中一个参数包含逗号分隔的css列表：.name（1,2,3;）， 逗号分隔的默认值：.name（@ param1：red，blue;）。 定义具有相同名称和参数数量的多个mixin是合法的。 Less将使用所有可应用的属性。如果你使用带有一个参数的mixin，例如.mixin（绿色）;然后将使用具有一个必需参数的所有mixins的属性： .mixin(@color) { color-1: @color; } .mixin(@color; @padding: 2) { color-2: @color; padding-2: @padding; } .mixin(@color; @padding; @margin: 2) { color-3: @color; padding-3: @padding; margin: @margin @margin @margin @margin; } .some .selector div { .mixin(#008000); } 输出： .some .selector div { color-1: #008000; color-2: #008000; padding-2: 2; } 命名参数 mixin参考可以通过其名称而不仅仅是位置来提供参数值。 任何参数都可以通过其名称引用，并且它们不必具有任何特殊顺序： .mixin(@color: black; @margin: 10px; @padding: 20px) { color: @color; margin: @margin; padding: @padding; } .class1 { .mixin(@margin: 20px; @color: #33acfe); } .class2 { .mixin(#efca44; @padding: 40px); } 输出 .class1 { color: #33acfe; margin: 20px; padding: 20px; } .class2 { color: #efca44; margin: 10px; padding: 40px; } @arguments变量 @arguments在mixins中有一个特殊含义，它包含调用mixin时传递的所有参数。 如果您不想处理单个参数，这非常有用： .mixin(...) { // matches 0-N arguments .mixin() { // matches exactly 0 arguments .mixin(@a: 1) { // matches 0-1 arguments .mixin(@a: 1; ...) { // matches 0-N arguments .mixin(@a; ...) { // matches 1-N arguments .mixin(@a; @rest...) { // @rest is bound to arguments after @a // @arguments is bound to all arguments } 模式匹配有时候，您可能希望根据传递给它的参数来更改mixin的行为，比如： .mixin(dark; @color) { color: darken(@color, 10%); } .mixin(light; @color) { color: lighten(@color, 10%); } .mixin(@_; @color) { display: block; } 下面我们使用它 @switch: light; .class { .mixin(@switch; #888); } 输出 .class { color: #a2a2a2; display: block; } 可以看到，传递给.mixin的颜色减轻了，如果@switch的值是dark，结果将是一个较暗的颜色，这里发生了参数匹配： 第一个mixin定义不匹配，因为它期望dark作为第一个参数。 第二个mixin定义匹配，因为它预期light。 第三个mixin定义匹配，因为它可以是任何值。 仅使用匹配的mixin定义来进行编译输出，变量匹配并绑定到任何值，除变量之外的任何内容仅与值等于其自身的值匹配。我们也可以匹配arity，这是一个例子： .mixin(@a) { color: @a; } .mixin(@a; @b) { color: fade(@a; @b); } 现在如果我们用一个参数调用.mixin，我们将得到第一个定义的输出，但如果我们用两个参数调用它，我们将得到第二个定义，即@a淡化为@b。 从mixin返回值从mixin返回变量或mixins,从Less 3.5开始，您可以使用属性/变量访问器从mixin获取“返回值”，基本上像函数一样使用它。 .average(@x, @y) { @result: ((@x + @y) / 2); } div { padding: .average(16px, 50px)[@result]; // call a mixin and look up its &quot;@return&quot; value } 输出 div { padding: 33px; } 调用范围内的变量 DEPRECATED - 使用属性/值访问器 mixin中定义的变量和mixin是可见的，可以在调用者的范围内使用。 只有一个例外：如果调用者包含一个具有相同名称的变量（包括由另一个mixin调用定义的变量），则不会复制变量。 只有受调用者本地范围中存在的变量才受到保护,从父作用域继承的变量将被重写。 .mixin() { @width: 100%; @height: 200px; } .caller { .mixin(); width: @width; height: @height; } 输出 .caller { width: 100%; height: 200px; } 直接在调用者范围中定义的变量不能被覆盖。 但是，调用者父作用域中定义的变量不受保护，将被覆盖： .mixin() { @size: in-mixin; @definedOnlyInMixin: in-mixin; } .class { margin: @size @definedOnlyInMixin; .mixin(); } @size: globaly-defined-value; // callers parent scope - no protection 输出 .class { margin: in-mixin in-mixin; } 最后，mixin中定义的mixin也可作为返回值使用，例子： .unlock(@value) { // outer mixin .doSomething() { // nested mixin declaration: @value; } } #namespace { .unlock(5); // unlock doSomething mixin .doSomething(); //nested mixin was copied here and is usable } Results in: #namespace { declaration: 5; } 递归混合在Less中，mixin可以自调用。 当与Guard表达式和模式匹配结合使用时，这种递归mixin可用于创建各种迭代/循环结构。 .loop(@counter) when (@counter &gt; 0) { .loop((@counter - 1)); // next iteration width: (10px * @counter); // code for each iteration } div { .loop(5); // launch the loop } 输出 div { width: 10px; width: 20px; width: 30px; width: 40px; width: 50px; } 使用递归循环生成CSS网格类的一般示例： .generate-columns(4); .generate-columns(@n, @i: 1) when (@i =&lt; @n) { .column-@{i} { width: (@i * 100% / @n); } .generate-columns(@n, (@i + 1)); } Output: .column-1 { width: 25%; } .column-2 { width: 50%; } .column-3 { width: 75%; } .column-4 { width: 100%; } Mixin Guards当您想要匹配表达式而不是简单值或arity时，防护很有用。 如果您熟悉函数式编程，则可能已经遇到过它们。为了尽可能地保持CSS的声明性，Less选择通过受保护的mixins而不是if / else语句实现条件执行，这是@media查询功能规范的一部分。举个例子： .mixin(@a) when (lightness(@a) &gt;= 50%) { background-color: black; } .mixin(@a) when (lightness(@a) &lt; 50%) { background-color: white; } .mixin(@a) { color: @a; } 关键是when关键字，它引入了一个保护序列（这里只有一个保护）。 现在，如果我们运行以下代码： .class1 { .mixin(#ddd) } .class2 { .mixin(#555) } 将输出如下： .class1 { background-color: black; color: #ddd; } .class2 { background-color: white; color: #555; } 比较运算符 守卫中可用的比较运算符的完整列表是：&gt;，&gt; =，=，= &lt;，&lt;。 此外，关键字true是唯一的truthy值，使这两个mixin等效： .truth(@a) when (@a) { ... } .truth(@a) when (@a = true) { ... } 除关键字true之外的任何值都认为是false： .class { .truth(40); // Will not match any of the above definitions. } 请注意，您还可以相互比较参数，或使用非参数： @media: mobile; .mixin(@a) when (@media = mobile) { ... } .mixin(@a) when (@media = desktop) { ... } .max(@a; @b) when (@a &gt; @b) { width: @a } .max(@a; @b) when (@a &lt; @b) { width: @b } 逻辑运算符 您可以将逻辑运算符与守卫一起使用，语法基于CSS媒体查询。使用and关键字组合守卫： .mixin(@a) when (isnumber(@a)) and (@a &gt; 0) { ... } 您可以通过用逗号分隔守卫来模拟或运算符： .mixin(@a) when (@a &gt; 10), (@a &lt; -10) { ... } 使用not关键字否定条件： .mixin(@b) when not (@b &gt; 0) { ... } 类型检查方法 最后，如果要根据值类型匹配mixins，可以使用is函数： .mixin(@a; @b: 0) when (isnumber(@b)) { ... } .mixin(@a; @b: black) when (iscolor(@b)) { ... } 常用的方法： iscolor isnumber isstring iskeyword isurl 如果您想检查某个值是否在某个特定单位中而不是数字，您可以使用以下方法之一： ispixel ispercentage isem isunit Mixins别名 Released v3.5.0-beta.4 将mixin调用分配给变量 可以将Mixins分配给变量以作为变量调用来调用，或者可以将其用于映射查找。 #theme.dark.navbar { .colors(light) { primary: purple; } .colors(dark) { primary: black; secondary: grey; } } .navbar { @colors: #theme.dark.navbar.colors(dark); background: @colors[primary]; border: 1px solid @colors[secondary]; } output: .navbar { background: black; border: 1px solid grey; } 可变调用 整个mixin调用可以是别名并称为变量调用。 如： #library() { .rules() { background: green; } } .box { @alias: #library.rules(); @alias(); } 输出 .box { background: green; } 注意，与root中使用的mixin不同，mixin调用分配给变量并且不带参数调用总是需要括号。 以下内容无效。 #library() { .rules() { background: green; } } .box { @alias: #library.colors; @alias; // ERROR: Could not evaluate variable call @alias } 这是因为如果变量被分配了选择器列表或mixin调用，则它是不明确的。 例如，在Less 3.5+中，此变量可以这种方式使用。 .box { @alias: #library.colors; @{alias} { a: b; } } 输出结果： .box #library.colors { a: b; } CSS守卫 released v1.5.0 像Mixin Guards一样，守卫也可以应用于css选择器，这是用于声明mixin然后立即调用它的语法糖。举个例子，在1.5.0之前你必须这样做： .my-optional-style() when (@my-option = true) { button { color: white; } } .my-optional-style(); 现在，你可以直接加在选择器上： button when (@my-option = true) { color: white; } 您还可以通过将此功能与＆功能相结合来实现if类型语句，从而允许您对多个守卫进行分组。 &amp; when (@my-option = true) { button { color: white; } a { color: blue; } } 分离的规则集将整个css规则集当作变量使用 发布v1.7.0 分离的规则集是一组css属性/嵌套规则集/媒体声明或存储在变量中的任何其他内容。 您可以将其包含在规则集或其他结构中，并将其所有属性复制到那里。 您也可以将它用作mixin参数变量进行传递。 @detached-ruleset: { background: red; }; // semi-colon is optional in 3.5.0+ // use detached ruleset .top { @detached-ruleset(); } 输出 .top { background: red; } 分离的规则集调用后的括号是必需的，调用@ detached-ruleset; 是不行的。 当您想要定义一个在媒体查询中或者从不支持的浏览器类名中抽象出来的mixin时，它非常有用，例如， .desktop-and-old-ie(@rules) { @media screen and (min-width: 1200px) { @rules(); } html.lt-ie9 &amp; { @rules(); } } header { background-color: blue; .desktop-and-old-ie({ background-color: red; }); } 这里的desktop-and-old-ie定义了媒体查询和根类，以便您可以使用mixin来包装一段代码。 这将输出 header { background-color: blue; } @media screen and (min-width: 1200px) { header { background-color: red; } } html.lt-ie9 header { background-color: red; } 此外，还可以带代表完整的Less规则集，例如， @my-ruleset: { .my-selector { background-color: black; } }; 甚至可以利用媒体查询冒泡 @my-ruleset: { .my-selector { @media tv { background-color: black; } } }; @media (orientation:portrait) { @my-ruleset(); } //output @media (orientation: portrait) and tv { .my-selector { background-color: black; } } 分离规则集的调用以与mixin调用相同的方式解锁（返回）其所有mixin到调用者，但是，它不返回变量。 // detached ruleset with a mixin @detached-ruleset: { .mixin() { color:blue; } }; // call detached ruleset .caller { @detached-ruleset(); .mixin(); } 输出 .caller { color: blue; } 私有变量： @detached-ruleset: { @color:blue; // this variable is private }; .caller { color: @color; // syntax error } 作用域分离的规则集可访问变量和mixin的范围，包括定义它的位子以及调用它的位置。如果两个范围包含相同的变量或mixin，则声明范围值优先。声明范围是定义分离规则集主体的范围。 规则集仅通过引用访问，将分离的规则集从一个变量复制到另一个变量而不能修改其范围。最后，分离的规则集可以通过解锁（导入）到范围来获得对范围的访问。 定义范围可见性 分离的规则集可以看到调用者的变量和mixins： @detached-ruleset: { caller-variable: @caller-variable; // variable is undefined here .caller-mixin(); // mixin is undefined here }; selector { // use detached ruleset @detached-ruleset(); // define variable and mixin needed inside the detached ruleset @caller-variable: value; .caller-mixin() { variable: declaration; } } 编译输出： selector { caller-variable: value; variable: declaration; } 变量和mixins可访问的同名变量定义胜过调用者中可用的那些： @variable: global; @detached-ruleset: { variable: @variable; }; selector { @detached-ruleset(); @variable: value; } 编译输出 selector { variable: global; } 引用不会修改分离的规则集范围 规则集仅通过在那里引用而无法访问新范围： @detached-1: { scope-detached: @one @two; }; .one { @one: visible; .two { @detached-2: @detached-1; // copying/renaming ruleset @two: visible; // ruleset can not see this variable } } .use-place { .one &gt; .two(); @detached-2(); } throws an error:ERROR 1:32 The variable “@one” was not declared. 解锁将修改分离的规则集范围 分离的规则集通过在作用域内解锁（导入）来获得访问权限： #space { .importer-1() { @detached: { scope-detached: @variable; }; // define detached ruleset } } .importer-2() { @variable: value; // unlocked detached ruleset CAN see this variable #space &gt; .importer-1(); // unlock/import detached ruleset } .use-place { .importer-2(); // unlock/import detached ruleset second time @detached(); } compiles into: .use-place { scope-detached: value; }","tags":[{"name":"Less","slug":"Less","permalink":"http://blueskyawen.com/tags/Less/"}]},{"title":"less深入指南一（译）","date":"2018-08-13T16:00:30.000Z","path":"2018/08/14/lessjs-use/","text":"这是有关LESS语言功能的深入指南，有关Less的简单概念和语法，请参阅less概述。有关安装和设置Less环境的深入指南，以及有关Less开发的文档，可查看上一篇译文less.js用法 变量使用单个变量控制常用值 概览在样式表中看到相同的值重复数十甚至数百次，这种情况并不罕见，比如下面的颜色值： a, .link { color: #428bca; } .widget { color: #fff; background: #428bca; } 通过使用变量可以使您的代码更易于维护： // Variables @link-color: #428bca; // sea blue @link-color-hover: darken(@link-color, 10%); // Usage a, .link { color: @link-color; } a:hover { color: @link-color-hover; } .widget { color: #fff; background: @link-color; } 变量插值上面的示例着重于使用变量来控制CSS规则中的值，但它们也可以在其他地方使用，例如选择器名称，属性名称，URL和@import语句，相当于其他语言里的一个宏替代。 应用于选择器 // Variables @my-selector: banner; // Usage .@{my-selector} { font-weight: bold; line-height: 40px; margin: 0 auto; } 编译后： .banner { font-weight: bold; line-height: 40px; margin: 0 auto; } 应用于属性 @property: color; .widget { @{property}: #0ee; background-@{property}: #999; } 编译后： .widget { color: #0ee; background-color: #999; } 应用于URL @images: &quot;../img&quot;; // Usage body { color: #444; background: url(&quot;@{images}/white-sand.png&quot;); } 应用于@import语句 请注意，在v2.0.0之前，只考虑在根或当前作用域中声明的变量，并且在查找变量时仅考虑当前文件和调用文件。 @themes: &quot;../../src/themes&quot;; // Usage @import &quot;@{themes}/tidal-wave.less&quot;; 变量的变量在Less中，您可以使用变量来定义另一个变量的名称，进行间接替代 @primary: green; @secondary: blue; .section { @color: primary; .element { color: @@color; } } 编译后： .section .element { color: green; } 懒评估在less中变量可以后向声明，即变量可以先使用，后声明 .lazy-eval { width: @var; } @var: @a; @a: 9%; 编译后： .lazy-eval { width: 9%; } 当定义相同变量两次时，在一个作用域内使用变量的最后一个定义，这与css本身类似，其中定义中的最后一个属性用于确定最后的替代值，比如： @var: 0; .class { @var: 1; .brass { @var: 2; three: @var; @var: 3; } one: @var; } 编译后： .class { one: 1; } .class .brass { three: 3; } 实质上，每个作用域范围都有一个“最终”值，类似于浏览器中的属性，就像使用自定义属性的示例： .header { --color: white; color: var(--color); // the color is black --color: black; } 这意味着，与其他CSS预处理语言不同，Less变量的行为与CSS非常相似。 属性即变量（新特性）在最新的V3.0.0版本中，你可以直接把css属性名当作“变量”来使用，只要利用$符号，这样有时候可以使你的代码更加轻量化，比使用@事先定义变量要方便，例如： .widget { color: #efefef; background-color: $color; } 编译后： .widget { color: #efefef; background-color: #efefef; } 请注意，与变量一样，Less将选择当前/父范围内的最后一个属性作为“最终”值。 .block { color: red; .inner { background-color: $color; //使用的blue } color: blue; } 默认变量我们有时会收到默认变量的请求 - 只有在尚未设置变量时才能设置变量。 此功能不是必需的，因为您可以通过后面的定义轻松覆盖变量。 // library @base-color: green; @dark-color: darken(@base-color, 10%); // use of library @import &quot;library.less&quot;; @base-color: red; 其中，@base-color被重写了，最后生效的是red 父选择器使用＆引用父选择器＆运算符表示嵌套规则的父选择器，在将链接类或伪类应用于现有选择器时最常用： a { color: blue; &amp;:hover { color: green; } &amp;.b { color: black; } } 编译后： a { color: blue; } a:hover { color: green; } a.b { color: black; } 可以看到，＆就是代表父选择器a,编译后作了替换链接“父选择器”运算符具有多种用途，本上，只要您需要嵌套规则的选择器以默认的其他方式组合。 例如，＆的另一个典型用法是产生重复的类名： .button { &amp;-ok { background-image: url(&quot;ok.png&quot;); } &amp;-cancel { background-image: url(&quot;cancel.png&quot;); } &amp;-custom { background-image: url(&quot;custom.png&quot;); } } 编译后： .button-ok { background-image: url(&quot;ok.png&quot;); } .button-cancel { background-image: url(&quot;cancel.png&quot;); } .button-custom { background-image: url(&quot;custom.png&quot;); } 多次使用&amp;＆可能会在选择器中出现多次。，这使得可以重复引用父选择器而不重复其名称。 .link { &amp; + &amp; { color: red; } &amp; &amp; { color: green; } &amp;&amp; { color: blue; } &amp;, &amp;ish { color: cyan; } } 编译后： .link + .link { color: red; } .link .link { color: green; } .link.link { color: blue; } .link, .linkish { color: cyan; } 请注意，＆表示的多层嵌套的父选择器（不仅仅是最近的祖先），因此以下示例： .grand { .parent { &amp; &gt; &amp; { color: red; } &amp; &amp; { color: green; } &amp;&amp; { color: blue; } &amp;, &amp;ish { color: cyan; } } } 输出： .grand .parent &gt; .grand .parent { color: red; } .grand .parent .grand .parent { color: green; } .grand .parent.grand .parent { color: blue; } .grand .parent, .grand .parentish { color: cyan; } 更改选择器顺序将选择器添加到继承的（父）选择器可能很有用。 这可以通过放置＆after当前选择器来完成。 例如，使用Modernizr时，您可能希望根据支持的功能指定不同的规则： .header { .menu { border-radius: 5px; .no-borderradius &amp; { background-image: url(&apos;images/button-background.png&apos;); } } } 编译输出： .header .menu { border-radius: 5px; } .no-borderradius .header .menu { background-image: url(&apos;images/button-background.png&apos;); } 组合选择器＆还可用于生成逗号分隔列表中每个可能的选择器排列： p, a, ul, li { &amp; + &amp; { border-top: 0; } } 编译输出： p + p, p + a, p + ul, p + li, a + p, a + a, a + ul, a + li, ul + p, ul + a, ul + ul, ul + li, li + p, li + a, li + ul, li + li { border-top: 0; } Extend伪类 发布v1.4.0 Extend是一个Less伪类，它将放置的选择器与它引用的选择器相匹配。 nav ul { &amp;:extend(.inline); background: blue; } .inline { color: red; } 在上面的规则集中，:extend选择器将“扩展选择器”（nav ul）应用到.inline类，即将.inline的css属性扩展到父选择器“nav ul”。编译输出： nav ul { background: blue; } .inline, nav ul { color: red; } 注意，nav ul:extend(.inline）选择器如何作为nav ul输出 - 在输出之前删除extend并且选择器块保持原样。 如果没有属性放入该块，则它将从输出中删除（但扩展仍可能影响其他选择器） 扩展语法extend可以附加到选择器，也可以放在规则集中。 .a:extend(.b) {} .a { &amp;:extend(.b); } // the above blocks does the same thing 它看起来像一个带有selector参数的伪类，后面可以跟可选的关键字all： .c:extend(.d all) { // extends all instances of &quot;.d&quot; e.g. &quot;.x.d&quot; or &quot;.d.x&quot; } .d { color: red; } .d.classX { font-size: 12px; } .classY.d { font-weight: 800; } //输出 .c,.d { color: red; } .c.classX,.d.classX { font-size: 12px; } .classY.c,.classY.d { font-weight: 800; } 它可以包含一个或多个要扩展的类，用逗号分隔,下面的例子实现的效果相同 .e:extend(.f) {} .e:extend(.g) {} // the above an the below do the same thing .e:extend(.f, .g) {} 扩展附加到选择器附加到选择器的扩展看起来像普通的伪类，选择器作为参数。 选择器可以包含多个extend子句，但所有extends都必须位于选择器的末尾。 pre:extend(div pre) { ... } 同 pre { ... &amp;:extend(div pre)； } 在伪类后扩展,比如 pre:hover:extend(div pre) 允许选择器和扩展之间的空间,比如pre:hover :extend(div pre) 允许多个扩展,pre:hover:extend(div pre):extend(.bucket tr) - 注意这与下面表示效果相同: pre:hover:extend（div pre，.bucket tr） 下面这样是不允许的：pre：hover：extend（div pre）.nth-child（odd）,因为extend必须在最后。 如果规则集包含多个选择器，则其中任何一个都可以包含extend关键字,比如： .big-division, .big-bag:extend(.bag), .big-bucket:extend(.bucket) { // body } 扩展内部规则集可以使用＆:extend（selector）语法将Extend放入规则集的正文中。 将extend放置到body中是将其放入该规则集的每个选择器的快捷方式。比如，下面两个例子的效果是一样的 pre:hover, .some-class { &amp;:extend(div pre); } pre:hover:extend(div pre), .some-class:extend(div pre) {} 扩展嵌套选择器Extend能够匹配嵌套选择器,例如： .bucket { tr { // nested ruleset with target selector color: blue; } } .some-class:extend(.bucket tr) {} // nested ruleset is recognized 输出 .bucket tr, .some-class { color: blue; } 本质上，扩展会查看已编译的css，而不是原始的less .bucket { tr &amp; { // nested ruleset with target selector color: blue; } } .some-class:extend(tr .bucket) {} // nested ruleset is recognized 输出 tr .bucket, .some-class { color: blue; } 与Extend完全匹配默认情况下，扩展会查找选择器之间的完全匹配。选择器是否使用前导星比较重要。 两个第n个表达式具有相同的含义并不重要，它们需要具有相同的形式才能匹配。 唯一的例外是属性选择器中的引号，较少知道它们具有相同的含义并匹配它们。 .a.class, .class.a, .class &gt; .a { color: blue; } .test:extend(.class) {} // this will NOT match the any selectors above *.class { color: blue; } .noStar:extend(.class) {} // this will NOT match the *.class selector 伪类的顺序很重要。 选择器链接：hover：visited和link：visited：hover匹配相同的元素集，但extend将它们视为不同： link:hover:visited { color: blue; } .selector:extend(link:visited:hover) {} //NOT match link:hover:visite nth表达式表示第N个表达形式很重要。 第N个表达式1n + 3和n+3是等价的，但是extend不匹配它们 :nth-child(1n+3) { color: blue; } .child:extend(:nth-child(n+3)) {} //NOT match 属性选择器中的引用类型无关紧要，以下所有内容都是等效的。 [title=identifier] { color: blue; } [title=&apos;identifier&apos;] { color: blue; } [title=&quot;identifier&quot;] { color: blue; } .noQuote:extend([title=identifier]) {} .singleQuote:extend([title=&apos;identifier&apos;]) {} .doubleQuote:extend([title=&quot;identifier&quot;]) {} 输出 [title=identifier], .noQuote, .singleQuote, .doubleQuote { color: blue; } [title=&apos;identifier&apos;], .noQuote, .singleQuote, .doubleQuote { color: blue; } [title=&quot;identifier&quot;], .noQuote, .singleQuote, .doubleQuote { color: blue; } 扩展所有all当你在extend参数中指定all关键字时，它会告诉Less将该选择器与另一个选择器的一部分相匹配。 将复制选择器，然后仅使用extend替换选择器的匹配部分，从而生成新的选择器。 .a.b.test, .test.c { color: orange; } .test { &amp;:hover { color: green; } } .replacement:extend(.test all) {} 输出 .a.b.test, .test.c, .a.b.replacement, .replacement.c { color: orange; } .test:hover, .replacement:hover { color: green; } 您可以将此操作模式视为基本上进行非破坏性搜索和替换。 具有扩展的选择器插值Extend无法将选择器不能匹配变量，也不能匹配被变量代表的选择器。 比如下面的情况将不生效： @variable: .bucket; @{variable} { // interpolated selector color: blue; } .some-class:extend(.bucket) {} // does nothing, no match is found .bucket { color: blue; } .some-class:extend(@{variable}) {} // interpolated selector matches nothing @variable: .bucket; 但是，extend可以附加到插值选择器上，即插值选择器可以作为extend的父，不能作为extend的子,比如： .bucket { color: blue; } @{variable}:extend(.bucket) {} @variable: .selector; //编译后 .bucket, .selector { color: blue; } 在@media媒体查询内扩展目前，在@media声明中扩展只会匹配同一媒体声明中的选择器： @media print { .screenClass:extend(.selector) {} // extend inside media .selector { // this will be matched - it is in the same media color: black; } } .selector { // ruleset on top of style sheet - extend ignores it color: red; } @media screen { .selector { // ruleset inside another media - extend ignores it color: blue; } } 编译后： @media print { .selector, .screenClass { /* ruleset inside the same media was extended */ color: black; } } .selector { /* ruleset on top of style sheet was ignored */ color: red; } @media screen { .selector { /* ruleset inside another media was ignored */ color: blue; } } 注意：扩展与嵌套的@media声明中的选择器不匹配： @media screen { .screenClass:extend(.selector) {} // extend inside media @media (min-width: 1023px) { .selector { // ruleset inside nested media - extend ignores it color: blue; } } } //extend不生效 最外层顶级扩展,可以匹配嵌套媒体内的选择器在内的所有内容： @media screen { .selector { /* ruleset inside nested media - top level extend works */ color: blue; } @media (min-width: 1023px) { .selector { /* ruleset inside nested media - top level extend works */ color: blue; } } } .topLevel:extend(.selector) {} /* top level extend matches everything */ 编译后： @media screen { .selector, .topLevel { /* ruleset inside media was extended */ color: blue; } } @media screen and (min-width: 1023px) { .selector, .topLevel { /* ruleset inside nested media was extended */ color: blue; } } 复制检测目前没有重复检测。 .alert-info, .widget { /* declarations */ } .alert:extend(.alert-info, .widget) {} 输出 .alert-info, .widget, .alert, .alert { /* declarations */ } 用例扩展经典用例 经典用例是避免添加基类，比如： .animal { background-color: black; color: white; } 并且您希望拥有一个覆盖背景颜色的动物子类型，那么您有两个选项，首先更改您的HTML &lt;a class=&quot;animal bear&quot;&gt;Bear&lt;/a&gt; .animal { background-color: black; color: white; } .bear { background-color: brown; } 或者简化了html并使用了更少的扩展。 例如 &lt;a class=&quot;bear&quot;&gt;Bear&lt;/a&gt; .animal { background-color: black; color: white; } .bear { &amp;:extend(.animal); background-color: brown; } 减少CSS大小 Mixins将所有属性复制到选择器中，这可能导致不必要的重复。 因此，您可以使用extends而不是mixins将选择器移动到您希望使用的属性，从而减少生成的CSS。 .my-inline-block() { display: inline-block; font-size: 0; } .thing1 { .my-inline-block; } .thing2 { .my-inline-block; } 输出 .thing1 { display: inline-block; font-size: 0; } .thing2 { display: inline-block; font-size: 0; } 又例如 .my-inline-block { display: inline-block; font-size: 0; } .thing1 { &amp;:extend(.my-inline-block); } .thing2 { &amp;:extend(.my-inline-block); } 输出 .my-inline-block, .thing1, .thing2 { display: inline-block; font-size: 0; } 结合样式/更高级的Mixin 另一个用例是mixin的替代方案 - 因为mixins只能用于简单的选择器，如果你有两个不同的html块，但是需要将相同的样式应用于两者，你可以使用extends来关联两个区域。 li.list &gt; a { // list styles } button.list-style { &amp;:extend(li.list &gt; a); // use the same list styles }","tags":[{"name":"Less","slug":"Less","permalink":"http://blueskyawen.com/tags/Less/"}]},{"title":"less.js用法（译）","date":"2018-08-09T16:00:15.000Z","path":"2018/08/10/less-common/","text":"命令行用法使用命令行将.less文件编译为.css 安装npm install less -g -g选项代表安装全局，安装后可用于命令行。 如果需要安装特定版本或标记的less，可以在包名称之后添加@VERSION，例如 npm install less@2.7.1 -g 开发本地安装如果您不想全局安装，也可以本地安装 npm i less --save-dev 这将在项目文件夹中安装最新的lessc正式版，并将其添加到项目的package.json的devDependencies中 lessc的Beta版本随着新功能的开发，lessc版本将定期的发布到npm，标记为beta。这些版本不会作为@latest官方发行版发布，并且通常会在版本中发布beta版（使用lessc -v获取当前版本）。由于补丁版本不会中断，我们将立即发布补丁版本，alpha / beta /候选版本将作为次要或主要版本升级发布（我们努力从1.4.0开始遵循语义版本控制）。 服务端命令行用法二进制文件bin / lessc可与* nix，OS X和Windows上的Node.js一起使用。 用法lessc [option option=parameter ...] &lt;source&gt; [destination] 如果source设置为` - ‘（破折号或连字符减号），则从stdin读取输入。例子： lessc bootstrap.less bootstrap.css lessc配置参数想要获取更多的参数和用法，请参看Less Options Silent 停止显示任何警告。 lessc -s lessc --silent Version 查看版本。 lessc -v / lessc --version help 打印包含可用选项和退出的帮助消息。 lessc --help / lessc -h Makefile 将导入到依赖关系列表的生成文件输出到stdout。 lessc -M lessc --depends No Color lessc --no-color Clean CSS 在v2中，Clean CSS不再作为直接依赖项包含在内。 要使用Clean CSS，请使用clean css插件。 浏览器端用法在浏览器中使用Less.js是最简单的入门方式，便于使用Less进行开发，但在生产中，当性能和可靠性很重要时，我们建议使用Node.js或许多第三方工具之一进行预编译首先，将.less样式表与rel属性设置为“stylesheet / less”链接： &lt;link rel =“stylesheet / less”type =“text / css”href =“styles.less”/&gt; 然后，将less.js包含在页面head元素的&lt;script&gt; &lt;/ script&gt;标记中： &lt;script src =“less.js”type =“text / javascript”&gt; &lt;/ script&gt; 配置参数可以通过在less脚本加载之前使用对象来设置参数选项，这会影响所有初始链接标记和less使用。 &lt;script&gt; less = { env: &quot;development&quot;, async: false, fileAsync: false, poll: 1000, functions: {}, dumpLineNumbers: &quot;comments&quot;, relativeUrls: false, rootpath: &quot;:/a.com/&quot; }; &lt;/script&gt; &lt;script src=&quot;less.js&quot;&gt;&lt;/script&gt; 另一张方式也可以再标签上直接设置参数 &lt;script&gt; less = { env: &quot;development&quot; }; &lt;/script&gt; &lt;script src=&quot;less.js&quot; data-env=&quot;development&quot;&gt;&lt;/script&gt; 或者为了简洁起见，可以将它们设置为脚本和链接标记上的属性： &lt;script src=&quot;less.js&quot; data-poll=&quot;1000&quot; data-relative-urls=&quot;false&quot;&gt;&lt;/script&gt; &lt;link data-dump-line-numbers=&quot;all&quot; data-global-vars=&apos;{ &quot;myvar&quot;: &quot;#ddffee&quot;, &quot;mystr&quot;: &quot;\\&quot;quoted\\&quot;&quot; }&apos; rel=&quot;stylesheet/less&quot; type=&quot;text/css&quot; href=&quot;less/styles.less&quot;&gt; 浏览器环境支持Less.js支持所有现代浏览器（Chrome，Firefox，Safari，IE11 +和Edge的最新版本）。 虽然在生产中可以在客户端使用Less，但请注意这样做会对性能产生影响（尽管Less的最新版本速度要快得多）。 此外，如果发生JavaScript错误，有时会出现装饰性问题。 这是灵活性与速度的折衷。 为了尽可能提高静态网站的性能，我们建议在服务器端编译Less。 注意事项 确保在脚本之前包含样式表。 当您链接多个.less样式表时，每个样式表都是独立编译的 因此，您在样式表中定义的任何变量，混合或名称空间都无法访问。 由于浏览器的原始策略相同，因此加载外部资源需要启用CORS 监控模式要启用监视模式，必须将选项env设置为开发。然后在包含less.js文件之后，调用less.watch（），如下所示： &lt;script&gt;less = { env: &apos;development&apos;};&lt;/script&gt; &lt;script src=&quot;less.js&quot;&gt;&lt;/script&gt; &lt;script&gt;less.watch();&lt;/script&gt; 或者，您可以通过将＃！watch附加到URL来临时启用“监视”模式。 变量修改启用Less变量的运行时修改。 使用新值调用时，将重新编译Less文件而不重新加载。 简单的基本用法： less.modifyVars({ &apos;@buttonFace&apos;: &apos;#5B83AD&apos;, &apos;@buttonText&apos;: &apos;#D9EEF2&apos; }); 调试可以在CSS中输出规则，允许工具找到规则的来源。如上所述指定选项dumpLineNumbers或将！dumpLineNumbers：mediaquery添加到url您可以将mediaquery选项与FireLESS一起使用（它与SCSS媒体查询调试格式相同）。 另请参阅FireLess和Less v2。 comment选项可用于在内联编译的CSS代码中显示文件信息和行号。 选项&lt;!-- set options before less.js script --&gt; &lt;script&gt; less = { env: &quot;development&quot;, logLevel: 2, async: false, fileAsync: false, poll: 1000, functions: {}, dumpLineNumbers: &quot;comments&quot;, relativeUrls: false, globalVars: { var1: &apos;&quot;quoted value&quot;&apos;, var2: &apos;regular value&apos; }, rootpath: &quot;:/a.com/&quot; }; &lt;/script&gt; &lt;script src=&quot;less.js&quot;&gt;&lt;/script&gt; lessc配置参数想要获取更多的参数和用法，请参看Less Options 异步async 类型：布尔值默认值：false是否使用async选项请求导入文件。请参阅fileAsync。 env运行环境 类型：字符串默认值：取决于页面URL，运行环境可以是开发或生产。例如：less = {env：’production’};在生产中，您的css缓存在本地存储中，信息消息不会输出到控制台。如果文档的URL以file：//开头，或者在本地计算机上或具有非标准端口，则它将自动设置为开发。 errorReporting 类型：字符串选项：html | console | function默认值：html编译失败时设置错误报告方法。 fileAsync 类型：布尔值默认值：false是否在具有文件协议的页面中异步请求导入。函数（不推荐使用 - 使用@plugin）类型：对象用户功能，按名称键入。 less = { 功能： { myfunc：function（）{ 返回less.Dimension（1）; } } }; 它可以像原生的Less函数一样使用，例如 .myclass { border-width：unit（myfunc（），px）; } logLevel 类型：数字默认值：22 - 信息和错误1 - 错误0 - 没什么javascript控制台中的日志记录量。注意：如果您在生产环境中，则不会进行任何记录。 poll 类型：整数默认值：1000处于监视模式时轮询之间的时间量（以毫秒为单位）。 relativeUrls 类型：布尔值默认值：false（可选）将URL调整为相对。如果为false，则URL已经相对于entry-less文件 useFileCache 类型：布尔值默认值：true（之前在v2之前为false）是否使用每个会话文件缓存。这会缓存较少的文件，以便您可以调用modifyVars，并且它不会再次检索所有较少的文件。如果使用观察程序或使用reload设置为true调用refresh，则在运行之前将清除缓存。 Less.js选项跨平台选项包括路径 lessc --include-path = PATH1; PATH2 {paths：[&apos;PATH1&apos;，&apos;PATH2&apos;]} 如果@import规则中的文件不存在于该确切位置，则Less将在传递给此选项的位置查找该文件。 例如，您可以使用它在Less文件中指定要引用库的相对路径。 Rootpath lessc -rp=resources/ lessc --rootpath=resources/ { rootpath: &apos;resources/&apos; } 如果@import规则中的文件不存在于该确切位置，则Less将在传递给此选项的位置查找该文件。 例如，您可以使用它在Less文件中指定要引用库的相对路径。 相对URL lessc -ru lessc --relative-urls {relativeUrls：true} 默认情况下，URL保持原样，因此如果您在引用图像的子目录中导入文件，则将在css中输出完全相同的URL。此选项允许您在导入的文件中重写URL，以便URL始终相对于基本导入的文件。例如。 // main.less @import“files / backgrounds.less”; // files / backgrounds.less .icon-1 { background-image：url（&apos;images / lamp-post.png&apos;）; } 正常输出以下内容 .icon-1 { background-image：url（&apos;images / lamp-post.png&apos;）; } 但是使用relativeUrls：true，它将输出 .icon-1 { background-image：url（&apos;files / images / lamp-post.png&apos;）; } 您可能还需要考虑使用data-uri函数而不是此选项，它会将图像嵌入到css中。 Strict Math lessc -sm = on lessc --strict-math = on {strictMath：true} 默认为off / false。如果没有此选项，Less将尝试处理您的CSS中的所有数学，例如在： .class { grid-column：3/6; } 3/6将导致2。 严格的数学运算，只处理不必要的括号内的数学。例如。 .class { grid-column：3/6; height：40px + 2px; width：（40px + 2px）; } .class { grid-column：3/6; width：40px + 2px; width：42px; } 我们原计划在未来将此默认为true，但它一直是一个有争议的选项，我们正在考虑我们是否以正确的方式解决了问题，或者Less是否应该只对有效或无效的实例有例外。 Strict Units lessc -su = on lessc --strict-units = on {strictUnits：true} 默认为off / false。如果没有此选项，则在数学运算时尝试猜测输出单位。例如 .class { property：1px * 2px; } 在这种情况下，事情显然是不对的 - 长度乘以长度给出一个区域，但css不支持指定区域。所以我们假设用户意味着其中一个值是一个值，而不是长度单位，我们输出2px。如果打开严格的单位，我们假设这是计算中的错误并抛出错误。 全局变量 lessc --global-var =“color1 = red”{globalVars：{color1：&apos;red&apos;}} 此选项定义可由文件引用的变量。变量的声明放在基础Less文件的顶部，这意味着可以使用它，也可以覆盖它。 修改变量 lessc --modify-var =“color1 = red”{modifyVars：{color1：&apos;red&apos;}} 与全局变量选项相反，这会将声明放在基本文件的末尾，这意味着它将覆盖Less文件中定义的任何内容。 URL参数 lessc --url-args =“cache726357”{urlArgs：&apos;cache726357&apos;} 此选项允许您指定要转到每个URL的参数。例如，这可以用于缓存清除。 预装插件 请参阅：预加载插件 lint检查 lessc --lint -l {lint：true} 运行较少的解析器，只报告错误而不输出任何内容。 压缩 lessc --compress -x {compress：true} 使用较少的内置压缩进行压缩。这项工作做得不错，但没有利用专用css压缩的所有技巧。请随时通过pull请求改进我们的压缩输出。 允许从不安全的HTTPS主机导入 lessc --insecure {insecure：true} 源映射选项大多数这些选项不适用于在浏览器中使用，因为您应该使用预编译的Less文件生成源映射。 生成源映射 lessc --source-map {sourceMap：{}} 源映射输出文件名 lessc --source-map=file.map { sourceMap: { outputFilename: &apos;file.map&apos; } } 源映射Rootpath lessc --source-map-rootpath=dev-files/ { sourceMap: { sourceMapRootpath: &apos;dev-files/&apos; } } 指定添加前导路径到源映射内的每个less文件路径，以及输出css中指定的映射文件的路径.由于basepath默认为输入较少文件的目录，因此根路径默认为从sourcemap输出文件到input less文件的基目录的路径。例如，如果您在Web服务器的根目录中生成了css文件，但将源/ less / css / map文件放在不同的文件夹中，请使用此选项 output.css dev-files/output.map dev-files/main.less 源映射Basepath lessc --source-map-basepath=less-files/ { sourceMap: { sourceMapBasepath: &apos;less-files/&apos; } } 这与rootpath选项相反，它指定应从输出路径中删除的路径。 例如，如果要编译less-files目录中的文件，但源文件将在根目录或当前目录中的Web服务器上可用，则可以指定此文件以删除路径中的其他less-files部分。它默认为输入less文件的路径。 在源映射中包含less源文件 lessc --source-map-include-source {sourceMap：{outputSourceFiles：true}} 此选项指定将所有Less文件包含在sourcemap中。这意味着您只需要映射文件即可获得原始来源。这可以与map inline选项一起使用，这样您根本不需要任何其他外部文件。 源映射内联 lessc --source-map-inline {sourceMap：{sourceMapFileInline：true}} 此选项指定映射文件应在输出内联CSS。这不建议用于生产，但是对于开发，它允许编译器在支持它的浏览器中生成单个输出文件，表现为使用的是编译后的css但显示的却是未编译的less源文件。 源映射URL lessc --source-map-url = .. / my-map.json {sourceMap：{sourceMapURL：&apos;.. / my-map.json&apos;}} 允许覆盖css中指向映文件的URL。这适用于rootpath和basepath选项未完全生成所需内容的情况。 预加载插件在Less.js开始解析之前加载插件虽然使用插件的最简单方法是使用@plugin-at-rule ，但在Node.js环境中，您可以通过命令行预先加载全局Less.js插件，或者在Less选项中指定它。 预处理如果要添加Less.js预处理器，则需要预加载插件。 也就是说，在解析之前会传递原始Less源并调用插件。 一个例子是Sass-To-Less预处理器插件。注意：预评估插件不需要预加载（在解析Less源之后，但在评估之前）。 Node.js使用使用命令行如果你使用lessc，你需要做的第一件事是安装该插件。 像NPM一样，我们建议使用“less-plugin-”前缀来注册Less.js插件（以便于搜索），尽管这不是必需的。 因此，对于自定义插件，您可以安装： npm install less-plugin-myplugin 要使用该插件，只需编写代码即可在命令行上传递： lessc --myplugin 每当有一个未知的Less选项（如“myplugin”）时，Less.js将尝试加载“less-plugin-myplugin”和“myplugin”模块作为插件。您还可以使用以下命令显式指定插件： lessc --plugin = myplugin 要将选项传递给插件，您可以使用以下两种方式之一来编写它。 lessc --myplugin =“advanced” lessc --plugin = myplugin = advanced 通过Less.js加载插件在Node中，require插件时需要将其作为插件数组来传递less插件。 例如。 var LessPlugin = require(&apos;less-plugin-myplugin&apos;); less.render(myCSS, { plugins: [LessPlugin] }) .then( function(output) { }, function(error) { } ); 编程使用编程中只要使用less的less.render函数来实现，比如 //返回承诺 less.render(lessInput, options) .then(function(output) { // output.css = string of css // output.map = string of sourcemap // output.imports = array of string filenames of the imports referenced }, function(error) { }); // or... //回调方法 less.render(css, options, function(error, output) {}) 如上所示，options参数是可选的。如果指定了回调方法，则不会返回承诺，如果您没有指定回调方法则会给出承诺。在编译引擎下，使用回调版本，以便可以同步使用less如果要渲染文件，首先要将其转化为字符串（传递给less.render），然后将options选项参数上的filename字段设置为主文件的文件名。 less会处理所有的导入。sourceMap选项是一个对象，可用于设置子源图选项。 可用的子选项包括：sourceMapURL，sourceMapBasepath，sourceMapRootpath，outputSourceFiles和sourceMapFileInline。 请注意，sourceMap选项现在不适用于浏览器编译器中的less.js. less.render(lessInput) .then(function(output) { // output.css = string of css // output.map = undefined } //, less.render(lessInput, {sourceMap: {}}) .then(function(output) { // output.css = string of css // output.map = string of sourcemap } //or, less.render(lessInput, {sourceMap: {sourceMapFileInline: true}}) .then(function(output) { // output.css = string of css \\n /*# sourceMappingURL=data:application/json;base64,eyJ2ZXJ..= */ // output.map = undefined } 访问日志您可以使用以下代码添加日志侦听器 less.logger.addListener({ debug: function(msg) { }, info: function(msg) { }, warn: function(msg) { }, error: function(msg) { } }); 注意：所有功能都是可选的。 less本身不会记录错误，而是将错误传递回less.render中的回调或承诺 为Less.js做贡献这部分就描述了，有兴趣的同学可以访问下源文为Less.js做贡献","tags":[{"name":"Less","slug":"Less","permalink":"http://blueskyawen.com/tags/Less/"}]},{"title":"JQuery-插件","date":"2018-07-31T04:15:45.000Z","path":"2018/07/31/jq-plugin/","text":"JQuery插件是对jquery函数库的一种扩展，以便在不同地方可以复用JQuery插件主要有三种： 对象方法的插件：封装对象的操作，插件函数可直接应用与jq对象，改变对象的外观和行为等 全局方法的插件：封装操作进jquery命名空间，可理解为给jquery添加静态函数，处理能力和一般的全局函数差不多,典型的是$.ajax()方法 选择器插件：封装属于自己的新的jquery选择器 在编写插件之前，先介绍一下两个重要的方法，在后面的插件书写中有重要的作用 闭包注册闭包是js的特色，相比大家比较熟悉，在插件中有着很好的应用 ;(function($) { ....插件扩展代码 })(JQuery); 这里有两个作用： 闭包函数自运行，将插件方注册金jquery里 以$为入参，传入jquery，这样在插件内部就可以直接使用$ $.extend$.extend方法用于合并扩展对象 $.extend(targetObj,object1,object2,...) 后面的对象同名成员将覆盖前面对象的成员，否则就合并起来,targetObj是合并后的对象，举个例子： $.extend({},{name:&apos;jack&apos;,age:18,sex:&apos;man&apos;}); 结果：{name:&apos;jack&apos;,age:18,sex:&apos;man&apos;} $.extend({name:&apos;jack&apos;,age:18},{name:&apos;tom&apos;,sex:&apos;man&apos;}); 结果：{name:&apos;tom&apos;,age:18,sex:&apos;man&apos;} 插件1) 对象方法的插件此类插件使用$.fn来扩展，比如： $.fn.valitor = function(object) {...} 或 $.fn.extend({valitor: function(object) {...})) 其实查看jquery的源码，可以看到 $.fn = $.prototype 所以这样做就相当于添加方法到jquery的原型对象上，所有对象都可使用这些方法下面是一个简单的例子，给元素添加颜色 ;(function($) { $.fn.color = function(value) { return this.css(&quot;color&quot;,value); } $.fn.extend({ back: function(value) { return this.css(&quot;background&quot;,value); }, border: function(value) { return this.css(&quot;border&quot;,value); } }); })(jQuery); 使用方式： &lt;div class=&quot;tagcontain&quot;&gt; &lt;button&gt;改变颜色&lt;/button&gt; &lt;/div&gt; &lt;span class=&quot;blue&quot;&gt;速率类&lt;/span&gt; &lt;span class=&quot;red&quot;&gt;百分比&lt;/span&gt; &lt;span class=&quot;black&quot;&gt;峰值比&lt;/span&gt; $(function() { $(&quot;button&quot;).click(function() { $(&quot;span&quot;).back(&quot;#999&quot;).color(&quot;black&quot;) .border(&quot;solid 2px red&quot;); }); }); 效果见：color插件 注意： 在插件方法内部的this值得是应用此插件的jq对象，可以使用jq的一些方法，比如：this.each();最后要返回jq对象本身，为了后续的链式调用 此外，还可以暴露插件的一些属性和方法，供使用者自定义，比如： $.fn.default = {..}; $.fn.format = function() {..} 这里也有个例子，是模仿bootstrapTable插件渲染表格的使用方式： &lt;table id=&quot;table1&quot;&gt;&lt;/table&gt; $(function() { var columnDefs = [{checkbox: true}, {field: &apos;name&apos;,title: &apos;姓名&apos;}, {field: &apos;sex&apos;,title: &apos;性别&apos;}, {field: &apos;address&apos;,title: &apos;地址&apos;}]; var rowData = [{name:&apos;张山&apos;,sex:&apos;男&apos;,address:&apos;上海&apos;}, {name:&apos;李四&apos;,sex:&apos;男&apos;,address:&apos;苏州&apos;}, {name:&apos;王五&apos;,sex:&apos;女&apos;,address:&apos;嘉兴&apos;}, {name:&apos;张麻子&apos;,sex:&apos;男&apos;,address:&apos;宁波&apos;}, {name:&apos;赵六&apos;,sex:&apos;男&apos;,address:&apos;长沙&apos;}]; $.fn.bootTable.defaultOptions = {odd: &apos;odd&apos;, even: &apos;even&apos;,selected:&apos;checked&apos;}; $(&quot;#table1&quot;).bootTable({id: &apos;table1&apos;, caption: &apos;表格标题&apos;, column: columnDefs, data: rowData, option: {odd: &apos;odd2&apos;, even: &apos;even2&apos;}}); //获取已选记录 var selection = $(&quot;#table1&quot;).bootTable(&apos;getSelection&apos;); }); 效果见：bootTable插件 当然，也可以隐藏私有方法，只要是在插件书写时直接这样生命方法即可 function privateFunc() {...} 2) 全局方法的插件此类插件使用$.extend()来扩展，其实可以理解为jquery命名空间添加静态方法，比如 $.Fuc = function() {...}； $.extend({ add: function(x,y) { return x+y; } }); 使用 var num = $.add(3,5); 这个比较简单, 也可以给jquery添加自定义命名空间来减少命名冲突 $.myName = { Fuc: function() {...} }; $.myName.Fuc();","tags":[{"name":"Jquery","slug":"Jquery","permalink":"http://blueskyawen.com/tags/Jquery/"}]},{"title":"JSON-序列化和反序列化","date":"2018-07-28T08:35:13.000Z","path":"2018/07/28/JSON-xuliehua/","text":"JSON,由于其语法简单，表达清晰等特点，在数据载体方面扮演这重要的角色。尤其在是javascript中，由于语法上与js对象相似，可方便的进行相互的转换js提供了全局对象JSON进行数据结构的序列化和反序列化 对象序列化JSON.stringify()用于将对像转化成JSON格式的字符串 JSON.stringify(object,[filter],[space]) 其中第一个参数为必选项的待转换对象；第二个参数是过滤器，可以是简单的key值数组，也可以是过滤处理的函数；第三个参数为制定缩进和换行，可以是缩进字符数目(最多10个)，也可以是填充字符串 var book = { name: &apos;jack&apos;, age: 18, skills: [&apos;talk&apos;,&apos;eat&apos;] } JSON.stringify(book); --&gt; {name: &apos;jack&apos;,age: 18,skills: [&apos;talk&apos;,&apos;eat&apos;]} JSON.stringify(book,[&apos;name&apos;,&apos;age&apos;]); --&gt; {name: &apos;jack&apos;,age: 18} JSON.stringify(book,[&apos;name&apos;,&apos;age&apos;],4); --&gt; { name: &apos;jack&apos;, age: 18 } JSON.stringify(book,[&apos;name&apos;,&apos;age&apos;],&apos;*&apos;); --&gt; { ****name: &apos;jack&apos;, ****age: 18 } JSON.stringify(book,function(key,value) { if(key === &apos;skills&apos;) { return value.join(&amp;); } else { return value + &apos;_1&apos;; } }); --&gt; {name: &apos;jack_1&apos;,age: 18_1,skills: &apos;talk&amp;eat&apos;} 注意，当对象里存在toJSON()实现方法是，调用stringify将会优先调用toJSON来返回结果；否则结果同上 对象反序列化JSON.parse()用于将JSON格式的字符串转化成对像 JSON.parse(jsonstr,[filter]) 其中第一个参数为必选项的待转换json字符串；第二个参数是过滤器，可以是处理的函数，当对于的key的处理返回是undefined，则在转换后对象中删除此字段 var book = JSON.stringify({ name: &apos;jack&apos;, age: 18, skills: [&apos;talk&apos;,&apos;eat&apos;] }); JSON.parse(book); --&gt;得到一个和转换前结构一样的对象 JSON.parse(book，function(key,value) { if(key === &apos;skills&apos;) { return undefined; } else { return value + &apos;2&apos;; } }); --&gt; { name: &apos;jack2&apos;, age: 182, } 对象拷贝利用对象的序列和反序列化的特点，可以简单的实现js对象的深拷贝 var book = JSON.stringify({ name: &apos;jack&apos;, age: 18, skills: [&apos;talk&apos;,&apos;eat&apos;] }); var bookclone = JSON.parse(JSON.stringify(book));","tags":[{"name":"js","slug":"js","permalink":"http://blueskyawen.com/tags/js/"}]},{"title":"JQuery","date":"2018-07-27T14:23:04.000Z","path":"2018/07/27/jquery-daoru/","text":"JQurey是一个javascript库，用与简化开发人员的工作，感兴趣的同学可进一步去学习和使用 JQurey的特点简化js操作文档的复杂度，写的更少，做的更多，这得益于jqurey的几大特点： 集合操作，大部分的元素操作都是集合操作，比如：$(“p”)就是p元素的集合 链式写法，对元素的操作无限叠加，典型的函数式编程$(“p”).addClass(“active”)… Dom操作和事件的混合，降低了代码复杂度 优秀的浏览器兼容性，js在操作时遇到了太多浏览器兼容性问题，一个操作有时候需要写一堆的代码，而jq很好的封装了这种差异性，提供了统一的接口 典型的Jquery语法： $(&quot;p&quot;).removeClass(&quot;BBB&quot;).filter(&quot;.AAA&quot;) .addClass(&quot;active&quot;) .click(function() {...}); 关于$$符号是JQurey的标志，所有的jq操作都已$开始，就连开发者对JQurey对象的命名也是以$开头，比如： var $volume = $(&quot;p&quot;); $只是JQurey的代号，使用$的地方都可以使用JQurey代替，比如： $(&quot;p&quot;) 同 JQurey(&quot;p&quot;) $.ajax() 同 JQurey.ajax() JQurey对象和Dom对象JQurey是对js操作的封装库，JQurey对象自然也是Dom对象的封装，两种可以相互转换Dom对象 –&gt; JQ对象： var cr=document.getElementByid(&quot;aa&quot;); var $cr = $(cr); JQ对象 –&gt; Dom对象： var $cr = $(&quot;#aa&quot;); var cr = $cr[0] 或 $cr.get(0) JQ对象方法多样，可以完成大部分Dom操作，但是有时候也有判断不了的问题，比如:判断页面是否存在p元素，由于JQ总是会生成一个封装对象，故无法直接判断，这时候需要转化成dom对象 var $cr = $(&quot;#aa&quot;); if($cr[0]) { alert(&apos;页面没有这个元素&apos;); } JQurey的核心操作JQurey的核心操作，我觉得就是三个方面的内容： 元素获取 元素操作 1) 元素获取主要通过选择器和各种遍历方法来获取元素的个体或集合，比如： $(&quot;p&quot;) $(&quot;div &gt; span.classA&quot;) $(&quot;p&quot;).parent().find(&quot;span&quot;); $(&quot;div&quot;).children(); 具体的选择器和DOM方法和javascript类似注意 Jquery对于父子标签组合的合理性有过检查，对于不合理的子标签查找不出 比如：我们div放进了table里 &lt;table&gt; &lt;div&gt; &lt;input type=&quot;text&quot; /&gt; &lt;/div&gt; &lt;/table&gt; 使用$(”table div input“)无法匹配到input元素,但是$(”div input“)可以 2) 元素操作（1）事件、动画的添加 $(&quot;p&quot;).click(function() { alert(&quot;click it!!&quot;); }); $(&quot;p&quot;).hover(function() {...}, function() {...}); $(&quot;p&quot;).fadeIn(&apos;slow&apos;,function() {...}); $(&quot;p&quot;).animate({left: &apos;200px&apos;},&apos;slow&apos;); （2）Dom操作 节点操作,节点的get/del/add/update/copy $(&quot;div p&quot;) $(&quot;div p&quot;).remove(); var newSpan = $(&quot;&lt;span&gt;newSpan&lt;/span&gt;&quot;); $(&quot;div p&quot;).append(newSpan); $(&quot;div p&quot;).replacewith(newSpan); $(&quot;div p&quot;).clone(); 属性操作，get/del/update/add $(&quot;div p&quot;).attr(&quot;title&quot;); $(&quot;div p&quot;).attr(&quot;title&quot;,&quot;I am title!!&quot;); $(&quot;div p&quot;).removeAttr(&quot;title&quot;); 样式操作，get/add/del $(&quot;div p&quot;).css(&quot;width&quot;); $(&quot;div p&quot;).css(&quot;font-weight&quot;,&quot;bolder&quot;); $(&quot;div p&quot;).css({ &quot;font-weight&quot;: &quot;bolder&quot;, &quot;color&quot;: &quot;red&quot; }); $(&quot;div p&quot;).addClass(&quot;AAA&quot;); $(&quot;div p&quot;).removeClass(&quot;AAA&quot;); $(&quot;div p&quot;).toggleClass(&quot;AAA&quot;); $(&quot;div p&quot;).hasClass(&quot;AAA&quot;); 三元操作符很实用 if(isActive) { $(&quot;p&quot;).addClass(&quot;AAA&quot;); } else { $(&quot;p&quot;).removeClass(&quot;AAA&quot;); } //使用三元操作符书写 $(&quot;p&quot;)[isActive ? &quot;addClass&quot; : &quot;removeClass&quot;](&quot;AAA&quot;); 文本操作，get/update $(&quot;div p&quot;).text(); $(&quot;div p&quot;).text(&quot;javascript中的ajax书写复杂&quot;); $(&quot;div p&quot;).html(); $(&quot;div p&quot;).html(&quot;&lt;span&gt;newSpan&lt;/span&gt;&quot;); $(&quot;div input&quot;).val(); $(&quot;div input#name&quot;).val(&quot;jack&quot;); 标签包裹，add $(&quot;p span&quot;).wrap(&quot;&lt;div&gt;&lt;/div&gt;&quot;); Ajaxjavascript中的ajax书写复杂，而且在不同浏览器之间有差异，开发者要详细考虑兼容各个浏览器的写法在JQuery中，封装了这种差异，提供了统一的ajax方法，简单易用 $().load()对象方法，load方法可根据url直接加载页面并添加到指定元素中，也可加载目标页面的部分元素 $(selector).load(url,[data],[callback]) 其中url为加载地址，data为可选入参数据，callback为可选加载完成的回调函数 $(&quot;#target&quot;).load(url); $(&quot;#target&quot;).load(&quot;url selector&quot;); $(&quot;#target&quot;).load(url，{name: &apos;jack&apos;}, function(reponseText,textStatus,XMLHttpRequest) { ... }); 使用load方法带与不带data，将对应调用get和post方法 $.get()使用get方法可进行异步数据请求 $.get(url,[data],[callback],[type]) 其中type为请求的返回数据的规定格式，有：xml,html,script,json,text等，不填默认为xml $(&quot;button.send&quot;).click(function() { $.get(url,{name: &apos;jack&apos;},function(data,textStatus) { ... }); }); //data响应数据，textStatus请求状态 $(&quot;button.send&quot;).click(function() { $.get(url,{name: &apos;jack&apos;},function(data,textStatus) { ... },&quot;json&quot;); }); $.post()使用post方法可向服务器发送数据 $.post(url,[data],[callback]) 使用post也能获取数据，且隐秘性更强，但一般用于数据写操作 $(&quot;button.send&quot;).click(function() { $.post(url,{name: &apos;jack&apos;},function(data,textStatus) { ... }); }); $.getScript()getScript方法用于动态加载js脚本，并且加载成功立即执行 $.getScript(&quot;text.js&quot;); $.getJSON()getJSON方法用于动态JSON数据或文档，并且加载成功立通过回调函数处理 $.getJSON(&quot;text.json&quot;,function(data) { .... }); $.ajax()ajax()方法是jquery-ajax的核心方法，有很多的参数配置，可以设置错误处理，超时处理等，功能强大，前面几种方法都是基于此方法来实现的 $.ajax({ type: &quot;GET&quot;, url: &quot;temp.json&quot;， dataType: &quot;json&quot;, success: function(data) { .... } }); 这是ajax()的一般用法，具体了解可参考jquery的官方文档 本文之作简单的导入介绍，了解更多可在网上资源学习，当然还需要一定的练习附：使用jquery改造过的一些组件，之前有js书写jquery-组件改造","tags":[{"name":"Jqury","slug":"Jqury","permalink":"http://blueskyawen.com/tags/Jqury/"}]},{"title":"JavaScript表单校验Api","date":"2018-06-16T12:00:23.000Z","path":"2018/06/16/JavaScript-form-Api/","text":"JavaScript表单元素提供了一些内置的验证方法和属性，来对用户输入进行校验和错误显示，比如 checkValidity()，input 元素中的数据是合法的返回 true，否则返回 false 设置 input 元素的 validationMessage属性，用于自定义错误提示信息的方法。使用 setCustomValidity 设置了自定义提示后，validity.customError 就会变成true，则 checkValidity 总是会返回false 例子： &lt;input id=&quot;id1&quot; type=&quot;number&quot; min=&quot;100&quot; max=&quot;300&quot; required&gt; &lt;button onclick=&quot;myFunction()&quot;&gt;验证&lt;/button&gt; &lt;script&gt; function myFunction() { var inpObj = document.getElementById(&quot;id1&quot;); if (inpObj.checkValidity() == false) { document.getElementById(&quot;demo&quot;).innerHTML = inpObj.validationMessage; } } &lt;/script&gt; 验证 DOM 属性validity布尔属性值，返回 input 输入值是否合法input元素的 validity属性包含一系列关于数据属性 customError 设置为 true, 如果设置了自定义的 validity 信息。 patternMismatch 设置为 true, 如果元素的值不匹配它的模式属性。 rangeOverflow 设置为 true, 如果元素的值大于设置的最大值。 rangeUnderflow 设置为 true, 如果元素的值小于它的最小值。 stepMismatch 设置为 true, 如果元素的值不是按照规定的 step 属性设置。 tooLong 设置为 true, 如果元素的值超过了 maxLength 属性设置的长度。 typeMismatch 设置为 true, 如果元素的值不是预期相匹配的类型。 valueMissing 设置为 true，如果元素 (required 属性) 没有值。 valid 设置为 true，如果元素的值是合法的。 例子： &lt;input id=&quot;id1&quot; type=&quot;number&quot; max=&quot;100&quot;&gt; &lt;button onclick=&quot;myFunction()&quot;&gt;验证&lt;/button&gt; &lt;script&gt; function myFunction() { var txt = &quot;&quot;; if (document.getElementById(&quot;id1&quot;).validity.rangeOverflow) { txt = &quot;输入的值太大了&quot;; } document.getElementById(&quot;demo&quot;).innerHTML = txt; } &lt;/script&gt; validationMessage浏览器错误提示信息使用setCustomValidity（error : string）来设置validationMessage，并可手动取消他们 setCustomValidity(&apos;&apos;)； setCustomValidity(null) setCustomValidity(undefined) willValidate表示input 是否需要验证比如,如果表单元素设置了required特性或pattern特性，则willValidate属性的值为true","tags":[{"name":"js","slug":"js","permalink":"http://blueskyawen.com/tags/js/"}]},{"title":"HTMLCollection 与 NodeList 的区别","date":"2018-06-06T12:00:23.000Z","path":"2018/06/06/HTMLCollection-and-NodeList/","text":"使用js原生方法获取Dom的涉及到很多的都是集合，只是根据方法不同集合类型也有不同 HTMLCollection：HTML 元素的集合。比如：document.getElementsByTagName(“p”)获取的集合 NodeList 是一个文档节点的集合。比如：document.querySelectorAll(“p”);document.getElementsByClassName()；获取的集合 两者的异同相似点 都与数组对象有点类似，可以使用索引 (0，1，…) 来获取元素。 有 length 属性。 都是动态的，会根据html文档的更新而自动更新，比如：文档中增加了一个元素，list就多一个节点，length也会加1 不同点 HTMLCollection 元素可以通过 name，id 或索引来获取；而NodeList 只能通过索引来获取。 只有 NodeList 对象有包含属性节点和文本节点。 注意:节点列表看起来像一个数组，却不是一个数组！节点列表无法使用数组的方法： valueOf(), pop(), push(), 或 join() 。","tags":[{"name":"js","slug":"js","permalink":"http://blueskyawen.com/tags/js/"}]},{"title":"Javascipt-闭包/作用域和this","date":"2018-05-06T12:00:23.000Z","path":"2018/05/06/javascipt-bibao-and-this/","text":"在javascript中，有一些特有且容易出错的特性，包括闭包，作用域，和this,这里将个人理解记录一波 闭包当函数在执行时，会自动创建自身的执行环境，包括：作用域链和活动对象，然后执行时每遇到一个子函数就会形成新的执行环境，并推进执行环境栈里…，于是形成了执行环境链 作用域链，函数所能访问的作用范围，包含执行环境所能访问的所有活动对象，从外层环境到当前环境，在访问变量时将从当前执行环境的活动对象开始往外搜索变量 活动对象，保存当前执行环境的变量和方法 创建闭包的常用方法是在一个函数创建子函数，子函数可访问外层函数的变量，形成闭包 function ageAdd(defalutAge) { var age = defalutAge; return function() { if(age &lt; 10) { age += 5; return age; } else if(age &lt; 20) { age += 2; return ++age; } else { return defalutAge++; } } } var funAdd = ageAdd(4) funAdd(); // 9 funAdd(); // 14 funAdd(); // 16 funAdd(); // 18 funAdd(); // 20 funAdd(); // 4 当外层函数执行完以后，其执行环境和作用域链将会销毁，但是由于它的活动对象被子函数引用，故不会被销毁直到子函数执行完毕，于是形成了闭包常见的普通函数对全局变量的引用也算是一种特殊的闭包js没有块作用域，只有全局作用域和函数级作用域，但是，利用闭包可模拟块作用域，如下： (function() { 块作用域... })() 例子 var Age = (function() { var age = 10; return ++age; })(); alert(&apos;age is : &apos; + Age); // age is : 11 alert(&apos;age is : &apos; + age); // 出错 作用域在传统的面向对象里，对象属性有公开/受保护/私有之分，但是在js中没有这些限制，js是动态脚本语言，对象额所以属性都是公开的，换句话说，在对象定义以外，可以随意访问对象属性和方法 function Animal(type,name) { this.type = type; this.name = name; } Animal.prototype.display = function() { alert(&quot;I am a &quot; + this.type + &quot;,my name is &quot; + this.name); }; var dog = new Dog(&apos;black&apos;); //直接访问 dog.display(); alert(dog.name); 设计所致，没有办法，但是在设计中为了区分去私有还是共有属性，开发者之间形成了一个约定，对于私有属性的命名，两边加下划线或下划线开头，比如这样 function Animal(type,name) { this._type_ = type; this._name = name; } 写法不能改变属性的特征，只是起到提示效果 当然可以使用闭包实对象的私有变量效果，但是没有实际意义 this指针在javaScript中，在创建函数或对象(其实也是函数)时，会自动生成两个参数：arguments和this指针，由于this指针总是指向调用者，即函数执行时的“上下文”，所以this是动态的，需要具体分析 1) 作为普通函数调用function test() { alert(this); } test(); // Window 由于所有全局函数都属于window对象，所以上面的调用其实是: window.test(); // 调用者是window 同理如下 (function test() { alert(this); })(); // Window 2) 作为对象方法调用当函数作为对象方法定义时，在对象实例化时会自动创建作用域并把this指针指向该对象 var animal = { name: &apos;wangcai&apos;, display: function() { alert(this.name); } }; animal.display(); // wangcai 即使先创建的对象，后添加给对象或原型的方法也一样会绑定this给对象，比如： function test() { alert(this.name); } var animal= { name: &apos;wangcai&apos; }; animal.display = test; animal.display(); // wangcai 对于构造函数方式创建的对象来说，在实例化对象的时候在除了携带入参数组初始化内部属性以外，还将绑定this指针，即使后面再添加方法也一样 function Animal(name,age) { this.name = name; this.age = age; this.getName = function() { alert(this.name); } } var jenny = new Person(&apos;wangwang&apos;,24); Person.prototype.getAge = function() { alert(this.age); }; jenny.getName(); // wangwang jenny.getAge(); // 24 对于多重对象来说，this将匹配直接包含本方法的对象，比如： function Animal(name,age) { this.name = name; this.age = age; this.display = function() { alert(this.name); } this.dog = { name: &apos;汪汪&apos;, display: function() { alert(this.name); } } } var ani = new Animal(&apos;wangcai&apos;,24); ani.display(); // wangcai ani.dog.display(); // 汪汪 但是有对象的方法里再调用外部函数时又有所不同， function FF() { alert(this); } function Animal(name,age) { this.name = name; this.age = age; this.display = function() { alert(this.name); FF(); } } var ani = new Animal(&apos;wangcai&apos;,24); ani.display(); // wangcai // Window 由于FF()是全局函数，执行的时候其实在使用的全局对象，即使是在对象方法调用的同理，在对象方法定义并执行内部函数意一样，比如： function Animal(name,age) { this.name = name; this.age = age; this.display = function() { alert(this.name); (function() { alert(this); })(); } } var ani = new Animal(&apos;wangcai&apos;,24); ani.display(); // wangcai // Window 和调用全局函数一样，这里实际关联的是全局对象上下文，但是这个普遍认为是脚本设计问题，可以通过保存this规避 function Animal(name,age) { this.name = name; this.age = age; this.display = function() { alert(this.name); var that = this; //临时保存 (function() { alert(that.name); //使用保存的this })() } } var ani = new Animal(&apos;wangcai&apos;,24); ani.display(); // wangcai // wangcai 然而当把上面的对象方法赋值给全局变量来执行，又是完全不一样的结果： function Animal(name,age) { this.name = name; this.age = age; this.display = function() { alert(this); var that = this; //临时保存 (function() { alert(that); //使用保存的this })() } } var ani = new Animal(&apos;wangcai&apos;,24); var dump = ani.display; dump(); // Window // Window 这里其实就验证了一句话，this关联的调用者的上下文，虽然display方法是对象内部方法，但是方法是对象，对象名仅仅只是个指针，这里只是让全局变量指向函数代码而已，最终调用的是全局对象，实际上和下面没有任何区分 var dump = function() { alert(this); var that = this; //临时保存 (function() { alert(that); //使用保存的this })() }; 3) 对象/函数作为返回值的场景当把对象或者函数作为函数返回时，有一些有趣的事情 function Animal(name) { this.name = name; return {}; } var ani = new Animal(&apos;汪汪&apos;); alert(ani.name); // undefined function Animal(name) { this.name = name; return function() {}; } var ani = new Animal(&apos;汪汪&apos;); alert(ani.name); // undefined function Animal(name) { this.name = name; return 12; } var ani = new Animal(&apos;汪汪&apos;); alert(ani.name); // 汪汪 function Animal(name) { this.name = name; return null; // 或undefined; } var ani = new Animal(&apos;汪汪&apos;); alert(ani.name); // 汪汪 可以看到，当函数返回空对象或空函数时，this指针发生了变化，指向了返回的对象/函数;但是当返回是变量，常量，甚至是null/undefined时，this无法进行指向切换，故还是指向的原来的对象，即new对象时创建的对象 4) call,apply改变this指向我们知道函数有两个特殊的方法：call(this,..),apply(this,[..]),函数恶意通过它们来执行这两个方法的第一个参数都是this,即方法内部变量的指向，可以通过她们来人为改变函数执行的this指向以全局函数为里例 function test() { alert(this.name); } test(); // undefined 使用call改变 var ani = { name: &apos;wangwang&apos;, age: 24, display: function() {alert(this.name);} } test.call(ani); // wangwang 在严格版中的默认的this不再是window，而是undefined","tags":[{"name":"js","slug":"js","permalink":"http://blueskyawen.com/tags/js/"}]},{"title":"Javascript-面向对象","date":"2018-05-05T11:30:58.000Z","path":"2018/05/05/ECMAScript-mianxiangduixiang/","text":"javascript是一门面向对象的脚本语言，但又于传统的面向对象语言不同，它没有类的概念 然而，在js中，对象被声明为一种无序属性的集合，属性值可以是普通数据，子对象，和方法对象，于是通过一些技术手段，能够在js中实现面向对象的编程特性 1 对象在ECMAScript里，对象的概念在我理解来说，可以类似于传统面向对象编程语言的“类”，而实例化出的多个实体叫对象实例构建对象的方法很多，介绍几种常用的方法以及使用场景 1) 原始方式通过原始对象Object直接构造,比较粗暴,实际上得到的是一个对象实例 var animal = new Object(); animal.type = &quot;dog&quot;; animal.name = &quot;wangcai&quot;; animal.display = function() { alert(&quot;I am a &quot; + this.type + &quot;,my name is &quot; + this.name); }; animal.display(); //I am a dog，my name is wangcai 2) 字面量对象同上，实际上得到的是一个对象实例，可用于简单的临时对象使用或放回值等 var animal = { type: &quot;dog&quot;, name: &quot;wangcai&quot;, display: function() { alert(&quot;I am a &quot; + this.type + &quot;,my name is &quot; + this.name); } }; animal.display(); //I am a dog，my name is wangcai 3) 工厂方法简单工厂，封装对象构造过程 function getAnimal(type,name) { var animal = new Object() animal.type = &quot;dog&quot;; animal.name = &quot;wangcai&quot;; animal.display = function() { alert(&quot;I am a &quot; + this.type + &quot;,my name is &quot; + this.name); }; return animal; } var dog = getAnimal(&quot;dog&quot;,&quot;wangcai&quot;); dog.display(); //I am a dog，my name is wangcai 4) 构造函数方法在js中由于函数本身其实是对象，对象是属性集合，故可以使用函数作为“构造函数”来模拟对象创建 function Animal(type,name) { this.type = type; this.name = name; this.display = function() { alert(&quot;I am a &quot; + this.type + &quot;,my name is &quot; + this.name); }; } var dog = new Animal(&apos;dog&apos;,&apos;wangcai&apos;); dog.display(); //I am a dog，my name is wangcai 这种方式特别简单，使用起来也比较像传统的面向对象类的用法，但缺点就是每个对象实例都会创建各自的方法对象，比较消耗内存，这是和类不一样的，我们知道类的函数是保存在堆上的，又实例共享 5) 原型方法为了解决构造函数的内存问题，引入原型方式在js中，每创建一个函数，会自动创建一个prototype属性指针，指向同时引入的函数的原型对象，这个原型对象保存在堆中，存储公共的属性和方法当使用这个函数创建实例的时候会复制对象的prototype属性，所以每个对象实例都指向同一个原型对象 function Animal() {} Animal.prototype.type = &apos;dog&apos;; Animal.prototype.eysNum = 2; Animal.prototype.name = &apos;wangcai&apos;; Animal.prototype.display = function() { alert(&quot;I am a &quot; + this.type + &quot;,my name is &quot; + this.name); }; var animal1 = new Animal(); var animal2 = new Animal(); animal1.display(); animal2.display(); //I am a dog，my name is wangcai //I am a dog，my name is wangcai 可以看到对象属性被实例共用，可以使用方法判断是否是某实例的原型或得到实例原型 Animal1.prototype.isPrototypeOf(animal1); // true Object.getPrototypeOf(Animal1); // Animal1.prototype js使用原型链搜索需要的属性或者方法，搜索顺序：实例 –&gt; 原型对象在实例中添加或重写原型的属性，可覆盖原型的同名变量，同上 animal1.color = &apos;black&apos;; animal1.name = &apos;wangwang&apos;; console.log(animal1.color); // black console.log(animal1.name); // wangwang delete animal1.name; console.log(animal1.name); // wangcai var animal3 = new Animal(); console.log(animal3.color); // undefined console.log(animal3.name); // wangcai key in object和for-in可以判断和遍历对象实例的属性，不论属性在存在于实例还是原型中 obj.hasOwnProperty(key)可检测属性是否在对象实例中 obj.propertyIsEnumerable()判断属性是否可提高for-in遍历 Object.keys()或者可遍历属性名 原型方式的缺点很明显，既然属性是实例共享的，当某一实例改变了属性值会立刻体现到所有实例上，尤其是对引用型变量的改变，这往往是不被希望的 6) 构造函数-原型混合结合上面两个方式的优点，使用构造函数保存多变属性，使用原型保存共享属性/方法，混合方式也是使用最多的 function Animal(type,name) { this.type = type; this.name = name; this.display = function() { alert(&quot;I am a &quot; + this.type + &quot;,my name is &quot; + this.name); }; } Animal.prototype = { constructor: Animal, eyeNum: 2, dump: function() { console.log(&apos;I am &apos;+ this.name + &apos;, i have &apos; + this.eysNum + &apos;eyes.&apos;); } }; var dog = new Animal(&apos;dog&apos;,&apos;wangcai&apos;); dog.display(); dog.dump(); // I am a dog，my name is wangcai // I am wangcai , i have 2 eyes. var cat = new Animal(&apos;cat&apos;,&apos;jiafei&apos;); cat.display(); cat.dump(); // I am a cat，my name is jiafei // I am jiafei , i have 2 eyes. 7) 工厂-构造函数混合使用工厂方式，和装饰器模式来构造 function Animal(type,name) { var animal = new Object() animal.type = &quot;dog&quot;; animal.name = &quot;wangcai&quot;; animal.display = function() { alert(&quot;I am a &quot; + this.type + &quot;,my name is &quot; + this.name); }; return animal; } var dog = new Animal(&apos;dog&apos;,&apos;wangcai&apos;); 2 继承在js中没有真正意义上的继承，主要依靠原型链的替换来实现“继承”的特性，再加上对象组合增强等设计方法，来优化实现 1) 原型链替换这种方式其实很简单，想想之前说的原型链，对象和对象实例都通过prototype指针指向堆上的原型对象，所以通过指针实现原型链搜索来访问原型的属性如果把prototype指针替换成“父对象”的实例，这个子对象实例便可以通过自身的prototype访问“父对象实例”的属性，同时通过“父对象实例”的prototype访问“父对象”的原型属性，间接实现继承可以通过不断替换prototype属性多级继承 function Animal(type,name) { this.type = type; this.name = name; } Animal.prototype.display = function() { alert(&quot;I am a &quot; + this.type + &quot;,my name is &quot; + this.name); }; function Dog(color) { this.color = color; this.legNum = 4; } Dog.prototype = new Animal(&apos;dog&apos;,&apos;wangcai&apos;); var dog = new Dog(&apos;black&apos;); dog.display(); // I am a dog，my name is wangcai 可以重写父对象的属性或添加新的属性，但记住要在prototype替换以后 Dog.prototype.display = function() { console.log(&apos;HAHAHA&apos;); } Dog.prototype.dump = function() { console.log(&apos;my name is&apos;+this.name+&apos;,my color is &apos;+this.color); } var dog = new Dog(&apos;black&apos;); dog.display(); // I am a dog，my name is wangcai dog.dump(); // my name is wangcai,my color is black 当然父对象的方法也可使用子对的属性，比如 Animal.prototype.display = function() { alert(&quot;I am a &quot; + this.type + &quot;,my color is &quot; + this.color); }; 在调用时会根据原型链来查找属性变量，先子对象 –&gt; 父对象 –&gt; …,当然这不是好的设计方式，在此只是为了说明而已与原型方式的对象方式一样，有着原型属性共享的问题，当其他继承者修改了“父对象”的属性时，将会反映在所有子类，即使设计时不是这样的 2) 仿冒子对象利用函数的call()或apply()方法，在子对象的构造函数中直接调用执行“父对象”函数，并传入子对象的指针，间接使子对象继承了父对象的属性，且实例之间相互独立，类似于“组合模式” function Animal(type,name) { this.type = type; this.name = name; this.display = function() { alert(&quot;I am a &quot; + this.type + &quot;,my name is &quot; + this.name); }; } function Dog(type,name,color) { Animal.call(this,type,name); this.color = color; this.legNum = 4; } Dog.prototype.dump = function() { alert(&quot;I am &quot; + this.name + &quot;,color is &quot; + this.color); } var dog = new Dog(&apos;dog&apos;,&apos;wangcai&apos;,&apos;black&apos;); dog.display(); // I am a dog，my name is wangcai dog.dump(); // I am wangcai,color is black 这种继承方式实际上是在子对像中实例化父对象的属性，上例就相当于直接在子对象添加父对象的属性，只不过是通过调用函数来实例化而已，与下面类似： function Dog(type,name,color) { //Animal this.type = type; this.name = name; this.display = function() { alert(&quot;I am a &quot; + this.type + &quot;,my name is &quot; + this.name); }; //Animal this.color = color; this.legNum = 4; } Dog.prototype.dump = function() { alert(&quot;I am &quot; + this.name + &quot;,color is &quot; + this.color); } 可以看到，这种方式实际上是在子对像内部实例化“父类”的一个副本，增加内存负担，没有什么共享可言 3) 原型链-仿冒混合和对象构建类似，也可以通过混合使用原型链和仿冒对象来获取各自的优点 function Animal(type,name) { this.type = type; this.name = name; } Animal.prototype.display = function() { alert(&quot;I am a &quot; + this.type + &quot;,my name is &quot; + this.name); }; function Dog(type,name,color) { Animal.call(this,type,name); this.color = color; this.legNum = 4; } Dog.prototype = new Animal(); Dog.prototype.dump = function() { alert(&quot;I am &quot; + this.name + &quot;,color is &quot; + this.color); } var dog = new Dog(&apos;dog&apos;,&apos;KA&apos;,&apos;black&apos;); dog.display(); //I am a dog,my name is KA dog.dump(); //I am KA,color is black 4) 原型式这个其实就是将原型链的实现进行“工厂化”，传入父对象，隐藏继承的实现 function Animal(type,name) { this.type = type; this.name = name; } Animal.prototype.display = function() { alert(&quot;I am a &quot; + this.type + &quot;,my name is &quot; + this.name); }; function SubAnimal(super_o,color) { function sub(color) { this.color = color; }; sub.prototype = super_o; sub.prototype.dump = function() { alert(this.name + &apos;@&apos; + this.color); }; return new sub(color); } var dog = SubAnimal(new Animal(&apos;dog&apos;,&apos;wangwang&apos;),&apos;BLUE&apos;); dog.display(); // I am a dog，my name is wangwang dog.dump(); // wangwang@BLUE ECMAScript5引入了Object.create()方法进行原型式继承，如下 function Animal(type,name) { this.type = type; this.name = name; } Animal.prototype.display = function() { alert(&quot;I am a &quot; + this.type + &quot;,my name is &quot; + this.name); }; var dog = Object.create(new Animal(&apos;dog&apos;,&apos;wangwan22g&apos;)); dog.display(); 上例中传入父对象来构建子对象dog,当只有着一个参数时其实没啥用，主要是第二个参数来为子对象添加属性，上面的例子还可以这样写： function Animal(type,name) { this.type = type; this.name = name; } Animal.prototype.display = function() { alert(&quot;I am a &quot; + this.type + &quot;,my name is &quot; + this.name); }; var dog = Object.create(new Animal(&apos;dog&apos;,&apos;wangwang&apos;), { color: {value: &apos;BLUE&apos;}, dump: { value: function() { alert(this.name + &apos;@&apos; + this.color); } } }); dog.display(); dog.dump(); // I am a dog，my name is wangwang // wangwang@BLUE 5) 寄生式这种方式我的理解其实就是在原型式基础上进一步进行了工厂包装 function Animal(type,name) { this.type = type; this.name = name; } Animal.prototype.display = function() { alert(&quot;I am a &quot; + this.type + &quot;,my name is &quot; + this.name); }; function GetAnimal(super_o,color) { var sub = Object.create(super_o); sub.color = color; sub.dump = function() { alert(this.name + &apos;@&apos; + this.color); }; return sub; } var dog = GetAnimal(new Animal(&apos;dog&apos;,&apos;wangwang&apos;),&apos;BLUE&apos;); dog.display(); dog.dump(); 6) 寄生组合式寄生组合方式也是原型/寄生/构造函数等的组合应用，只是create子对象不是使用父对象实例，而是使用父对象的原型作为入参 function GetAnimal(super_o,color) { var sub = Object.create(super_o.prototype); sub.color = color; sub.dump = function() { alert(this.name + &apos;@&apos; + this.color); }; return sub; }","tags":[{"name":"js","slug":"js","permalink":"http://blueskyawen.com/tags/js/"}]},{"title":"Javascript-ECMAScript基础","date":"2018-04-24T16:08:35.000Z","path":"2018/04/25/Javascript-ECMAScript/","text":"ECMAscript是Javascript的一部分，主要规定脚本的语法相关集合，和其他编程语言一样具有类型,运算符等组成部分 1 数据类型js的变量是动态的，没有其他语言严格的变量类型规定，也就是变量可以被赋予任何类型的变量对象js有6大基本类型： String Boolean Number Null Undefined Function 可以使用typeOf来测试变量的基本类型，比如： typeOf &quot;I love&quot; --&gt; String typeOf 123 --&gt; Number typeOf () =&gt; {} --&gt; Function 运算符js也有其他语言的类似运算符，也有特殊的情况，比如： == 和 !=,比较时会进行自动类型转换 === 和 !==，全等比较，比较时不会转换类型，换言之就是值和类型一起参与比较 2 语句js的语句借鉴C语言特点，大部分语句规则和C类似，也有特殊的语言标签，比如：for-in，label标签等 3 函数js中的函数是对象，函数名是对象实例名，定义方式有好几个： function fun(x,y) { return x + y; } var fun = function(x,y) { return x + y; }; var fun = (x,y) =&gt; { return x + y; }; var fun = new Function(&apos;x&apos;,&apos;y&apos;,&apos;return x + y;&apos;); 既然函数是对象，则函数可以作为参数，变量进行赋值，甚至作为返回值，比如： var fun2 = function fun(x,y) { return (x,y) =&gt; { return 5 * x + y; }; } fun2(2,3); 或 （(x,y) =&gt; { return (x,y) =&gt; { return 5 * x + y; }; })(4,5); 或 （function() =&gt; { return 123; })(); 4 对象在js中，一切皆是对象，包括我们常用的数值，函数等，主要关系如下图： 1.所有的对象都继承于object，所以其他子对象都具有object的公共方法，包括：toString(),valueOf()等2.每种基本类型都对应一种引用型对象，比如： var a = &apos;hello world!&apos;; //string - String 在定义变量表达式是js引擎自动在内存创建基本类型对应的引用类型变量，所以变量自然拥有对象的方法，因为当调用方法时js引擎会自动查找对象是否有可用的方法，当变量使用完后该对象自动销毁3.基本类型对应的内置对象可以当作是通过“构造函数方式”利用Function/原型构建的，所以这些对象的原型constructor都是构造函数，比如: Array =&gt; function Array() { ... } Number =&gt; function Number() { ... } 4.基本类型和引用类型对象的检测方式不同，基本类型使用typeOf，引用类型使用instanceOf，比如： typeOf 123 =&gt; Number typeOf &apos;123&apos; =&gt; String typeOf [1,2,3] =&gt; object typeOf null =&gt; object typeOf undefined =&gt; Undefined typeOf ()=&gt; {} =&gt; Function [1,2,3] instanceOf Array =&gt; true /[0-9a-z]*/gi instanceOf RegExp =&gt; true 5.既然对象都是继承于object,则可以使用object直接构造内置对象，比如： var str = new Object(&quot;123&quot;) str instanceOf String = true var num = new Object(123) num instanceOf Number = true","tags":[{"name":"js","slug":"js","permalink":"http://blueskyawen.com/tags/js/"}]},{"title":"设计模式三","date":"2018-03-18T12:08:42.000Z","path":"2018/03/18/design-pattern-3/","text":"本节介绍几种结构型模式，看着比较相似，比较容易混淆，在此描述希望有所区分 装饰器模式装饰器模式主要是为了复用现有对象和类，在不修改现有类的前提下添加新功能。一般扩展类功能通常采用继承来实现，而装饰器可直接扩展新功能，防止继承造成的子类膨胀下面以X战警的例子来举个例子，X-man是变异人，是在普通人类的基础上拥有特殊能力的一类人： class Person { string name; Person(string name) {name = name;} ~Person() {name = &quot;&quot;;} void display() { cout &lt;&lt; &quot;===名字：&quot; &lt;&lt; name &lt;&lt; endl; } } class Man: public Person { Man(string name): Person(name) {} ~Man() {} } class Woman: public Person { Woman(string name): Person(name) {} ~Woman() {} } class Skill{ string m_skill; Skill(string skill) {m_skill = skill;} ~Skill() {m_skill = &quot;&quot;;} void display() { cout &lt;&lt; m_skill &lt;&lt; &quot; ; &quot;; } } class XMan { Person m_tPerson; Skill m_skillList = []; XMan(Person person) { m_tPerson = person; } ~XMan() {m_skillList = [];} void addSkill(Skill skill) { m_skillList.push(skill); } void display() { m_tPerson.display(); cout &lt;&lt; &quot;技能：&quot; &lt;&lt; endl; for(int index=0;index &lt; m_skillList.length;index++) { m_skillList[index].display(); } cout &lt;&lt; endl; } } //暴风女 class Storm: public XMan { Storm(Person person): XMan(person) {} ~Storm() {} } //镭射眼 class Cyclops: public XMan { Cyclops(Person person): XMan(person) {} ~Cyclops() {} } //金刚狼 class Wolverine: public XMan { Wolverine(Person person): XMan(person) {} ~Wolverine() {} } int main() { XMan storm = new Storm(new Woman(&quot;暴风女&quot;)); storm.addSkill(new Skill(&quot;操纵雷电&quot;)); storm.addSkill(new Skill(&quot;操纵暴风&quot;)); storm.addSkill(new Skill(&quot;操纵龙卷风&quot;)); storm.display(); XMan cyclops = new Storm(new Man(&quot;镭射眼&quot;)); cyclops.addSkill(new Skill(&quot;发射冲击波&quot;)); cyclops.display(); XMan wolverine = new Wolverine(new Man(&quot;金刚狼&quot;)); wolverine.addSkill(new Skill(&quot;延缓衰老&quot;)); wolverine.addSkill(new Skill(&quot;自愈&quot;)); wolverine.addSkill(new Skill(&quot;金刚爪&quot;)); wolverine.display(); } 输出：===名字：暴风女技能 ： 操纵雷电; 操纵暴风; 操纵龙卷风;===名字：镭射眼技能 ： 发射冲击波;===名字：金刚狼技能 ： 延缓衰老; 自愈; 金刚爪; 代理模式代理模式是新增代理类来对基础类进行访问控制的一种设计手段，由代理类提供调用接口，隐藏基础类的直接访问，此外还可以完成其他事物处理，包括： 隐藏基础类访问的复杂性 控制外部用户对基础类的直接访问，比如：进行访问算法优化 中间代理层可以对访问方式进行转化，比如：用户加解密 以访问数据库的代理处理为例： class DataBase { OracleDB m_db; DataBase() {} ~DataBase() {} object getData(string id) { return m_db.get(id); } void writeData(object data) { m_db.write(data); } void deleteData(string id) { m_db.delete(id); } } class UserService { string userName; string password; UserService(string name,string pwd) { userName = name; password = pwd; } ~UserService() {} boolean testUser(string name,string pwd) { return (userName == name) &amp;&amp; (password == pwd); } } class DataBaseService { DataBase m_database; UserService m_user = new UserService(&quot;aaa&quot;,&quot;123456&quot;); DataBaseService() {} ~DataBaseService() {} object get(string id) { m_database.getData(id); } void del(string id,string name,string pwd) { if(m_user.testUser(name,pwd)) { m_database.deleteData(id); } } void post(object data,string name,string pwd) { if(m_user.testUser(name,pwd)) { m_database.writeData(id); } } } int main() { DataBaseService dbService.; dbService.post(data,&quot;aaa&quot;,&quot;123456&quot;); dbService.get(&quot;aaa&quot;); dbService.del(&quot;aaa&quot;); } 外观模式代理模式","tags":[{"name":"设计","slug":"设计","permalink":"http://blueskyawen.com/tags/设计/"}]},{"title":"设计模式二","date":"2018-03-17T13:39:54.000Z","path":"2018/03/17/design-pattern-2/","text":"设计模式作为软件设计的经验总结，有三大原则需要遵守： 类对象职责单一，即在封装数据时尽量使类的功能单一，各类之间通过消息或者接口组合在一起 开放-闭合原则，即对扩展的开放，对修改的闭合 依赖倒转原则，对象抽象时应该依赖于抽象，而不应该依赖于细节，即面向接口编程 建造者模式建造者模式是将多个不同的对象组合成负责复杂对象的一种设计模式，而各个子对象可以独立抽象和发展而互不影响，通过建造者可以组合成不同的复杂对象，灵活多变。同时，可以构建多层的建造者对象来得到更加复杂的类对象建造者模式是设计中比较常用的设计方法，我们在程序设计中处理的事物总是零散，通过分析抽象可将零散的事物进行抽象分类，在使用中就可以直接使用下面通过吃火锅点单系统来说明模式的使用方式，火锅订单包括： 锅底，麻辣/清汤 蘸料碟，芝麻/花生 餐具，筷子/碗 荤菜，牛肉/鱼肉/鸡肉 素菜，白菜/土豆/玉米 盛菜盘子，陶瓷盘/玻璃盘 下面来进行构造： class ProductItem { int price = 0; ProductItem(int price) { price = price; } ProductItem() {} ~ProductItem() {price = 0;} virtual void display() = 0; int getPrice() { return price; } } //锅底 //麻辣锅底 class SpicyHotPotSoup: public ProductItem { SpicyHotPotSoup(int price): ProductItem(price) {} ~SpicyHotPotSoup() {} void display() { cout &lt;&lt; &quot;名称：麻辣锅底&quot; &lt;&lt; &quot; 价格：&quot; &lt;&lt; price &lt;&lt; &quot; &quot;; } } //清汤锅底 class LightHotPotSoup: public ProductItem { LightHotPotSoup(int price): ProductItem(price) {} ~LightHotPotSoup() {} void display() { cout &lt;&lt; &quot;名称：清汤锅底&quot; &lt;&lt; &quot; 价格：&quot; &lt;&lt; price &lt;&lt; &quot; &quot;; } } //蘸料 //芝麻蘸料 class SesameSauce: public ProductItem { SesameSauce(int price): ProductItem(price) {} ~SesameSauce() {} void display() { cout &lt;&lt; &quot;名称：芝麻蘸料&quot; &lt;&lt; &quot; 价格：&quot; &lt;&lt; price &lt;&lt; &quot; &quot;; } } //花生蘸料 class PeanutSauce: public ProductItem { PeanutSauce(int price): ProductItem(price) {} ~PeanutSauce() {} void display() { cout &lt;&lt; &quot;名称：花生蘸料&quot; &lt;&lt; &quot; 价格：&quot; &lt;&lt; price &lt;&lt; &quot; &quot;; } } //餐具 //碗 class Bowl: public ProductItem { Bowl() {} ~Bowl() {} void display() { cout &lt;&lt; &quot;名称：碗&quot; &lt;&lt; &quot; 价格：&quot; &lt;&lt; price &lt;&lt; &quot; &quot;; } } //筷子 class Chopsticks: public ProductItem { Chopsticks() {} ~Chopsticks() {} void display() { cout &lt;&lt; &quot;名称：筷子&quot; &lt;&lt; &quot; 价格：&quot; &lt;&lt; price &lt;&lt; &quot; &quot;; } } //盛菜盘子 class Plate { Plate() {} ~Plate() {} } //陶瓷盘 class CermicPlate: public Plate { CermicPlate() {} ~CermicPlate() {} } //玻璃盘 class GlassPlate: public Plate { GlassPlate() {} ~GlassPlate() {} } //荤菜 class Meat: public ProductItem { Plate m_plate; Meat(Plate plate,int price): ProductItem(price) { m_plate = new CermicPlate(); } ~Meat() {m_plate = null;} } //牛肉 class Beef: public Meat { Beef(int price): Meat(price) { } ~Beef() {} void display() { cout &lt;&lt; &quot;名称：牛肉&quot; &lt;&lt; &quot; 价格：&quot; &lt;&lt; price &lt;&lt; &quot; &quot;; } } //鱼肉 class Fish: public Meat { Fish(int price): Meat(price) {} ~Fish() {} void display() { cout &lt;&lt; &quot;名称：鱼肉&quot; &lt;&lt; &quot; 价格：&quot; &lt;&lt; price &lt;&lt; &quot; &quot;; } } //鸡肉 class Chicken: public Meat { Chicken(int price): Meat(price) {} ~Chicken() {} void display() { cout &lt;&lt; &quot;名称：鸡肉&quot; &lt;&lt; &quot; 价格：&quot; &lt;&lt; price &lt;&lt; &quot; &quot;; } } //素菜 class Vagetble: public ProductItem { Plate m_plate; Vagetble(int price): ProductItem(price) { m_plate = new GlassPlate(); } ~Vagetble() {m_plate = null;} } //白菜 class Cabbage: public Vagetble { Cabbage(int price): Vagetble(price) {} ~Cabbage() {} void display() { cout &lt;&lt; &quot;名称：白菜&quot; &lt;&lt; &quot; 价格：&quot; &lt;&lt; price &lt;&lt; &quot; &quot;; } } //土豆 class Potato: public Vagetble { Potato(int price): Vagetble(price) {} ~Potato() {} void display() { cout &lt;&lt; &quot;名称：土豆&quot; &lt;&lt; &quot; 价格：&quot; &lt;&lt; price &lt;&lt; &quot; &quot;; } } //玉米 class Maize: public Vagetble { Maize(int price): Vagetble(price) {} ~Maize() {} void display() { cout &lt;&lt; &quot;名称：玉米&quot; &lt;&lt; &quot; 价格：&quot; &lt;&lt; price &lt;&lt; &quot; &quot;; } } class Order { ProductItem *m_product; int num; Order(ProductItem *pitem,int num) { m_productList = pitem; num = num; } ~Order() { m_productList = null; num = 0; } int getOrderPrice() { return m_productList-&gt;getPrice() * num; } void display() { m_product-&gt;display(); cout &lt;&lt; &quot; 数量：&quot; &lt;&lt; num &lt;&lt; endl; } } class OrderMeal { Order orders[] = []; OrderMeal() {} ~OrderMeal() {} void addOrder(string type,int price,int num) { switch(type) { case &quot;SpicyHotPotSoup&quot;: { orders.push(new SpicyHotPotSoup(price),num); break; } case &quot;LightHotPotSoup&quot;: { orders.push(new LightHotPotSoup(price),num); break; } case &quot;SesameSauce&quot;: { orders.push(new SesameSauce(price),num); break; } case &quot;PeanutSauce&quot;: { orders.push(new PeanutSauce(price),num); break; } case &quot;Bowl&quot;: { orders.push(new Bowl(price),num); break; } case &quot;Chopsticks&quot;: { orders.push(new Chopsticks(price),num); break; } case &quot;Beef&quot;: { orders.push(new Beef(price),num); break; } case &quot;Fish&quot;: { orders.push(new Fish(price),num); break; } case &quot;Chicken&quot;: { orders.push(new Chicken(price),num); break; } case &quot;Cabbage&quot;: { orders.push(new Cabbage(price),num); break; } case &quot;Potato&quot;: { orders.push(new Potato(price),num); break; } case &quot;Maize&quot;: { orders.push(new Maize(price),num); break; } } } int getTotalBill() { int total = 0; for(int index = 0;index &lt; orders.length;index++) { total += orders[index].getOrderPrice(); } return total; } void dump() { for(int index = 0;index &lt; orders.length;index++) { total += orders[index].display(); } cout &lt;&lt; &quot; 总共：&quot; &lt;&lt; getTotalBill() &lt;&lt; endl; } } int main() { OrderMeal myMeal = new OrderMeal(); myMeal.addOrder(&quot;SpicyHotPotSoup&quot;,30,1); myMeal.addOrder(&quot;LightHotPotSoup&quot;,30,1); myMeal.addOrder(&quot;SesameSauce&quot;,5,1); myMeal.addOrder(&quot;PeanutSauce&quot;,5,1); myMeal.addOrder(&quot;Bowl&quot;,0,2); myMeal.addOrder(&quot;Chopsticks&quot;,0,2); myMeal.addOrder(&quot;Beef&quot;,20,4); myMeal.addOrder(&quot;Fish&quot;,35,1); myMeal.addOrder(&quot;Chicken&quot;,15,1); myMeal.addOrder(&quot;Cabbage&quot;,10,1); myMeal.addOrder(&quot;Potato&quot;,8,2); myMeal.addOrder(&quot;Maize&quot;,12,1); myMeal.dump(); } 输出：名称：麻辣锅底 价格：30 数量：1名称：清汤锅底 价格：30 数量：1名称：芝麻蘸料 价格：5 数量：1名称：花生蘸料 价格：5 数量：1名称：碗 价格：0 数量：2名称：筷子 价格：0 数量：2名称：牛肉 价格：20 数量：4名称：鱼肉 价格：35 数量：1名称：鸡肉 价格：30 数量：1名称：白菜 价格：10 数量：1名称：土豆 价格：8 数量：2名称：玉米 价格：12 数量：1总共：253 组合模式组合模式比较简单，主要是解决那些树形接口的系统或者事物，而又想在各个系统节点上有类似的属性和接口比如一个集团，有总公司，总公司下属有财务和人事部门,负责财务的结算和人员招聘;总公司下面有区分中心公司，中心公司下属又有各个城市的子公司，这些不同级别的子公司都需要财务和人事部门，这就涉及到节点的接口统一问题了，可以用到组合模式，例子： class Department { Department() {} ~Department() {} virtual void display() = 0; } class Finance: public Department { Finance() {} ~Finance() {} void display() { cout &lt;&lt; &quot;部门: 财务&quot; &lt;&lt; endl; } } class Personnel: public Department { Personnel() {} ~Personnel() {} void display() { cout &lt;&lt; &quot;部门: 人事&quot; &lt;&lt; endl; } } class Company { string name; Department * m_departments[] = []; Company *m_pcompanys[] = []; string qinzui = &quot;=&quot;; Company(string name) { name = name; m_departments.push(new Finance()); m_departments.push(new Personnel()); } ~Company() {} virtual void addCompany() = 0; virtual void removeCompany() = 0; virtual void display() = 0; void addQinzui(string qinzui) { qinzui = qinzui; } } class ConCompany: public Company { ConCompany(string name): Company(name) {} ~ConCompany() {} void addCompany(Company *pcomp) { pcomp.addQinzui(qinzui+&quot;===&quot;); m_pcompanys.push(pcomp); } void removeCompany(Company *pcomp) { m_pcompanys.remove(pcomp); } void dump() { cout &lt;&lt; qinzui &lt;&lt; name &lt;&lt; endl; if(m_departments.length != 0) { for(int index=0;index &lt; m_departments.length;index++) { cout &lt;&lt; qinzui; m_departments[index].display(); } } if(m_pcompanys.length != 0) { for(int index=0;index &lt; m_departments.length;index++) { m_pcompanys[index].dump(); } } } } int main() { ConCompany huadong = new ConCompany(&quot;华东分公司&quot;); huadong.addCompany(new ConCompany(&quot;上海分公司&quot;))； huadong.addCompany(new ConCompany(&quot;杭州分公司&quot;)); ConCompany huabei = new ConCompany(&quot;华北分公司&quot;); huabei.addCompany(new ConCompany(&quot;北京分公司&quot;)); huabei.addCompany(new ConCompany(&quot;天津分公司&quot;)); ConCompany zong = new ConCompany(&quot;总公司&quot;); zong.addCompany(huadong); zong.addCompany(huabei); zong.dump(); } 输出： =总公司 =部门: 财务 =部门: 人事 ====华东分公司 ====部门: 财务 ====部门: 人事 ========上海分公司 ========部门: 财务 ========部门: 人事 ========杭州分公司 ========部门: 财务 ========部门: 人事 ====华北分公司 ====部门: 财务 ====部门: 人事 ========北京分公司 ========部门: 财务 ========部门: 人事 ========天津分公司 ========部门: 财务 ========部门: 人事","tags":[{"name":"设计","slug":"设计","permalink":"http://blueskyawen.com/tags/设计/"}]},{"title":"设计模式一","date":"2018-03-09T14:59:29.000Z","path":"2018/03/09/design-pattern-1/","text":"设计模式是一种经验总结，是软件开发人员在长期的实践中对所遇问题的常用解决方案。设计模式的目的是让我们的软件设计方法化，开发的程序更具重用性，灵活性和可扩展性。设计模式是针对面向对象的设计方法总结，有一个需要遵从的“开放-闭合原则”：对扩展的开放，对修改的闭合，即功能扩展时易增加且不改动原有代码，功能变更时可以少修改代码，这个原则可以借助面向对象的抽象和继承来设计实现。设计模式有很多设计原则，我摘取了几个，认为只要符合下面几个原则，基本上是较好的设计： 单个类封装设计，功能职责单一 对对象或者行为接口进行隔离，减低耦合 针对接口编程，而非过程编程 依赖于抽象而非具体 优先对象组合而非继承，只在有意义的时候进行继承 以下例子均以C++实现 工厂模式工厂模式封装对象的创建，配合类的抽象继承，隐藏子对象的创建过程，提供统一的创建接口比如，宠物店的例子： class Pet { private: string name; public: Pet(string name) { name = name; } ~Pet() { name = &quot;&quot;; } void sayName() { cout &lt;&lt; &quot;My name is : &quot; &lt;&lt; name &lt;&lt; &quot; ! &quot;; } virtual void shut() = 0; } class Dog: public Pet { Dog(string name): Pet(name) {} ~Dog() {} void shut() { sayName(); cout &lt;&lt; &quot;旺旺～&quot; &lt;&lt; endl; } } class Cat: public Pet { Cat(string name): Pet(name) {} ~Cat() {} void shut() { sayName(); cout &lt;&lt; &quot;喵喵～&quot; &lt;&lt; endl; } } class PetStore { Pet * pInst; PetStore() { pInst = null; } ~PetStore() { pInst = null; } getOnePet(string type,string name) { switch(type) { case &quot;DOG&quot;: pInst = new Dog(name); break; case &quot;CAT&quot;: pInst = new Cat(name); break; default: break; } return pInst; } } int main() { PetStore petStore = new PetStore(); Pet * myPet; myPet = petStore.getOnePet(&quot;DOG&quot;,&quot;旺财&quot;); myPet-&gt;shut(); myPet = petStore.getOnePet(&quot;CAT&quot;,&quot;加菲&quot;); myPet-&gt;shut(); } 输出：My name is : 旺财 ; 旺旺～My name is : 加菲 ; 喵喵～ 抽象工厂模式抽象工厂是处理多集群的一种方式，将工厂抽象化，先创建工厂，再让具体的工厂创建具体的实例对象，比如： 宠物 - 小猫/小狗 - 宠物店 - 店铺 服装 - 衣服/裤子 - 服装店 - 店铺 如上，将工厂对象-店铺先作对象，创建具体的店铺后，由相应的店铺创建各自的对象，实现方式和工厂模式相似，这就不描述了 工厂方法模式工厂模式可以看到隐藏了对象的创建细节，提供了统一的接口，但是可以看到的是当功能扩展时需要修改对象工厂的内部实现，比如：想增加个小猪，除了新增小猪类外，还要修改store的创建逻辑，这就不符合“开放-闭合”原则，可以使用工厂方法将各个对象的工厂独立开来 class Pet { private: string name; public: Pet(string name) { name = name; } ~Pet() { name = &quot;&quot;; } void sayName() { cout &lt;&lt; &quot;My name is : &quot; &lt;&lt; name &lt;&lt; &quot; ! &quot;; } virtual void shut() = 0; } class Dog: public Pet { Dog(string name): Pet(name) {} ~Dog() {} void shut() { sayName(); cout &lt;&lt; &quot;旺旺～&quot; &lt;&lt; endl; } } class Cat: public Pet { Cat(string name): Pet(name) {} ~Cat() {} void shut() { sayName(); cout &lt;&lt; &quot;喵喵～&quot; &lt;&lt; endl; } } class Store { Pet * pInst; Store() { pInst = null; } ~Store() { pInst = null; } virtual Pet * getOnePet(string name) = 0; } class DogStore: public Store { DogStore() { } ~DogStore() {} Pet * getOnePet(string name) { pInst = new Dog(name); return pInst; } } class CatStore: public Store { CatStore() {} ~CatStore() {} Pet * getOnePet(string name) { pInst = new Cat(name); return pInst; } } int main() { Store *petStore = null; Pet * myPet; petStore = new DogStore(); myPet = petStore-&gt;getOnePet(&quot;旺财&quot;); myPet-&gt;shut(); petStore = new CatStore(); myPet = petStore-&gt;getOnePet(&quot;加菲&quot;); myPet-&gt;shut(); } 如上，每种宠物一个工厂，增加只要继承扩展就行。简单工厂模式就好比是大商城，啥都卖;而工厂方法模式就是专卖店，只卖一种类型的宠物。 两种模式各有优缺点，当种类不多时可以采用简单工厂，而当种类多而且各工厂内部复杂时可考虑工厂方法 策略模式工厂模式是对事物属性变化的封装，当对象的属性相对稳定，行为变化频繁的时候，就需要对行为进行封装适应。而策略模式正是针对这种问题的一个解决方法。比如，简易计算器，数字的四则运算，处理的属性不变，而计算方式却大不相同： class OPerate { private: int num1; int num2; int operResult; public: Operate(int n1,int n2) { num1 = n1; num2 = n2; operResult = 0; } ~Operate(int n1,int n2) { num1 = 0; num2 = 0; operResult = 0; } void displayResult() { cout &lt;&lt; &quot;The result is : &quot; &lt;&lt; operResult &lt;&lt; endl; } virtual void doOperation() = 0; } class OperateAdd: public OPerate { OperateAdd(int n1,int n2): OPerate(n1,n2) {} ~OperateAdd() {} void doOperation() { operResult = num1 + num2; } } class OperateMultiple: public OPerate { OperateMultiple(int n1,int n2): OPerate(n1,n2) {} ~OperateMultiple() {} void doOperation() { operResult = num1 * num2; } } class OperateContext { private: OPerate * pInst; public: OperateContext(OPerate * pInstz) { pInst = pInstz; } ~OperateContext() { pInst = null; } void getOperateResult() { pInst-&gt;doOperation(); } void dump() { pInst-&gt;displayResult(); } } int main() { OperateContext context; context = new OperateContext(new OperateAdd(3,5)); context.getOperateResult(); context.dump(); context = new OperateContext(new OperateMultiple(3,5)); context.getOperateResult(); context.dump(); } 输出：The result is : 8The result is : 15 策略-工厂组合模式策略模式最后的使用将对象的行为暴露出来不合适，结合工厂模式来隐藏内部过程，提供统一使用对象和接口，重构上面的部分代码： class OperateContext { private: OPerate * pInst = null; public: OperateContext(string type,int n1,int n2) { if(pInst == null) { pInst = createInst(type,n1,n2); } } ~OperateContext() { pInst = null; } OPerate * createInst(string type,int n1,int n2) { switch(type) { case &quot;ADD&quot;: return new OperateAdd(n1,n2); case &quot;MULTIPLE&quot;: return new OperateMultiple(n1,n2); default: return null; } } void getOperateResult() { if(pInst != null) { pInst-&gt;doOperation(); } } void dump() { if(pInst != null) { pInst-&gt;displayResult(); } } } int main() { OperateContext *pcontext = null; pcontext = (OperateContext *)new OperateContext(&quot;ADD&quot;,3,5); context-&gt;getOperateResult(); context-&gt;dump(); pcontext = (OperateContext *)new OperateContext(&quot;MULTIPLE&quot;,3,5); context-&gt;getOperateResult(); context-&gt;dump(); } 单例模式单例模式利用类的静态属性的特点使得一个类有且只能有一个实例，减少内存消耗比如： char g_auData[sizeof(Sington)]; Sington * Sington::pInst = null; class Sington { private: static Sington * pInst; public: static Sington * getInstance() { if(pInst != null) { return pInst; } else { pInst = (Sington * )g_auData; new (pInst) Sington(); return pInst; } void display() { cout &lt;&lt; &quot;I am sington!&quot; &lt;&lt; endl; } } } int main() { Sington * pContext = Sington::getInstance(); pContext-&gt;display(); } 输出：I am sington!","tags":[{"name":"设计","slug":"设计","permalink":"http://blueskyawen.com/tags/设计/"}]},{"title":"css3-媒体查询与响应式设计","date":"2018-01-24T15:40:30.000Z","path":"2018/01/24/css3-modia/","text":"说起响应式设计，从字面上看比较难以理解，其实简单来说就是网页的设计根据设备的不同，窗口大小的变化等动态适配页面的布局和样式，以免出现变形和错乱，体验过差 可以结合媒体查询，设备窗口和媒体查询一起进行页面的响应式设计 媒体查询媒体查询可以根据媒体类型和特性条件来改变元素的样式，从而使得页面能够在不同设备下可以良好的呈现媒体查询声明方式： @media ([and|not|only]? media_type? （[and]? (featrue1)) ...[and]? (featrueN))),... { CSS样式 } 这是使用正则表达式的规则表示的媒体查询的用法，可以以定义多个查询表达式，中间使用逗号相隔，只要一个表达式满足，其中的CSS样式便生效，每个“查询表达式”由类似的几部分组成 media_type这是支持的媒体类型或设备，比如： all，适用所有设备，默认值 print，打印媒介 screen，屏幕 speech，语言 修饰连接符and，not，only都是表达式的修饰符，可以修饰整个查询表达式，也可以修饰单个表达式，甚至链接多个表达式或特性来形成辅助的媒体查询（1）andand用户连接媒体类型和特性featrue,或者连接多个featrue，比如： @media screen and (min-width: 700px) { CSS... } //媒介是screen且宽度大于700px生效 @media screen and (min-width: 700px) and (max-width: 1000px) { CSS... } //媒介是screen，且700px&lt;= width &lt;= 1000px时生效 当不指定媒体类型时默认all,前面可以省略 @media (min-width: 700px) { CSS... } 效果同下 @media all and (min-width: 700px) { CSS... } （2）notnot用于对整个表达式进行逻辑去反，且使用not操作符必须指定设备类型，比如： @media not screen and (min-width:500px) { CSS } 指的对后面整个and表达式取反，就是说：当不是screen屏幕或者宽度大于500px，CSS都生效 not操作符仅能用于一个完整的媒体查询 说到这，得先说一下另一个特殊的操作-逗号操作符，用于将多个查询表达式连接在一起，只要其中一个表达式满足，即生效，看下面： @media screen and (min-width:500px)，print and (max-width:700px) { CSS } 这就宽泛很多了，CSS生效的条件可以是： screen 且 width&gt;=500px print 且 width&lt;=700px 好，下面把not加入进去，因为只能用于一个查询表达式，所以下面几种写法是一样的： @media not screen and (min-width:500px)，print and (max-width:700px) { CSS } @media (not screen and (min-width:500px))，print and (max-width:700px) { CSS } @media print and (max-width:700px),not screen and (min-width:500px) { CSS } （3）onlyonly操作符用于防止老的不支持媒体查询的浏览器不读取余下的媒体查询，同时一并忽略链接的样式表,比如： &lt;link rel=&quot;stylesheet&quot; media=&quot;only screen and (width:700px)&quot; href=&quot;example.css&quot; /&gt; featruefeatrue指的是除了媒体类型以外的限制条件，比如：height，width,常用的有： width,min-width,max-width height,min-height,max-height device-height,device-width 更多可参看菜鸟教程：modia 使用方式：(featrue: value),比如： @media screen and (min-width:500px) and (min-device-height:300px) { CSS } 媒体查询相关demo: 媒体查询-demo 方向：横屏/竖屏orientation：portrait | landscape portrait：指定输出设备中的页面可见区域高度大于或等于宽度 landscape： 除portrait值情况外，都是landscape 作为特性使用： @media screen and (orientation: landscape) { CSS } Viewportviewport是用户网页的可视区域比如，手机浏览器是把页面放在一个虚拟的”窗口”（viewport）中，通常这个虚拟的”窗口”（viewport）比屏幕宽，这样就不用把每个网页挤到很小的窗口中（这样会破坏没有针对手机浏览器优化的网页的布局），用户可以通过平移和缩放来看网页的不同部分下面是一个常用的针对移动网页优化过的页面的meta标签： &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, height=device-height, initial-scale=1.0,minimum-scale=0.5,maximum-scale:5.0, user-scalable:true&quot;&gt; 其中： width/heght：控制 viewport 的大小，可以指定的一个值，比如600;或者关键字，比如device-width initial-scale：初始缩放比例，也即是当页面第一次 load 的时候缩放比例 maximum-scale：允许用户缩放到的最大比例 minimum-scale：允许用户缩放到的最小比。 user-scalable：用户是否可以手动缩放，默认为true 珊格视图珊格其实是把视图根据比例分成等量宽度，根据设计时使用，事先 * { box-sizing: border-box; } 最常见的是将视区分为12份 .col-1 {width: 8.33%;} .col-2 {width: 16.66%;} .col-3 {width: 25%;} .col-4 {width: 33.33%;} .col-5 {width: 41.66%;} .col-6 {width: 50%;} .col-7 {width: 58.33%;} .col-8 {width: 66.66%;} .col-9 {width: 75%;} .col-10 {width: 83.33%;} .col-11 {width: 91.66%;} .col-12 {width: 100%;} [class*=&quot;col-&quot;] { float: left; padding: 15px; border: 1px solid red; } 使用： &lt;header class=&quot;col-12&quot;&gt;手机展现&lt;/header&gt; &lt;aside class=&quot;col-3&quot;&gt; &lt;ul&gt; &lt;li onclick=&quot;selectMenu(1)&quot;&gt;Oppo&lt;/li&gt; &lt;li onclick=&quot;selectMenu(2)&quot;&gt;Vivo&lt;/li&gt; &lt;li onclick=&quot;selectMenu(3)&quot;&gt;小米&lt;/li&gt; &lt;/ul&gt; &lt;/aside&gt; &lt;article id=&quot;oppo&quot; class=&quot;col-9&quot; style=&quot;display:block;&quot;&gt; OPPO 更多年轻人选择的拍照手机 &lt;/article&gt; &lt;footer class=&quot;col-12&quot;&gt; &lt;details&gt; &lt;summary&gt;Copyright 1999-2011.&lt;/summary&gt; &lt;p&gt;by Refsnes Data. All Rights Reserved.&lt;/p&gt; &lt;p&gt;datetime=&quot;2012-03-01&quot;.&lt;/p&gt; &lt;/details&gt; &lt;/footer&gt; 结合媒体查询，可以根据页面变化进行响应式设计，动态改变样式 @media only screen and (min-width: 800px) { .col-1 {width: 8.33%;} .col-2 {width: 16.66%;} .col-3 {width: 25%;} .col-4 {width: 33.33%;} .col-5 {width: 41.66%;} .col-6 {width: 50%;} .col-7 {width: 58.33%;} .col-8 {width: 66.66%;} .col-9 {width: 75%;} .col-10 {width: 83.33%;} .col-11 {width: 91.66%;} .col-12 {width: 100%;} [class*=&quot;col-&quot;] { float: left; border: 0px solid red; } } @media only screen and (max-width: 799px) { [class*=&quot;col-&quot;] { float: left; border: 0px solid red; width:100%; } article{ background:#ccff33; padding:16px; height:auto; } } 相应效果见demo: 珊格","tags":[{"name":"CSS","slug":"CSS","permalink":"http://blueskyawen.com/tags/CSS/"}]},{"title":"css3-Flex布局","date":"2018-01-21T05:40:48.000Z","path":"2018/01/21/css3-flex/","text":"Flex是一种弹性布局框，和上一篇讲的box特别像，可以说是Box的增强版，能够实现box支持的所有，也增加和简化了部分属性功能 Flex的声明如下： display: -webkit-flex; /* Safari */ display: flex; 设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效 flex-directionflex-direction规定子元素的排列方向和顺序，同时也设定了主轴和次轴的方向，默认是水平方向相当于box-orient + box-direction 主轴 次轴 如图所示，蓝色为主轴方向，紫色的为次轴方向，这是默认的排列方式flex-direction有四种取值： row，默认水平方向从左向右排列，水平为主轴，垂直为次轴，主轴延伸方向：左–&gt;右 row-reverse，水平方向反向排列，水平为主轴，垂直为次轴，主轴延伸方向：右–&gt;左 column，垂直方向从上向下排列，垂直方向为主轴，水平方向为次轴，主轴延伸方向：上–&gt;下 column-reverse，垂直方向反向排列，垂直方向为主轴，水平方向为次轴，主轴延伸方向：下–&gt;上 效果见flex-demo-01 flex-wrapflex-wrap规定子元素在主轴上如果排不下的时候，如何换行，默认都排在一条轴线上类似于box-lines，只不过box不被支持flex-direction有四种取值： nowrap， 默认， 不换行 wrap，换行，第一行在上方 wrap-reverse，换行，第一行在下方 效果见flex-demo-01 flex-flowflex-flow是flex-direction和flex-wrap的简写形式，默认值为：row nowrap flex-flow: flex-direction flex-wrap justify-contentjustify-content规定子元素在主轴方向上对齐方式，默认为:flex-start,沿着主轴的延伸方向在起点处放置类似于box-packjustify-content有5种取值 flex-start，子元素放置于主轴延伸方向的起点处，比如：正向水平排列时，在左边;反向水平排列时，在右边;垂直正向排列时，在上边;以此类推 flex-end，子元素放置于主轴延伸方向的终点处，比如：正向水平排列时，在右边;反向水平排列时，在左边;垂直正向排列时，在下边;以此类推 center，子元素放置于主轴延伸方向的中点处，两边的剩余空间平均分布 space-between，两端对齐，元素之间的间隔都相等，与box-pack=justify类似 space-around，每个元素两侧的间隔相等，项目之间的间隔比项目与边框的间隔大一倍 效果见flex-demo-01 align-itemsalign-items规定子元素在次轴方向上对齐方式，默认为:start,沿着次轴的延伸方向在起点处放置类似于box-alignalign-items有5种取值 flex-start，子元素放置于次轴延伸方向的起点处，比如：正向水平排列时，在上边;垂直正向排列时，在左边;以此类推 flex-end，子元素放置于次轴延伸方向的起终点处，比如：正向水平排列时，在下边;垂直正向排列时，在右边;以此类推 center，子元素放置于次轴延伸方向的中点处，两边的剩余空间平均分布 baseline，如果 box-orient 是inline-axis或horizontal，所有子元素均与其基线对齐 stretch ，默认，拉伸子元素以填充包含块, 效果见：flex-demo-01flex-demo-02 align-contentalign-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用 orderorder属性规定框中子元素的显示次序，数值越小，排列越靠前，默认为0类似于box-ordinal-group box-ordinal-group: N; //正整数，不可负值 此属性可以突破子元素的书写顺序，根据需要将元素按照规定顺序排列，N值越小，排列越靠前 flex-growflex-grow规定各个子元素对父框剩余空间的分配比例类似于box-flex flex-grow: N; 默认为0，即如果存在剩余空间，不要空间来填充 flex-shrinkflex-shrink定义了元素的缩小比例，默认为1，即如果空间不足，该项目将缩小 flex-shrink: N; 如果所有元素的flex-shrink属性都为1，当空间不足时，都将等比例缩小 如果一个项目的flex-shrink属性为0，则空间不足时，不缩小 flex-basisflex-basis定义了在分配多余空间之前，项目占据的主轴空间，浏览器根据这个属性，计算主轴是否有多余空间。默认值为auto，即项目的本来大小类似于box-flex中设置固定尺寸 flex-basis: Npx 或 auto; flexflex属性是flex-grow, flex-shrink 和 flex-basis的简写 flex：flex-grow flex-shrink flex-basis; 默认值为0 1 auto,后两个属性可选该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto) align-selfalign-self属性允许单个元素有不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 align-self: auto | flex-start | flex-end | center | baseline | stretch; 效果见：flex-demo-03 参考：Flex 布局教程：语法篇 .father{ height:120px; width:240px; border:solid 1px; margin:auto; margin-top:20px; position:relative; } .son1{ height:0px; width:100%; border:solid 1px #0000ff; position:absolute; top:50%; } .son1::after{ content:\"\"; display:inline-block; position:absolute; left:97%; top:-6px; border-width: 6px 12px; border-style: solid; border-color: transparent transparent transparent #0000ff; border-radius: 4px 0 0 4px/4px 0 0 4px; } .son2{ height:100%; width:0; border:solid 1px #8a00e6; position:absolute; left:50%; top:0%; } .son2::after{ content:\"\"; display:inline-block; position:absolute; left:-5px; top:-14px; border-width: 12px 6px; border-style: solid; border-color: transparent transparent #8a00e6 transparent; border-radius: 4px 0 0 4px/4px 0 0 4px; }","tags":[{"name":"CSS","slug":"CSS","permalink":"http://blueskyawen.com/tags/CSS/"}]},{"title":"css3-Box弹性框","date":"2018-01-21T05:40:43.000Z","path":"2018/01/21/css3-box/","text":"Box是一种弹性可伸缩框，能够实现灵活的元素布局，几乎可以替代传统的“盒子模型”和浮动等，灵活方便 Box的声明如下： display:-moz-box; display:-webkit-box; display:box; box布局有一些属性加以辅助，是灵活布局的关键 box-orientbox-orient规定子元素的排列方向，同时也设定了主轴和次轴的方向，默认是水平方向 主轴 次轴 如图所示，蓝色为主轴方向，紫色的为次轴方向，这是默认的排列方式orient有四种取值： horizontal，子元素沿水平方向从左向右排列，水平方向为主轴，垂直方向为次轴 vertical，子元素沿垂直方向从上向下排列，垂直方向为主轴，水平方向为次轴 inline-axis，映射为 horizontal block-axis，映射为 vertical 效果见box-demo-01 box-directionbox-direction规定子元素在主轴上是否根据书写顺序，以正序还是反序来显示，默认是正序，呈现方式会随着主轴不同而不同;同时也会规定了主轴和次轴的延伸方向举个例子： &lt;div&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;/div&gt; 书写顺序为1 2 3，正序显示为:1 2 3,反序为：3 2 1direction有2种取值 normal,以默认方向显示子元素,正方向 reverse,以反方向显示子元素 主轴的延伸方向 水平 + 正向 排列，延伸方向：左–&gt;右 水平 + 反向 排列，延伸方向：右–&gt;左 垂直 + 正向 排列，延伸方向：上–&gt;下 垂直 + 反向 排列，延伸方向：下–&gt;上 次轴的延伸方向 水平 + 正向 排列，延伸方向：上–&gt;下 水平 + 反向 排列，延伸方向：上–&gt;下 垂直 + 正向 排列，延伸方向：左–&gt;右 垂直 + 反向 排列，延伸方向：左–&gt;右 效果见box-demo-01 box-packbox-pack规定子元素在主轴方向上放置方式，默认为:start,沿着主轴的延伸方向在起点处放置direction有4种取值 start，子元素放置于主轴延伸方向的起点处，比如：正向水平排列时，在左边;反向水平排列时，在右边;垂直正向排列时，在上边;以此类推 end，子元素放置于主轴延伸方向的终点处，比如：正向水平排列时，在右边;反向水平排列时，在左边;垂直正向排列时，在下边;以此类推 center，子元素放置于主轴延伸方向的中点处，两边的剩余空间平均分布 justify，两边最边上的2个子元素分别在起点和终点处，中间其他元素分散分布，中间元素之间的间隔均等 效果见box-demo-01 box-alignbox-align规定子元素在次轴方向上放置方式，默认为:start,沿着次轴的延伸方向在起点处放置align有4种取值 start，子元素放置于次轴延伸方向的起点处，比如：正向水平排列时，在上边;垂直正向排列时，在左边;以此类推 end，子元素放置于次轴延伸方向的起终点处，比如：正向水平排列时，在下边;垂直正向排列时，在右边;以此类推 center，子元素放置于次轴延伸方向的中点处，两边的剩余空间平均分布 baseline，如果 box-orient 是inline-axis或horizontal，所有子元素均与其基线对齐 stretch ，拉伸子元素以填充包含块 效果见：box-demo-01box-demo-02 box-linesbox-lines 规定如果列超出了父框中的空间，是否要换行显示，但是目前并没有浏览器支持，我试了也没有看到效果 box-ordinal-groupbox-ordinal-group 属性规定框中子元素的显示次序，使用方式： box-ordinal-group: N; //正整数，不可负值 此属性可以突破子元素的书写顺序，根据需要将元素按照规定顺序排列，N值越小，排列越靠前 效果见：box-demo-03 box-flexbox-flex规定各个子元素对父框剩余空间的分配比例，有三种情况： 父框存在剩余，剩余空间在子元素上按设置的比例分配 父框存在剩余，其中有几个子元素占用固定空间;如果还有剩余，则剩余空间在其他子元素上按设置的比例分配 父框不存在剩余，设置的比例分配无效果 效果见：box-demo-03 .father{ height:120px; width:240px; border:solid 1px; margin:auto; margin-top:20px; position:relative; } .son1{ height:0px; width:100%; border:solid 1px #0000ff; position:absolute; top:50%; } .son1::after{ content:\"\"; display:inline-block; position:absolute; left:97%; top:-6px; border-width: 6px 12px; border-style: solid; border-color: transparent transparent transparent #0000ff; border-radius: 4px 0 0 4px/4px 0 0 4px; } .son2{ height:100%; width:0; border:solid 1px #8a00e6; position:absolute; left:50%; top:0%; } .son2::after{ content:\"\"; display:inline-block; position:absolute; left:-5px; top:-14px; border-width: 12px 6px; border-style: solid; border-color: transparent transparent #8a00e6 transparent; border-radius: 4px 0 0 4px/4px 0 0 4px; }","tags":[{"name":"CSS","slug":"CSS","permalink":"http://blueskyawen.com/tags/CSS/"}]},{"title":"css3-渐变","date":"2018-01-18T15:28:32.000Z","path":"2018/01/18/css3-gradients/","text":"渐变是css3新增加的一种属性，分线性渐变和径向渐变，可渲染出一些复杂的效果，比如： background: linear-gradient(angle角度，color1-stop,color2-stop,...); 渐变其实是一种特殊的背景图片，因此可以像背景图一样使用，并配合背景底色 background-image: linear-gradient(angle角度，color1-stop,color2-stop,...); background-color: #f2f2f2; 渐变至少要两个色标 线性渐变线性渐变是几个颜色沿着一定角度的“发射线”而形成的颜色过渡效果线性渐变声明方式： linear-gradient(angle角度，color1-stop,color2-stop,...) 其中： 1. angle角度指的是沿着元素中心的“射线”的角度，几个颜色点就是沿着这根射线的方向在变化和过渡的，从下向上为0deg，顺时针为正，逆时针为负值也可以使用关键字来指明方向，to top表示从下往上，to top left表示从右下角往左上角，当height=width的时候： to top -&gt; 0deg to right -&gt; 90deg to bottom -&gt; 180deg to left -&gt; -90deg(或270deg) to top left -&gt; -45deg(或315deg) to top right -&gt; 45deg to bottom left -&gt; -135deg(或225deg) to bottom right -&gt; 135deg 2. 色标色标就是上面的color-stop，指的是每个颜色的结束位置，包括颜色和位置，比如： red 20% blue 50% //在20%-&gt;50%的位置范围内从red过渡到blue 位置如果不写的话，默认平均分配，比如下面写法效果一样： linear-gradient(red, green, blue) linear-gradient(red 0%, green 50%, blue 100%) linear-gradient(red n%, blue m%)表示： 0%-&gt;n%，red n%-&gt;m%，red到blue的过渡 n%-&gt;100%，blue 当两个不同颜色位置写诚一样时，可形成边界分明的“颜色条”，比如： linear-gradient(red 0%,red30%，green 30%，green 50%,blue 50%blue 100%) 表示：0%-&gt;30%，red;30%-&gt;30%，red到green,一般显示一条边界线;30%-&gt;50%，green;50%-&gt;100%,blue 3. 重复渐变当首尾两颜色位置不在0%或100%时，可以进行重复渐变,使色标在渐变线方向上无限重复,形成特殊的排列效果例子： background: -webkit-repeating-linear-gradient(blue 20%,green 50%); background: repeating-linear-gradient(blue 20%,green 50%); #####4. 多次渐变组合背景颜色渐变可以定义多次，这些渐变效果将会重叠在一起，合理使用背景的其他属性，比如：size,repeat，可以构造处多个渐变的组合效果，这里不缀述，可以参考后面的demo 本文所有的效果见:linear-gradient-demo 参考文章：深入理解线性渐变 径向渐变径向渐变从圆心点以椭圆形状向外扩散，渐变的实现由两部分组成：位置，形状，size和色标 radial-gradient(shape size ?at position, color-stop，..) #####1.位置位置指的是径向椭圆的中心点的位置，可以使用关键字/百分比/整数来定义，比如： at top left at 200px 200px at 30% 30% 其中关键字的对应关系 top left：0% 0% top right：100% 0% center center：50% 50% bottom left：0% 100% bottom right：100% 100% #####2.形状形状指的是圆形还是椭圆：circle/ellipse，默认是椭圆，可以不用书写; #####3.size这个主要是径向渐变发散的半径不同，可以参考文档：深入理解径性渐变 本节所有demo可见：径向渐变-demo","tags":[{"name":"CSS","slug":"CSS","permalink":"http://blueskyawen.com/tags/CSS/"}]},{"title":"css3-动画","date":"2018-01-14T14:50:03.000Z","path":"2018/01/14/css3-animation/","text":"CSS3中有两种制造动画效果的方式，一种是过渡transition，一种是animation 过渡transition即transition系列属性，可以对CSS属性的变化定义一个过程效果，主要属性如下： transition-property，应用过渡的CSS属性名 transition-duration，过渡效果总共花费的时间，可以是s或ms。默认是 0，无效果 transition-timing-function,规定过渡效果的时间曲线,可能取值：linear/ease/ease-in/ease-out/ease-in-out,默认是ease transition-delay,过渡效果开始的延迟时间，默认是0 transition是几个属性的简写： transition： property duration function delay; 过渡的效果是一次性的，一次可以同时添加多个css属性的变化过渡需要事件的触发，包括：鼠标键盘事件，超时事件等 点击这里有demo:transition-demo animationanimation也是基于css属性的变化来够造动画效果的，但是，与过渡不同，它可以构造多次动画效果，甚至可以一直动下去，也可作用于多个CSS属性animation主要包括下面几个属性： @keyframes,定义动画,按时间流动变化定义CSS变化 animation-name ，定义@keyframes 动画的名称 animation-duration，动画完成一个周期所花的总时长，单位：秒或毫秒，默认是 0;keyframes里的百分比就是这个时常的百分比，代表时间流动的间隔 animation-timing-function，动画的速度曲线，默认是 “ease” animation-delay，动画开始的延迟，默认是0 3 animation-iteration-count，动画被播放的次数，默认是 1,infinite指无限次 animation-direction，声明动画是否在下一周期逆向地播放，默认是 “normal”，“alternate”指正反轮流播放 animation-play-state，规定动画是否正在运行或暂停，默认是 “running”，设置成“paused”，动画将暂停 animation-fill-mode，规定对象动画时间之外的状态 声明animation动画很简单，就两部： 使用@keyframes定义动画，即按照时间流动的百分比例来规定css属性的变化 利用animation来使用动画，定义动画的时间，运动方式..等 animation是多个属性的简写： animation：name duration function delay count direction; 下面是一个例子： @keyframes my-animation { 0% {background:red; left:0px; top:0px;} 25% {background:yellow; left:200px; top:0px;} 50% {background:blue; left:200px; top:200px;} 75% {background:green; left:0px; top:200px;} 100% {background:red; left:0px; top:0px;} } //其他浏览器兼容需要定义多个，分别带前缀，比如@-moz-keyframes，.. div:hover { animation:myfirst 5s linear 2s infinite alternate; -moz-animation:myfirst 5s linear 2s infinite alternate; -webkit-animation:myfirst 5s linear 2s infinite alternate; -o-animation:myfirst 5s linear 2s infinite alternate; } 相关demo请点击：动画-demo旋转木马怦然心动","tags":[{"name":"CSS","slug":"CSS","permalink":"http://blueskyawen.com/tags/CSS/"}]},{"title":"css3-3D变换","date":"2018-01-14T13:14:19.000Z","path":"2018/01/14/css3-3D/","text":"3D转换，能够对元素进行3D变换 transformtransform: none|transform-functions; 其中变换方法如下： matrix3d(n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n)，定义 3D 转换，使用 16 个值的 4x4 矩阵。。 translate3d(x,y,z)，定义在三个坐标轴上的转换，包括：translateX(x)，translateY(y)，translateZ(z) scale3d(x,y,z)，定义三个坐标轴上的缩放，包括：scaleX(x)，scaleY(y)，scaleZ(z) rotate3d(x,y,z,angle)，定义 3D 旋转; rotateX(angle)，沿着 X 轴旋转 rotateY(angle)，沿着 Y 轴旋转 rotateZ(angle)，沿着 Z 轴旋转 rotate3drotate3d(x,y,z,deg) 方法有4个参数，前三个，对应x,y,z 轴，是标示你是否希望沿着该轴旋转，是为1，不是为0，最后一个标示旋转的角度其中， x：是一个0到１之间的数值，主要用来描述元素围绕X轴旋转的矢量值； y：是一个０到１之间的数值，主要用来描述元素围绕Y轴旋转的矢量值； z：是一个０到１之间的数值，主要用来描述元素围绕Z轴旋转的矢量值； a：是一个角度值，主要用来指定元素在3D空间旋转的角度，如果其值为正值，元素顺时针旋转，反之元素逆时针旋转。 当然，也可以理解为并不是元素在旋转，而是基平面转动而造成的元素旋转的现象：rotateX是由于y-z平面的旋转，rotateY是由于x-z平面的旋转，rotateZ是由于x-y平面的旋转 rotateX(angle)，从右向左看，angle为正值，顺时针旋转;为负值，逆时针旋转; rotateY(angle)，从下向上看，angle为正值，顺时针旋转;为负值，逆时针旋转; rotateZ(angle)，从前向后看，angle为正值，顺时针旋转;为负值，逆时针旋转; 下面介绍的三个旋转函数功能等同： rotateX(a)函数功能等同于rotate3d(1,0,0,a) rotateY(a)函数功能等同于rotate3d(0,1,0,a) rotateZ(a)函数功能等同于rotate3d(0,0,1,a) transform-style规定子元素如何在3D空间中显现，设置在父元素 flat，子元素将不保留其3D位置，以2D形式呈现 preserve-3d，子元素将保留其3D空间 perspective定义元素距视图的距离，以像素计;当为元素定义 perspective 属性时，其子元素会获得透视效果，而不是元素本身;如下图所示，perspective实际是人的眼睛和屏幕元素的视距：如上图，perspective距离于舞台元素尺寸一样，perspective-origin默认为舞台中心这时侯，假如三个子元素都逆时针旋转45deg,第三个元素在视图上将“消失”，因为其正好与视线平行， perspective属性有两种写法： 设置在父元素，perspective：Npx，表示”眼睛”与父元素平台的距离，这是的视距是针对父元素来的，其子元素的呈现可能会因为位置不一致导致看到的各不相同 设置于子元素，transform: perspective(Npx), 各个子元素的视距一样，所看到的效果基本是一致的 perspective-origin定义视图视线所关注的位置，从Z轴往x-y平面看去： perspective-origin: x-axis y-axis; //可能取值：left/center/right/length/% 在perspective平面上，可以移动视线，关注点自然不一样，图解如下：其中，默认是沿着Z轴中心，1，2都是因为perspective-origin变化导致的关注点不同举个例子，加入视线看着元素上边沿，下面是origin移动时，视线和视图方向的变化： 设置在父元素，表示”眼睛”与父元素舞台的位置，在边上，中心或其他位置，在不同的位置对其子元素的视觉是不一样的，包括子元素变换的时候 backface-visibility定义当元素不面向屏幕时是否可见当元素发生旋转，尤其是绕X轴和Y轴旋转，当旋转角度大于90deg以上时，就呈现的是元素的背面了;backface-visibility就是指示背面要不要被看到，其中： visible，背面是可见的 hidden，背面是不可见的。相当于啥都看不到 效果查看demo的transform3d：transform-3D","tags":[{"name":"CSS","slug":"CSS","permalink":"http://blueskyawen.com/tags/CSS/"}]},{"title":"css3-2D变换","date":"2018-01-14T10:22:27.000Z","path":"2018/01/14/css3-2D/","text":"2D变换，能够对元素进行移动、缩放、转动、拉长或拉伸 transformtransform: none|transform-functions; 其中变换方法如下： matrix(n,n,n,n,n,n)，定义 2D 转换，使用六个值的矩阵。 translate(x,y)，定义 2D 转换，沿着 X 和 Y 轴移动元素。 translateX(n) ，定义 2D 转换，沿着 X 轴移动元素。 translateY(n) ，定义 2D 转换，沿着 Y 轴移动元素。 scale(x,y) ，定义 2D 缩放转换，改变元素的宽度和高度。 scaleX(n) ，定义 2D 缩放转换，改变元素的宽度。 scaleY(n) ，定义 2D 缩放转换，改变元素的高度。 rotate(angle) ，定义 2D 旋转，在参数中规定角度。 skew(x-angle,y-angle) ，定义 2D 倾斜转换，沿着 X 和 Y 轴。 skewX(angle) ，定义 2D 倾斜转换，沿着 X 轴。 skewY(angle) ，定义 2D 倾斜转换，沿着 Y 轴。 1.translate（x,y）元素平移，其中 x是水平移动，正值向右，负值向左 y是水平移动，正值向下，负值向上 例子： transform: translate(50px,20px); -ms-transform: translate(50px,20px); /* IE 9 */ -webkit-transform: translate(50px,20px); /* Safari and Chrome */ -o-transform: translate(50px,20px); /* Opera */ -moz-transform: translate(50px,20px); /* Firefox */ 2.scale(x,y)元素尺寸大小缩放，可为小数，其中 x是宽度缩放 y是高度缩放 例子： transform: scale(2,2.4); -ms-transform: scale(2,2.4); -webkit-transform: scale(2,2.4); -o-transform: scale(2,2.4); -moz-transform: scale(2,2.4); 3.rotate(angle)元素旋转一定角度，正值沿顺时针旋转，负值沿逆时针旋转例子： transform: skewX(30deg); -ms-transform: skewX(30deg); -webkit-transform: skewX(30deg); -o-transform: skewX(30deg); -moz-transform: skewX(30deg); 4.skew(x-angle,y-angle)沿着 X 和 Y 轴的 2D 倾斜转换先按照元素两个中轴倾斜固定的角度，再将2根中轴线向两边平移形成 transform: skewY(30deg); -ms-transform: skewY(30deg); -webkit-transform: skewY(30deg); -o-transform: skewY(30deg); -moz-transform: skewY(30deg); 两个中轴只有一根倾斜： transform: skewX(30deg); -ms-transform: skewX(30deg); -webkit-transform: skewX(30deg); -o-transform: skewX(30deg); -moz-transform: skewX(30deg); transform: skewY(30deg); -ms-transform: skewY(30deg); -webkit-transform: skewY(30deg); -o-transform: skewY(30deg); -moz-transform: skewY(30deg); transform-origin此属性允许您改变被转换元素的位置，主要用于rotate，scale和skew函数的参考点，对translate无明显影响，其中： 对于rotate，用于旋转的参考点位置 对于scale，用于缩放时的变换方向，比如，origin：0% 100%-使用scaleY(N)时向上变换；origin：0% 50%-使用scaleY(N)时向两边变换；..等等，具体在文章末demo观察 对于skew，用于变换的固定参考点 Demo请点击此处，可以自行调节参数观察各函数的使用变化：2D-translate-demo2D-skew-demo","tags":[{"name":"CSS","slug":"CSS","permalink":"http://blueskyawen.com/tags/CSS/"}]},{"title":"CSS3-边框和文本","date":"2018-01-14T07:27:46.000Z","path":"2018/01/14/css3-border-box/","text":"边框border-radius顺序设置元素每个角的圆角边框 border-radius: 1-4 length|% / 1-4 length|%; -webkit-border-radius: 1-4 length|% / 1-4 length|%; -moz-border-radius: 1-4 length|% / 1-4 length|%; -o-border-radius: 1-4 length|% / 1-4 length|%; 其中1-4就是四个角处的半径，单位可以是：N或%，若省略了部分值，则以对角的设置为准，如下图： 以下都是合法的写法： border-radius:1px 2px 3px 4px / 2px 3px 4px 5px; border-radius:1px 2px 3px 4px / 2px 3px 4px; 同 border-radius:1px 2px 3px 4px / 2px 3px 4px 3px; border-radius:1px 2px 3px 4px / 2px 3px; 同 border-radius:1px 2px 3px 4px / 2px 3px 2px 3px; border-radius:1px 2px 3px 4px / 2px; 同 border-radius:1px 2px 3px 4px / 2px 2px 2px 2px; border-radius:1px 2px / 2px 3px; 同 border-radius:1px 2px 1px 2px / 2px 3px 2px 3px; border-radius:1px 2px; 同 border-radius:1px 2px / 1px 2px; border-radius:2px; 同 border-radius:2px 2px 2px 2px / 2px 2px 2px 2px; 以下分开写的属性： border-top-left-radius:a b; //length或%，定义了左上角的弧度 border-top-right-radius //定义了右上角的弧度 border-bottom-right-radius //定义了右下角的弧度 border-bottom-left-radius //定义了左下角的弧度 具体Demo请点击此处：border-radius-demo box-shadow向框添加一个或多个阴影 box-shadow: x-shadow y-shadow blur spread color inset; x-shadow,水平阴影的位置。为正值时，阴影在右边框往右;负值时，阴影在左边框往左。但当inset内阴影时，正值时阴影在左边框往右，负值时阴影在右边框往左。 y-shadow,垂直阴影的位置。为正值时，阴影在下边框往下;负值时，阴影在上边框往上。但当inset内阴影时，正值时阴影在上边框往下，负值时阴影在下边框往上。 blur,模糊距离 spread，阴影的尺寸 color，阴影的颜色 将外部阴影 (outset) 改为内部阴影 具体Demo请点击此处：box-shadow-demo border-image图片边框,几种属性的简写 border-image：border-image-source border-image-slice / border-image-width / border-image-outset fill border-image-repeat 其中： border-image-source，用在边框的图片的路径 border-image-slice，4个边框向内切割的偏移量 border-image-width，边框宽度 border-image-outset，图像边框和内容框的间距偏移距离 border-image-repeat，切割后的图片在边框拉伸中的实现方式，平铺(repeated)、铺满(rounded)或拉伸(stretched) fill，指示中间部分是否显示，fill则显示，否则不显示 简单写来： border-image：image-source slice1 slice2 slice3 slice / width1 width2 width3 width4 / outset1 outset2 outset3 outset4 fill repeat; 其中：width1-4是“上右下左”顺序四个图片边框的宽度，省略时以对面为准，同border其他属性的设置方式slice1-4是“上右下左”顺序四个切割的宽度，切割出来的图片被用来显示成边框，如下图，类似于9宫格的切片方式 四个角用作图边框的角，四边切出来的图片用作image边框4边的填充图 具体Demo请点击此处：border-image-demo 背景背景色background-color: color; background-clip: border-box; 或 background: color border-box; 其中clip为背景绘制区域，有border-box/padding-box/content-box几种类型值 背景图片background-image: url(***.jpg); background-position: left top; background-size: contain; background-repeat: no-repeat; background-origin: border-box; background-attach: scroll; 或 background: image position / size repeat attach; 其中: background-origin，是背景图片的定位方式，有border-box/padding-box/content-box取值，类似与背景的clip background-attach，定义背景图是否随着页面内容滚动而滚动，取值scroll/fixed，但是这个属性是针对于整个页面生效的，对单个盒子是不生效的 具体Demo请点击此处：background-demo 文本white-space设置如何处理元素内的空白，值 normal，默认，空白会被浏览器忽略。 pre，空白会被浏览器保留。 nowrap，文本不会换行，文本会在在同一行上继续，直到遇到br pre-wrap，保留空白符序列，但是正常地进行换行 pre-line，合并空白符序列，但是保留换行符 inherit，规定应该从父元素继承 white-space 属性的值 text-shadow向文本添加一个或多个阴影 text-shadow: h-shadow v-shadow blur color; 其中： h-shadow，水平阴影的位置。正值阴影在右边，负值阴影在左边 v-shadow，垂直阴影的位置。正值阴影在下边，负值阴影在上边 blur，可选，模糊的距离 color，阴影的颜色 具体Demo请点击此处：text-shadow text-overflow规定当文本溢出包含元素时发生的事情 clip，修剪文本 ellipsis，显示省略符号来代表被修剪的文本 string，使用给定的字符串来代表被修剪的文本 具体Demo请点击此处：text-overflow word-wrap属性允许长单词或 URL 地址换行到下一行 normal，只在允许的断字点换行（浏览器保持默认处理）。 break-word，在长单词或 URL 地址内部进行换行，使用时整个长单词都换行到下一行 word-break属性规定自动换行的处理方法 normal，使用浏览器默认的换行规则。 break-all，允许在单词内换行。 keep-all，只能在半角空格或连字符处换行。 具体Demo请点击此处：word-break","tags":[{"name":"CSS","slug":"CSS","permalink":"http://blueskyawen.com/tags/CSS/"}]},{"title":"Rxjs-forkjoin/zip/combineLatestde的相似与区别","date":"2018-01-11T15:18:00.000Z","path":"2018/01/11/forkjoin-zip/","text":"forkJoin,ip,combineLatest都是Observable的静态组合方法，用来将多个Observable组合起来处理，在使用中有时候有点混，下面说一下它们的相似点和区别 forkJoinforkJoin合并的流，会在每个被合并的流都发出结束信号时发射一次也是唯一一次数据，数据即几个流对象的最后的一个发射值组成的数组 //延迟1s后发射自增值，每次发射间隔1s,取前3个 var obj1 = Observable.timer(1000,1000).take(3); //延迟1s后发射自增值，每次发射间隔2s,取前5个 var obj2 = Observable.timer(1000,2000).take(5); Observable.forkJoin(obj1,obj2).subscribe(data =&gt; console.log(data)); //输出：--&gt; 9s --&gt; [2, 4] 等待全部发射完后去最后一个值构成输出数组对象 操作符只是巡查最后一个Observable的complete信号来判断 在Observable只有一个值的时候，比如HTTP使用就十分简单 Observable.forkJoin(http.getObject1(),http.getObject2()) .subscribe(data[0]= =&gt; console.log(data)); //data[0]=Object1;data[1]=Object2; zipzip合并流的时候，是对每一个发射的值都进行合并输出;就比如，当每个传入zip的流都发射完毕第一次数据时，zip将这些数据合并为数组并发射出去；当这些流都发射完第二次数据时，zip再次将它们合并为数组并发射。以此类推直到其中某个流发出结束信号，整个被合并后的流结束还是上面的例子 var obj1 = Observable.timer(1000,1000).take(3); var obj2 = Observable.timer(1000,2000).take(5); Observable.forkJoin(obj1,obj2).subscribe(data =&gt; console.log(data)); //输出：-&gt;1s-&gt; 0 -&gt;1s-&gt; 1 -&gt;1s-&gt; 2 -&gt;1s-&gt; 0 -&gt; 2s -&gt; 1 -&gt; 2s -&gt; 2 -&gt; 2s -&gt; 3 . [0,0] [1,1] [2,2] 可以看到，zip是每一次对应的值反射完成后都会组合起来输出的，直到一个流结束;例子中，obj1在3s处就发射完成，等待obj2对应的值反射后，输出最后一次组合值，然后结束，不管obj2后面是否还有值，总耗时: 1+2+2 = 5s 在Observable只有一个值的时候，比如HTTP使用和forkJoin的效果一样 Observable.zip(http.getObject1(),http.getObject2()) .subscribe(data[0]= =&gt; console.log(data)); //data[0]=Object1;data[1]=Object2; combineLatestcombineLatest使用每一次发射值与其他流的当前发射值进行合并输出，除了第一次要等到都完成有值以外就是说，子流1在等待其他流发射数据期间又发射了新数据，则使用子流1最新发射的数据和其他流的最后一次发射值进行合并;之后每当有某个流发射新数据，不再等待其他流同步发射数据，而是使用其他流之前的最近一次数据进行合并;以此类推，直到所以流都结束了，这是和zip不一样的地方 var obj1 = Observable.timer(1000,1000).take(3); var obj2 = Observable.timer(1000,2000).take(5); Observable.combineLatest(obj1,obj2).subscribe(data =&gt; console.log(data)); //输出： -&gt;1s-&gt; 0 -&gt;1s-&gt; 1 -&gt;1s-&gt; 2 -&gt;1s-&gt; 0 --&gt; 2s --&gt; 1 --&gt;2s--&gt; 2 --&gt;2s--&gt; 3 --&gt;2s--&gt; 4 [0,0] [1,0] [1,1][2,1] [2,2] [2,3] [2,4] 总耗时：9s","tags":[{"name":"rxjs","slug":"rxjs","permalink":"http://blueskyawen.com/tags/rxjs/"}]},{"title":"Rxjs-操作符","date":"2017-12-27T14:47:10.000Z","path":"2017/12/27/rxjs-operators/","text":"操作符是 Observable 类型上的方法，比如map(…)、.filter(…)、.merge(…)，等等。当操作符被调用时，它们不会改变已经存在的 Observable 实例。相反，它们返回一个新的 Observable ，它的 subscription 逻辑基于第一个 Observable 操作符是函数，它基于当前的 Observable 创建一个新的 Observable。这是一个无副作用的操作：前面的 Observable 保持不变。 操作符本质上是一个纯函数 (pure function)，它接收一个 Observable 作为输入，并生成一个新的 Observable 作为输出。订阅输出 Observalbe 同样会订阅输入 Observable创建一个自定义操作符函数，它将从输入 Observable 接收的每个值都乘以10： function multiplyByTen(input) { var output = Rx.Observable.create(function subscribe(observer) { input.subscribe({ next: (v) =&gt; observer.next(10 * v), error: (err) =&gt; observer.error(err), complete: () =&gt; observer.complete() }); }); return output; } var input = Rx.Observable.from([1, 2, 3, 4]); var output = multiplyByTen(input); output.subscribe(x =&gt; console.log(x)); 输出： 10 20 30 40 操作符分类实例操作符通常提到操作符时，我们指的是实例操作符，它是 Observable 实例上的方法。举例来说，如果上面的 multiplyByTen 是官方提供的实例操作符，它看起来大致是这个样子的： Rx.Observable.prototype.multiplyByTen = function multiplyByTen() { var input = this; return Rx.Observable.create(function subscribe(observer) { input.subscribe({ next: (v) =&gt; observer.next(10 * v), error: (err) =&gt; observer.error(err), complete: () =&gt; observer.complete() }); }); } 实例运算符是使用 this 关键字来指代输入的 Observable 的函数。注意，这里的 input Observable 不再是一个函数参数，它现在是 this 对象。下面是我们如何使用这样的实例运算符： var observable = Rx.Observable.from([1, 2, 3, 4]) .multiplyByTen(); .subscribe(x =&gt; console.log(x)); 静态操作符除了实例操作符，还有静态操作符，它们是直接附加到 Observable 类上的。静态操作符在内部不使用 this 关键字，而是完全依赖于它的参数。比如：forkJoin var obj1 = Rx.Observable.from([1,2.3]); var obj2 = Rx.Observable.of(4,5,6); Rx.Observable.forkJoin(obj1,obj2),subscribe(data =&gt; { var obj1 = data[0]; var obj2 = data[1]; }); 常用操作符Observable的操作符很多，详细可参考官网：Rxjs-opertors，里面有一节叫“选择操作符”很有用，指导你选择需要的操作符 1) 创建create，empty，from，fromEvent，fromEventPattern，fromPromise，generate，interval，never，of，repeat，range，throw，timer等 //每隔1秒发出自增的数字，3秒后开始发送。 var numbers = Rx.Observable.timer(3000, 1000); numbers.subscribe(x =&gt; console.log(x)); //先发出数字7，然后发出错误通知。 var result = Rx.Observable.throw(new Error(&apos;oops!&apos;)).startWith(7); result .subscribe(res =&gt; console.log(res)) .catch(Rx.Observable.throw(errot.msg)); //发出从1开始，长度为10的数字 var numbers = Rx.Observable.range(1, 10); //每1秒发出一个自增数 var numbers = Rx.Observable.interval(1000); 2) 转换mapmap(function),根据条件函数对每个源方式值进行数据处理，输出到输出Observablea.数据序列二次处理 import { Observable} from &apos;rxjs/Observable&apos;; import &apos;rxjs/add/operator/map&apos; let list = Observable.of(1,2,3); list.map(x =&gt; x*10 + &apos;$&apos;).subscribe(res =&gt; console.log(res)); //输出 10$ -&gt; 20$ -&gt; 30$ b.对象结构体属性处理 let obj1 = {name:&apos;jack&apos;,age:16,sex:&apos;man&apos;}; let obj2 = {name:&apos;licy&apos;,age:18,sex:&apos;woman&apos;}; Observable.of(obj1,obj2) .map(x =&gt; x.name+&apos;@&apos;+x.age) .subscribe(res =&gt; console.log(res)); //输出 jack@16 -&gt; licy@18 mapTomapTo(value: any)，每次源 Observble 发出值时，都在输出 Observable 上发出给定的常量值 var timer1 = Observable.of(2,3,6); this.subject = timer1.mapTo(88).subscribe(v =&gt; {this.valueList.push(v);}); //输出： 88 88 88 pluckpluck(string..),根据key提取源Observable每个发射对象的属性值，输出新Observable let obj1 = {name:{firstName:&apos;li&apos;,secondName:&apos;jack&apos;},age:16,sex:&apos;man&apos;}; let obj2 = {name:{firstName:&apos;yang&apos;,secondName:&apos;lucy&apos;},age:18,sex:&apos;woman&apos;}; Observable.of(obj1,obj2) .pluck(&apos;age&apos;) .subscribe(res =&gt; console.log(res)); //输出 16 -&gt; 18 Observable.of(obj1,obj2) .pluck(&apos;name&apos;,&apos;firstName&apos;) .subscribe(res =&gt; console.log(res)); //输出 li -&gt; yang pairwise将当前值和前一个值作为数组放在一起，然后将其发出,[(N-1)th, Nth] var timer1 = Observable.of(1,2,3,4,5,6); this.subject = timer1.pairwise().subscribe(v =&gt; {this.valueList.push(v);}); //输出: 1,2 2,3 3,4 4,5 5,6 partitionpartition(function),将源 Observable 一分为二,输出两个Observables ： 一个像 filter 的输出， 而另一个是所有不符合条件的值 var timer1 = Observable.of(1,2,3,4,5,6); var parts = timer1.partition(x =&gt; x%2 == 0); var oushu = parts[0]; this.subject = oushu.subscribe(v =&gt; {this.valueList.push(v);}); //满足条件的：2 6 8 var qishu = parts[1]; this.subject = qishu.subscribe(v =&gt; {this.valueList.push(v);}); //不满足条件的：1 3 5 scanscan(function),对源 Observable 使用累加器函数， 返回生成的中间值， 可选的初始值;给定初始值，计算值作为前一个值于数组元素进行计算 var timer1 = Observable.of(1,3,5); this.subject = timer1.scan((x,y) =&gt; x * y, 2).subscribe(v =&gt; {this.valueList.push(v);}); //输出： 2 6 30 2*1 2×3 6×5 groupBy根据指定条件将源 Observable 发出的值进行分组，并将这些分组作为 GroupedObservables 发出，每一个分组都是一个 GroupedObservable 通过 id 分组并返回数组 Observable.of&lt;Obj&gt;({id: 1, name: &apos;aze1&apos;}, {id: 2, name: &apos;sf2&apos;}, {id: 2, name: &apos;dg2&apos;}, {id: 1, name: &apos;erg1&apos;}, {id: 1, name: &apos;df1&apos;}, {id: 2, name: &apos;sfqfb2&apos;}, {id: 3, name: &apos;qfs3&apos;}, {id: 2, name: &apos;qsgqsfg2&apos;} ) .groupBy(p =&gt; p.id) .flatMap( (group$) =&gt; group$.reduce((acc, cur) =&gt; [...acc, cur], [])) .subscribe(p =&gt; console.log(p)); // 显示： // [ { id: 1, name: &apos;aze1&apos; }, // { id: 1, name: &apos;erg1&apos; }, // { id: 1, name: &apos;df1&apos; } ] // // [ { id: 2, name: &apos;sf2&apos; }, // { id: 2, name: &apos;dg2&apos; }, // { id: 2, name: &apos;sfqfb2&apos; }, // { id: 2, name: &apos;qsgqsfg2&apos; } ] // // [ { id: 3, name: &apos;qfs3&apos; } ] concatconcat(Observable,..),创建一个输出 Observable，它在当前 Observable 之后顺序地发出每个给定的输入 Observable 中的所有值;顺序地发出多个 Observables 的值将它们连接起来，一个接一个的 let obj1 = Observable.of(6,7,8); let obj2 = Observable.of(1,2,3); this.subject = obj1.concat(obj2) .subscribe(v =&gt; {this.valueList.push(v);}); //输出：6 7 8 1 2 3 concatAll通过顺序地连接内部 Observable，将高阶 Observable 转化为一阶 Observable;通过一个接一个的连接内部 Observable ，将高阶 Observable 打平 var clicks = Rx.Observable.fromEvent(document, &apos;click&apos;); var higherOrder = clicks.map(ev =&gt; Rx.Observable.interval(1000).take(4)); var firstOrder = higherOrder.concatAll() .subscribe(x =&gt; console.log(x)); //顺序串行输出，于&quot;document&quot;对象上的点击事件，都会以1秒的间隔发出从0到3的值 concatMapconcatMap = concatAll + map将每个值映射为Observable, 然后使用concatAll将所有的内部Observables打平,顺序合并到输出 Observable,以串行的方式等待前一个完成再合并下一个Observable var obj = Observable.of(1,6,10); obj.concatMap(v =&gt; Observable.range(v,3)) .subscribe(x =&gt; console.log(x); //输出：1,2,3 6,7,8 10,11,12 var obj2 = Observable.of(10,10,10); obj.concatMap(v =&gt; obj2.map(y =&gt; y*v)) .subscribe(x =&gt; console.log(x); //输出：10,10,10 60,60,60 100,100,100 concatMapToconcatMapTo = concat + mapToconcatMapTo(obj),将源对象每个值映射成常对象，然后打平和顺序合并到输出 Observable var obj = Observable.of(1,6,10); obj.concatMapTo(Observable.of(&apos;a&apos;,&apos;b&apos;,&apos;c&apos;)) .subscribe(x =&gt; console.log(x); //输出：a,b,c a,b,c a,b,c merge创建一个输出Observable，通过把多个 Observables 的值按照时间混合到一个 Observable中来将其打平,混合的顺序没有明确规律merge(Observables,number)其中number为可同时订阅的输入 Observables 的最大数量 var timer1 = Rx.Observable.interval(1000).take(10); var timer2 = Rx.Observable.interval(2000).take(6); var timer3 = Rx.Observable.interval(500).take(10); timer1.merge(timer2, timer3, 2).subscribe(x =&gt; console.log(x)); mergeAllmergeAll(number),打平高阶 Observable，将高阶 Observable 转换成一阶 Observable ，一阶 Observable 会同时发出在内部 Observables 上发出的所有值 var clicks = Rx.Observable.fromEvent(document, &apos;click&apos;); var higherOrder = clicks.map((ev) =&gt; Rx.Observable.interval(1000).take(10)); higherOrder.mergeAll(2).subscribe(x =&gt; console.log(x)); mergeMapmergeMap = mergeAll + map效果同concatMap，只是mergeMap不是顺序合并，而是： 同步数据时，按发射时间输出 异步数据时，无规律输出 mergeMapTomergeMapTo = merge + mapTo效果与concatMapTo类似，,将源对象每个值映射成常对象，然后合并到输出，无特定顺序 switch通过只订阅最新发出的内部 Observable ，将高阶 Observable 转换成一阶 Observable;当发出一个新的内部 Observable 时， switch 会从先前发送的内部 Observable 那取消订阅，然后订阅新的内部 Observable 并开始发出它的值 // 结果是 `switched` 本质上是一个每次点击时会重新启动的计时器。 // 之前点击产生的 interval Observables 不会与当前的合并。 var clicks = Rx.Observable.fromEvent(document, &apos;click&apos;); var higherOrder = clicks.map((ev) =&gt; Rx.Observable.interval(1000)); higherOrder.switch().subscribe(x =&gt; console.log(x)); switchMapswitchMap = switch + map将每个源值投射成 Observable，该 Observable 会合并到输出 Observable 中， 并且只发出最新投射的 Observable 中的值 //还是上面的例子，只是将switch，map换成switchMap var clicks = Rx.Observable.fromEvent(document, &apos;click&apos;); higherOrder.switchMap(v =&gt; Observable.interval(1000)) .subscribe(x =&gt; console.log(x)); switchMapToswitchMapTo = switch + mapTo效果与concatMapTo类似 3) 过滤filterfilter(function..),通过只发送源 Observable 的中满足指定 predicate 函数的项来进行过滤 let obj = Observable.interval(1000); this.subject = obj.filter(x =&gt; x%2 == 0) .subscribe(v =&gt; {this.valueList.push(v);}); //输出 0 2 4 6 8 ... taketake(N),只发出源 Observable 最初发出的的N个值 let obj = Observable.interval(1000); this.subject = obj.take(5) .subscribe(v =&gt; {this.valueList.push(v);}); //输出 0 1 2 3 4 takeLasttakeLast(N),只发出源 Observable 最后发出的的N个值,只有当它完成时发出这些值; 此操作符必须等待源Observable 的complete 通知发送才能在输出 Observable 上发出 next值,所以一般应用于有限序列 let obj = Observable.range(1,10); this.subject = obj.takeLast(2) .subscribe(v =&gt; {this.valueList.push(v);}); //输出 9 10 takeWhiletakeWhile(function),发出在源 Observable 中满足 predicate 函数的每个值，并且一旦出现不满足 predicate 的值就立即完成 let obj = Observable.interval(1000); this.subject = obj.takeWhile(x =&gt; x &lt; 6) .subscribe(v =&gt; {this.valueList.push(v);}); //输出 0 1 2 3 4 5 distinctdistinct(keySelector: function, flushes: Observable),入参可选，去重 let obj = Observable.of(0,1,2,7,0,7,6,2); this.subject = obj.distinct() .subscribe(v =&gt; {this.valueList.push(v);}); //输出 0 1 2 7 6 this.subject = Observable.of&lt;any&gt;({ age: 4, name: &apos;Foo&apos;}, { age: 7, name: &apos;Bar&apos;}, { age: 5, name: &apos;Foo&apos;}) .distinct((p: Person) =&gt; p.name) .subscribe(x =&gt; console.log(x)); //输出 { age: 4, name: &apos;Foo&apos;} -&gt; { age: 7, name: &apos;Bar&apos;} distinctUntilChangeddistinctUntilChanged(keySelector: function),入参可选，它发出源 Observable 发出的所有与前几项不相同的 let obj = Observable.of(0,1,1,1,2,7,7,6,6); this.subject = obj.distinctUntilChanged() .subscribe(v =&gt; {this.valueList.push(v);}); //输出 0 1 2 7 6 this.subject = Observable.of&lt;any&gt;({ age: 4, name: &apos;Foo&apos;}, { age: 7, name: &apos;Bar&apos;}, { age: 5, name: &apos;Foo&apos;}, { age: 4, name: &apos;Foo&apos;},, { age: 4, name: &apos;Fool&apos;},) .distinctUntilChanged((p,q) =&gt; p.name == q.name) .subscribe(x =&gt; console.log(x)); //输出 { age: 4, name: &apos;Foo&apos;} -&gt; { age: 7, name: &apos;Bar&apos;} -&gt; { age: 5, name: &apos;Foo&apos;} -&gt; { age: 4, name: &apos;Fool&apos;} debounceTimedebounceTime(dueTime: number, scheduler: Scheduler),只有在特定的一段时间经过后并且没有发出另一个源值，才从源 Observable 中发出一个值 debounceTime 延时发送源 Observable 发送的值,但是会丢弃正在排队的发送如果源 Observable 又发出新值,可以用于搜索框实现 let obj = Observable.interval(2000); this.subject = obj.debounceTime(1000) .subscribe(v =&gt; {this.valueList.push(v);}); //输出 0 1 2 3 4 ... debouncedebounce(durationSelector: function(value: T)),只有在另一个 Observable 决定的一段特定时间经过后并且没有发出另一个源值之后，才从源 Observable 中发出一个值,但是静默时间段由第二个 Observable 决定这个操作符会追踪源 Observable 的最新值, 并通过调用 durationSelector 函数来生产 duration Observable。只有当 duration Observable 发出值或完成时，才会发出值，如果源 Observable 上没有发 出其他值，那么 duration Observable 就会产生 var clicks = Rx.Observable.fromEvent(document, &apos;click&apos;); var result = clicks.debounce(() =&gt; Rx.Observable.interval(1000)); result.subscribe(x =&gt; console.log(x)); throttleTime从源 Observable 中发出一个值，然后在 duration 毫秒内忽略随后发出的源值， 然后重复此过程 let obj = Observable.interval(1000); this.subject = obj.throttleTime(5000) .subscribe(v =&gt; {this.valueList.push(v);}); //输出 0 5 10 15 ... throttle从源 Observable 中发出一个值，然后在由另一个 Observable 决定的期间内忽略 随后发出的源值，然后重复此过程 像throttleTime，但是沉默持续时间是由 第二个 Observable 决定的 firstfirst(predicate: function, resultSelector: function),只发出由源 Observable 所发出的值中第一个(或第一个满足条件的值)predicate: 可选函数，用于测试是否符合条件resultSelector(value: T, index: number):基于源 Observable 的值和索引来生成输出 Observable 的值 let obj = Observable.interval(1000); this.subject = obj.first() .subscribe(v =&gt; {this.valueList.push(v);}); //输出 0 this.subject = obj.first(x =&gt; x!== 0 &amp;&amp; x%5 == 0) .subscribe(v =&gt; {this.valueList.push(v);}); //输出 5 this.subject = obj.first((x) =&gt; {return x!== 0 &amp;&amp; x%5 == 0;},(value,index) =&gt; {return value*10;}) .subscribe(v =&gt; {this.valueList.push(v);}); //输出 50 lastlast(predicate: function),只发出由源 Observable 所发出的值中最后一个(或最胡=后一个满足条件的值)，用法同first skipLastskipLast(count: number),跳过源 Observable 最后发出的的N个值 4) 组合zipzip(observable,observable,..),将多个 Observable 组合以创建一个，该 Observable的值是由所有输入 Observables 的值按顺序计算而来的如果最后一个参数是函数, 这个函数被用来计算最终发出的值.否则, 返回一个顺序包含所有输入值的数组 let obj1 = Observable.of&lt;number&gt;(12,13,14); let obj2 = Observable.of&lt;string&gt;(&apos;AA&apos;,&apos;BB&apos;,&apos;CC&apos;); this.subject = Observable.zip(obj1,obj2) .subscribe(v =&gt; {this.valueList.push(v);}); //输出 [12,&apos;AA&apos;] -&gt; [13,&apos;BB&apos;] -&gt; [13,&apos;CC&apos;] this.subject = Observable.zip(obj1,obj2,(a,b) =&gt; {return a+&apos;@&apos;+b}) .subscribe(v =&gt; {this.valueList.push(v);}); //输出 12@AA -&gt; 13@BB -&gt; 13@CC forkJoinforkJoin(Observable,Observable,…),等待源对象都完成后才输出目标Observable let obj1 = Observable.of&lt;number&gt;(12,13,14); let obj2 = Observable.of&lt;string&gt;(&apos;AA&apos;,&apos;BB&apos;,&apos;CC&apos;); this.subject = Observable.forkJoin(obj1,obj2) .subscribe(data =&gt; {this.valueList.push(data);}); //输出：data[0] = obj1;data[2] = obj2; combineLatestcombineLatest(Observables,function),组合多个 Observables 来创建一个 Observable ，该 Observable 的值根据每个输入 Observable 的最新值计算得出的其中： Observables是将要和源 Observable结合的输入Observable， function是可选的投射函数，将输出 Observable 返回的值投射为要发出的新的值 例子： var timer1 = Observable.interval(1000).take(3); var timer3 = Observable.interval(600).take(5); this.subject = timer1. combineLatest(timer3).subscribe(v =&gt; {this.valueList.push(v);}); timer1 0 1 2 timer3 0 1 2 3 4 输出：0,0 0,1 0,2 1,2 1,3 2,3 2,4 this.subject = timer1. combineLatest(timer3,(x,y) =&gt; x*10 + y).subscribe(v =&gt; {this.valueList.push(v);}); 输出：0 1 2 12 13 23 24 startWithstartWith(s),返回的 Observable 会先发出s项，然后再发出由源 Observable 所发出的项 源Observable的数据类型必须和入参s类型一致 var timer1 = Observable.of(&apos;a&apos;,&apos;b&apos;,&apos;c&apos;); this.subject = timer1.startWith(&apos;fff&apos;).subscribe(v =&gt; {this.valueList.push(v);}); 输出：fff a b c var timer1 = Observable.of(1,2,3); this.subject = timer1.startWith(999).subscribe(v =&gt; {this.valueList.push(v);}); 输出：999 1 2 3 5) 多播multicast publish 6) 错误处理catchcatch(selector: function),捕获 observable 中的错误，可以通过返回一个新的 observable 或者抛出错误对象来处理 Observable.of(1, 2, 3, 4, 5).map(n =&gt; { if (n == 4) { throw &apos;four!&apos;; } return n; }) .catch(err =&gt; { throw &apos;error in source. Details: &apos; + err; }) .subscribe( x =&gt; console.log(x), err =&gt; console.log(err) ); //输出：1, 2, 3, error in source. Details: four! retryretry(count: number)，返回一个 Observable， 该 Observable 是源 Observable 不包含错误异常的镜像。 如果源 Observable 发生错误, 这个方法不会传播错误而是会不 断的重新订阅源 Observable 直到达到最大重试次数：count 7) 条件delaydelay(number|Date),通过给定的超时或者直到一个给定的日期来延迟源 Observable 的发送 let obj = Observable.interval(1000); this.subject = obj.delay(5000) .subscribe(v =&gt; {this.valueList.push(v);}); //输出不变，只是延时5s发射 this.subject = obj.delay(ew Date(&apos;March 15, 2020 12:00:00&apos;)) .subscribe(v =&gt; {this.valueList.push(v);}); //输出不变，直到设定的事件日期时才发射 delayWhendelayWhen(delayDurationSelector: function(value: T): Observable, subscriptionDelay: Observable),在给定的时间范围内，延迟源 Observable 所有数据项的发送，该时间段由另一个 Observable 的发送决定,延时的时间间隔由第二个Observable决定 do给定一些 Observer 的回调函数， 将当前 Notification 所表示的值正确的传递给相应的回调函数 var value = 0; Observable.of(1,2,3).do(x =&gt; value += x;}).subscribe(); //value = 6 Observable.of(1,2,3).do(x =&gt; console.log(x)}).subscribe(); toArray输出数组 let obj = Observable.of(1,2,3,4,5,6,7,8); this.subject = obj.toArray() .subscribe(v =&gt; {this.valueList.push(v);}); //输出 [1,2,3,4,5,6,7,8] toPromise将 Observable 序列转换为符合 ES2015 标准的 Promise Rx.Observable.toPromise() .then((value) =&gt; console.log(&apos;Value: %s&apos;, value)) .catch((err) =&gt; console.log(&apos;Error: %s&apos;, err)); 工具defaultIfEmptydefaultIfEmpty(defaultValue: any)，如果源 Observable 在完成之前没有发出任何 next 值，则发出给定的值，否则返回 Observable 的镜像 everyevery(predicate: function),发出是否源 Observable 的每项都满足指定的条件,是则返回true,否则false let obj = Observable.of(1,2,3,4,5,6,7,8); this.subject = obj.every(x =&gt; x &lt; 8) .subscribe(v =&gt; {this.valueList.push(v);}); //输出 false this.subject = obj.every(x =&gt; x &lt; 10) .subscribe(v =&gt; {this.valueList.push(v);}); //输出 true findfind(predicate: function(value: T, index: number, source: Observable),只发出源 Observable 所发出的值中第一个满足条件的值 let obj = Observable.of(1,2,3,4,5,6,7,8); this.subject = obj.find(x =&gt; x%4 == 0) .subscribe(v =&gt; {this.valueList.push(v);}); //输出 4 findIndex同find,发出源 Observable 所发出的值中第一个满足条件的值的索引 let obj = Observable.of(1,2,3,4,5,6,7,8); this.subject = obj.findIndex(x =&gt; x%4 == 0) .subscribe(v =&gt; {this.valueList.push(v);}); //输出 3 isEmptyisEmpty(),如果源 Observable 是空的话，它返回一个发出 true 的 Observable，否则发出 false let obj = Observable.of(1,2,3,4,5,6,7,8); this.subject = obj.isEmpty() .subscribe(v =&gt; {this.valueList.push(v);}); //输出 false 数学countcount(predicate: function),发出源值的个数或满足函数条件的值个数 let obj = Observable.of(1,2,3,4,5,6,7,8); this.subject = obj.count() .subscribe(v =&gt; {this.valueList.push(v);}); //输出：8 this.subject = obj.count(x =&gt; x%2 == 0) .subscribe(v =&gt; {this.valueList.push(v);}); //输出：4 maxmax(comparer: Function),当源 Observable 完成时它发出单一项：最大值的项 Observable.of(5, 4, 7, 2, 8) .max() .subscribe(x =&gt; console.log(x)); //输出： 8 Observable.of&lt;any&gt;({age: 7, name: &apos;Foo&apos;}, {age: 5, name: &apos;Bar&apos;}, {age: 9, name: &apos;Beer&apos;}) .max&lt;any&gt;((a: any, b: any) =&gt; a.age &lt; b.age ? -1 : 1) .subscribe(x =&gt; console.log(x.name+&apos;@&apos;+x.age)); //输出：Beer@9 minmin(comparer: Function),当源 Observable 完成时它发出单一项：最小值的项 Observable.of&lt;any&gt;({age: 7, name: &apos;Foo&apos;}, {age: 5, name: &apos;Bar&apos;}, {age: 9, name: &apos;Beer&apos;}) .min&lt;any&gt;( (a: any, b: any) =&gt; a.age &lt; b.age ? -1 : 1) .subscribe(x =&gt; console.log(x.name+&apos;@&apos;+x.age)); //输出：Bar@5 reducereduce(accumulator: function, seed),在源 Observalbe 上应用 accumulator (累加器) 函数，然后当源 Observable 完成时，返回 累加的结果，可以提供一个可选的 seed初始值 let obj = Observable.of(1,2,3,4,5,6,7,8); this.subject = obj.reduce((x,y) =&gt; x+y,0) .subscribe(v =&gt; {this.valueList.push(v);}); //输出：36","tags":[{"name":"rxjs","slug":"rxjs","permalink":"http://blueskyawen.com/tags/rxjs/"}]},{"title":"Rxjs-响应式流编程","date":"2017-12-24T11:00:33.000Z","path":"2017/12/24/rxjs/","text":"前端数据处理主要是异步的，来源于：用户操作，后台数据交互，定时处理等 Promise承诺promise是传统的异步数据处理方法，在业界广泛使用，主要使用方式： function getData() { return new Promise(Data); } getData().then((res) =&gt; { callback(res); }); 但是基于承诺的数据处理有诸多问题，比如： 一次只能处理一个请求，连续多个数据的时候处理困难 无失败重试 不能请求取消 但是由于它能处理大部分的数据且用法简单，所以仍是使用最多的 RXJSrxjs作为新的数据处理方式，可替代常用的promise/callback等，因为它拥有它们的粗里能力，同时也有新的其他方式所不及的能力rxjs能处理的数据包括：http请求，event事件回调，读取文件，用户操作，点击事件等等 1. 基本知识rxjs是数据流处理工具，在它看来，万物皆为流或者可转化为流来处理，流可以连续处理，可以截断，也可以进行转换，所以rxjs是对变化进行响应的响应式编程模式，主要有如下特点： 面向数据流的变化与传播 函数式编程，链式调用 迭代器式编程，遍历机制 观察者模式 声明式编程 2. 组成部分RxJS 是一个库，它通过使用 observable 序列来编写异步和基于事件的程序。它提供了一个核心类型 Observable，附属类型 (Observer、 Schedulers、 Subjects) 和受 [Array#extras] 启发的操作符 (map、filter、reduce、every, 等等)，这些数组操作符可以把异步事件作为集合来处理。 Observable: 被观察者，也称为观察对象/数据生产者/数据流容器 Observer: 观察者，也称为数据流消费者 operators: 数据流操作动作 subscribe: 数据流订阅符 Subject: 发射数据给多个observer的Observable 1. ObservableObservable可以处理或包装处理同和异步的数据流，是数据流的生产者，产生的它的方式有很多，任何数据都可以包装成可观察对象来处理： //单值 var obj = Observable.of(2017); //多值 var obj = Observable.from([1,2,3,4,5]) or Observable.of(1,2,3,4,5); //promise var g = new Promise(...); var obj = Observable.fromPromise(g); //new var obj = new Observable(observer =&gt; {}); //create var obj = Rx.Observable.create(observer =&gt; { observer.next(); observer.error(); observer.complete(); }); //来自事件 var obj = Rx.Observable.fromEvent(dom,&apos;keyup&apos;); 例子： let obj = Rx.Observable.create(observer =&gt; { console.log(&apos;AAA&apos;); observer.next(22); }); obj.subscribe(x =&gt; console.log(&apos;a_&apos;+x)); obj.subscribe(y =&gt; console.log(&apos;b_&apos;+y)); 结果： AAA a_22 AAA b_22 可以把obj想象成一个函数，你每次调用obj都会导致传入Rx.Observable.create里的回调函数重新执行一次, 调用的方式为obj.subscribe(callback), 相当于obj() observer.next表示返回一个值, 你可以调用多次，每次调用observer.next后， 会先将next里的值返回给obj.subcribe里的回调函数, 执行完后再返回 Observable类似于函数，但又不同于回调函数，Observable可发射多个值，而函数每次只能返回一个 Observable可同步或异步推送数据给观察者，而观察者只是从数据生产者拉取数据，不关心是否同步 observer的next,complete, error可以用来来控制流程，比如: var observable = Rx.Observable.create(observer =&gt; { try { console.log(&apos;AAA&apos;); observer.next(11); observer.next(22); observer.complete(); observer.next(33); } catch (err) { observer.error(err); } }); let subcription = observable.subscribe(res =&gt; { console.log(‘a_’+res); }) 结果： AAA a_11 a_22 可以看到， observable的next(22)有效，而next(33)无效了，因为complete（）在其之前调用，阻止了值的发射 Observable可以连续发射和处理多个值，这是和Promise不同的地方，Promise只能通过链接的then()来实现 当observable的执行出现异常的时候，通过observer.error将错误返回, 而observable.subscribe的回调函数无法接收到错误 2. Observer对象观察者，数据消费者，即对Observable的数据流进行处理，通常不直接构造这个对象，而是在观察对象被订阅调用时创建这个对象，它有三个方法： class Observer { next(data) { //正常数据的反射出路 } error(data) { //错误处理 } complete(data) { //手动停止数据发射 } } 比如： var obj = Rx.Observable.create(observer); obj.subscribe(callback(res)); 其中回调函数callback(res)就是观察者，只不过实际运行时是将它内部转变成oberver对象来处理： oo = new observer() { next(value) {callback(value);} error(error) {..} complete() {} } Rx.Observable.create(oo); 就这样回调函数被封装成观察者对象来进行数据处理，举个更简单的例子： var observable = Observable.of([1,2,3]); observable.subscribe( (res) =&gt; {console.log(&apos;AB&apos;+res);}， （error）=&gt; {console.log(&apos;Error&apos;+error);} ); 回调函数封装： observer = { next(v) =&gt; { console.log(&apos;AB-&apos;+v); } error(v) =&gt; { console.log(&apos;Error&apos;+v); } complete(v) =&gt; { ... } } 由observer来对被观察对象的数据流进行处理，结果如下： AB-1 AB-2 AB-3 由于观察者实例一般只有在订阅调用时被创建，所以就容易理解我们的“冷模式”了，只有订阅被调用时才有效 3. subscribe当调用了 observable.subscribe ，观察者会被附加到新创建的 Observable 执行中。这个调用还返回一个对象，即 Subscription (订阅)： var subscription = observable.subscribe(x =&gt; console.log(x)); Subscription 表示进行中的执行，它有最小化的 API 以允许你取消执行。想了解更多订阅相关的内容，请参见 Subscription 类型。使用 subscription.unsubscribe() 你可以取消进行中的执行： var observable = Rx.Observable.from([10, 20, 30]); var subscription = observable.subscribe(x =&gt; console.log(x)); // 稍后： subscription.unsubscribe(); 当你订阅了 Observable，你会得到一个 Subscription ，它表示进行中的执行。只要调用 unsubscribe() 方法就可以取消执行，否则会造成内存泄漏; Subscription 还可以合在一起，这样一个 Subscription 调用 unsubscribe() 方法，可能会有多个 Subscription 取消订阅 。你可以通过把一个 Subscription 添加到另一个上面来做这件事： var observable1 = Rx.Observable.interval(400); var observable2 = Rx.Observable.interval(300); var subscription = observable1.subscribe(x =&gt; console.log(&apos;first: &apos; + x)); var childSubscription = observable2.subscribe(x =&gt; console.log(&apos;second: &apos; + x)); subscription.add(childSubscription); setTimeout(() =&gt; { // subscription 和 childSubscription 都会取消订阅 subscription.unsubscribe(); }, 1000); 结果： second: 0 first: 0 second: 1 first: 1 second: 2 Subscriptions 还有一个 remove(otherSubscription) 方法，用来撤销一个已添加的子 Subscription 取消订阅只是对数据流停止处理，并不能阻止数据的流动 4. operators操作符分为实例操作符和静态操作符： 实例操作符： 作用于对象实例，比如map，switch 静态操作符: 属于Observable的静态方法，必须通过Observable来调用，比如：forkJoin() 操作符对Observable对像的动作是纯的高阶函数，不会改变当前的对象，而是操作完返回一个新的Observable对象;这样可以供其他操作符处理，形成链式操作Observable的操作符很多，详细可参考官网：Rxjs-opertors 转换操作： 改变数据形态：map, mapTo, pluck 过滤一些值：filter, skip, first, last, take 时间轴上的操作：delay, timeout, throttle, debounce, audit, bufferTime 累加：reduce, scan 异常处理：throw, catch, retry, finally 条件执行：takeUntil, delayWhen, retryWhen, subscribeOn, ObserveOn 转接：switch 对若干个数据流进行组合： concat，保持原来的序列顺序连接两个数据流 merge，合并序列 race，预设条件为其中一个数据流完成 forkJoin，预设条件为所有数据流都完成 zip，取各来源数据流最后一个值合并为对象 combineLatest，取各来源数据流最后一个值合并为数组 1)自己实现一个operators： function multiplyByTen(input) { var output = Rx.Observable.create(function subscribe(observer) { input.subscribe({ next: (v) =&gt; observer.next(10 * v), error: (err) =&gt; observer.error(err), complete: () =&gt; observer.complete() }); }); return output; } var input = Rx.Observable.from([1, 2, 3, 4]); var output = multiplyByTen(input); output.subscribe(x =&gt; console.log(x)); 结果： 10 20 30 40 2) 数据流处理RxJS一个很强大的特点是，它以流的方式来对待数据，因此，可以用一些操作符对整个流上所有的数据进行延时、取样、调整密集度等等。 const timeA$ = Observable.interval(1000) const timeB$ = timeA$.filter(num =&gt; { return (num % 2 != 0) &amp;&amp; (num % 3 != 0) &amp;&amp; (num % 5 != 0) &amp;&amp; (num % 7 != 0) }) const timeC$ = timeB$.debounceTime(3000) const timeD$ = timeC$.delay(2000) 示例代码中，我们创建了四个流：A是由定时器产生的，每秒一个值B从A里面过滤掉了一些C在B的基础上，对每两个间距在3秒之内的值进行了处理，只留下后一个值D把C的结果整体向后平移了2秒 所以结果大致如下： A: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 B: 1 11 13 17 19 C: 1 13 19 D: 1 13 3) 数据流处理 5. SubjectSubject是一种能够发射数据给多个observer的Observable, 在 Subject 的内部，subscribe 不会调用发送值的新执行。它只是将给定的观察者注册到观察者列表中，类似于其他库或语言中的 addListener 的工作方式,例子： var subject = new Rx.Subject(); subject.subscribe({ next: (v) =&gt; console.log(&apos;observerA: &apos; + v) }); subject.subscribe({ next: (v) =&gt; console.log(&apos;observerB: &apos; + v) }); subject.next(1); subject.next(2); 结果： observerA: 1 observerB: 1 observerA: 2 observerB: 2 可以看到 与Observable不同的是， Subject发射数据给多个observer 义subject的时候并没有传入callback， 这是因为subject自带next, complete, error等方法，从而可以发射数据给observer observer只需要订阅处理数据即可，而并不关心数据来源是哪里Subject有各种特性不同的派生子类： BehaviorSubject，能够保留最近的数据，使得当有subscribe的时候，立马发射出去 ReplaySubject，能够保留最近的一些数据， 使得当有subscribe的时候，将这些数据发射出去 AsyncSubject，只会发射结束前的一个数据 既然subject有next, error, complete三种方法， 那subject就可以作为observer来使用，比如： var subject = new Rx.Subject(); subject.subscribe({ next: (v) =&gt; console.log(&apos;AA: &apos; + v) }); subject.subscribe({ next: (v) =&gt; console.log(&apos;BB: &apos; + v) }); var observable = Rx.Observable.from([1, 2, 3]); observable.subscribe(subject); 输出结果： AA: 1 BB: 1 AA: 2 BB: 2 AA: 3 BB: 3 也就是说， observable.subscribe可以传入一个subject来订阅其消息，这就好像是Rxjs中的一颗语法糖 3. rxjs在angular里的使用angular是推荐使用rxjs进行http访问和其他的数据交互的，angular自身封装的Http服务返回的数据就是Observable对象，我们可以方便的运行rxjs的相关知识进行操作处理简单的例子： getData() { this.http.getAll(url).map((res) =&gt; {return res.json();}) .catch(this.handleError) } handleError(error) { console.error(error.msg); Observable.throw(error.msg); } //使用 this.serve.getData().subscribe( res =&gt; { this.data = res; } error =&gt; { alert(error); } ); 4. rxjs使用(1) 补丁方式 npm install rxjs 导入整个核心功能集： import Rx from &apos;rxjs/Rx&apos;; Rx.Observable.of(1,2,3) 通过打补丁的方式只导入所需要的(这对于减少 bundling 的体积是十分有用的)： import { Observable} from &apos;rxjs/Observable&apos;; import &apos;rxjs/add/observable/of&apos;; import &apos;rxjs/add/operator/map&apos;; Observable.of(1,2,3).map(x =&gt; x + &apos;!!!&apos;); // 等等 只导入需要的并且使用被提议的绑定操作符： 注意：这个额外的预发需要编译器支持并且此语法可能会在没有任何通知的情况下完全从 TC39 撤回！要使用的话需要你自己来承担风险。 import { Observable } from &apos;rxjs/Observable&apos;; import { of } from &apos;rxjs/observable/of&apos;; import { map } from &apos;rxjs/operator/map&apos;; Observable::of(1,2,3)::map(x =&gt; x + &apos;!!!&apos;); // 等等 （2）nodejs脚本使用导入所有核心功能: var Rx = require(&apos;rxjs/Rx&apos;); Rx.Observable.of(1,2,3); // 等等 通过打补丁的方式只导入所需要的(这对于减少 bundling 的体积是十分有用的)： var Observable = require(&apos;rxjs/Observable&apos;).Observable; // 使用适合的方法在 Observable 上打补丁 require(&apos;rxjs/add/observable/of&apos;); require(&apos;rxjs/add/operator/map&apos;); Observable.of(1,2,3).map(function (x) { return x + &apos;!!!&apos;; }); 导入操作符并手动地使用它们(这对于减少 bundling 的体积也十分有用)： var of = require(&apos;rxjs/observable/of&apos;).of; var map = require(&apos;rxjs/operator/map&apos;).map; map.call(of(1,2,3), function (x) { return x + &apos;!!!&apos;; }); （3）Observable在angular中的应用通过Observable的特点和丰富的操作符，Observable可替代解决各种异步和同步的数据处理场景，比如：http请求处理，事件，数组，路由器参数等通常，Observable 可以在一段时间内返回多个值。 但来自 HttpClient 的 Observable 总是发出一个值，然后结束，再也不会发出其它值。","tags":[{"name":"rxjs","slug":"rxjs","permalink":"http://blueskyawen.com/tags/rxjs/"}]},{"title":"Angular-路由器守卫","date":"2017-12-01T14:11:34.000Z","path":"2017/12/01/router-guard/","text":"路由守卫，顾名思义，是守护路由的导航激活，在路由激活之前进行逻辑判断和数据处理;比如：路由权限的判断，表单填写丢弃的询问，以及路由激活前数据额预加载..等等，都是守卫干的工作，下面会根据使用场景不同介绍几种守卫的实现 路由激活守卫CanActivate守卫，用于对某个页面导航的守卫，在导航前可以作逻辑判断，比如：是否有访问权限，来判断是否激活这个路由来查看页面主要步骤有： 封装服务，实现CanActivate接口，返回true，则允许激活;否则，不允许激活 注入服务到对应模块，在路由配置中添加对于服务 路由守卫一般用于守护一类特性路由的集合 定义守卫服务：实现CanActivate守卫接口，判断是否登录;若已登录,则返回true,激活路由;否则，则返回flase，无法激活路由并返回登录首页 import { Injectable } from &apos;@angular/core&apos;; import {CanActivate, Router,ActivatedRouteSnapshot,RouterStateSnapshot} from &apos;@angular/router&apos;; import { AuthService } from &apos;./auth.service&apos;; @Injectable() export class AuthGuard implements CanActivate { constructor(private authService: AuthService, private router: Router) {} canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): boolean { let url: string = state.url; if (this.authService.isLoggedIn) { return true; } else { this.authService.redirectUrl = url; this.router.navigate([&apos;/login&apos;]); return false; } } } const adminRoutes: Routes = [ { path: &apos;admin&apos;, component: AdminComponent, canActivate: [AuthGuard], children: [ { { path: &apos;crises&apos;, component: ManageCrisesComponent }, { path: &apos;heroes&apos;, component: ManageHeroesComponent } } ] } ]; 子路由激活守卫在前面路由守卫是守护一类特性路由的集合，由于守卫只会检测自身守护的对应路由参数有无变化，当子路由参数变化的时候是不会检测到的，比如上文的那个例子对于以下的url组是可以检测的： /main/admin/../.. /main/heros/../.. 但是一旦对应的参数固定后便检测不到，页面可以访问，比如下面这些路由： /main/admin/add /main/admin/cers /main/admin/cers/detail 这明显不是被希望的，于是便有了子路由守卫，对子路由进行守护CanAcitvateChild守卫，用于对某个子页面导航的守卫，在导航前可以作逻辑判断，比如：是否有访问权限，来判断是否激活这个路由来查看页面，实现与上面类似 import { Injectable } from &apos;@angular/core&apos;; import {CanActivate, Router,ActivatedRouteSnapshot, RouterStateSnapshot,CanActivateChild} from &apos;@angular/router&apos;; import { AuthService } from &apos;./auth.service&apos;; @Injectable() export class AuthGuard implements CanActivate, CanActivateChild { constructor(private authService: AuthService, private router: Router) {} canActivateChild(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): boolean { let url: string = state.url; if (this.authService.isLoggedIn) { return true; } else { this.authService.redirectUrl = url; this.router.navigate([&apos;/login&apos;]); return false; } } /* . . . */ } const adminRoutes: Routes = [ { path: &apos;admin&apos;, component: AdminComponent, children: [ { path: &apos;&apos;, canActivateChild: [AuthGuard], children: [ { path: &apos;crises&apos;, component: ManageCrisesComponent }, { path: &apos;heroes&apos;, component: ManageHeroesComponent }, { path: &apos;&apos;, component: AdminDashboardComponent } ] } ] } ]; 表单去激活守卫CanDeactivate守卫，用于在填写表单时路由离开时使用，可进行判断是否离开，并进行一些数据处理 封装服务，实现CanDeactivate接口，实现逻辑判断，返回true，则允许去激活，直接导航出去;否则，不允许激活，一般会以弹框询求确定 注入服务到对应模块，在路由配置中添加对于服务 去激活守卫有两种实现方式：公共方式和特有组件方式 1）公共方式 封装公共服务实现CanDeactivate接口，接受具体组件类的方法调用;各个需要使用的组件实现CanDeactivate方法即可 dialog.ts import &apos;rxjs/add/observable/of&apos;; import { Injectable } from &apos;@angular/core&apos;; import { Observable } from &apos;rxjs/Observable&apos;; /** * Async modal dialog service * DialogService makes this app easier to test by faking this service. * TODO: better modal implementation that doesn&apos;t use window.confirm */ @Injectable() export class DialogService { /** * Ask user to confirm an action. `message` explains the action and choices. * Returns observable resolving to `true`=confirm or `false`=cancel */ confirm(message?: string): Observable&lt;boolean&gt; { const confirmation = window.confirm(message || &apos;Is it OK?&apos;); return Observable.of(confirmation); }; } deactive-guard.service import { Injectable } from &apos;@angular/core&apos;; import { CanDeactivate } from &apos;@angular/router&apos;; import { Observable } from &apos;rxjs/Observable&apos;; export interface CanComponentDeactivate { canDeactivate: () =&gt; Observable&lt;boolean&gt; | Promise&lt;boolean&gt; | boolean; } @Injectable() export class CanDeactivateGuard implements CanDeactivate&lt;CanComponentDeactivate&gt; { canDeactivate(component: CanComponentDeactivate) { return component.canDeactivate ? component.canDeactivate() : true; } } 具体组件内实现canDeactivate方法： export class TemplateFormComponent { name : any; password : any; constructor(public dialogService : DialogService) { } canDeactivate(): Observable&lt;boolean&gt; | boolean { if (!this.name &amp;&amp; !this.password) { return true; } return this.dialogService.confirm(&apos;已有修改未保存，确定离开吗?&apos;); } } 路由配置 const appRoutes: Routes = [ { path: &apos;templateForm&apos;, component: TemplateFormComponent, canDeactivate: [CanDeactivateGuard]} ]; 2）特定方式 即为具体组件实现对于的服务，注入特定组件的实例来进行逻辑判断 import { Injectable } from &apos;@angular/core&apos;; import { Observable } from &apos;rxjs/Observable&apos;; import { CanDeactivate, ActivatedRouteSnapshot, RouterStateSnapshot } from &apos;@angular/router&apos;; import { TemplateFormComponent } from &apos;./template-form/template-form.component&apos;; @Injectable() export class CanDeactivateGuard2 implements CanDeactivate&lt;TemplateFormComponent&gt; { canDeactivate( component: TemplateFormComponent, route: ActivatedRouteSnapshot, state: RouterStateSnapshot ): Observable&lt;boolean&gt; | boolean { console.log(state.url); if (!component.name &amp;&amp; !component.password) { return true; } return component.dialogService.confirm(&apos;已有修改未保存，确定离开吗?&apos;); } } //路由 const appRoutes: Routes = [ { path: &apos;templateForm&apos;, component: TemplateFormComponent, canDeactivate: [CanDeactivateGuard2]} ]; 数据预加载预加载，顾名思义，就是在路由激活前对路由模板组件所需要的数据进行预先的获取，这样在路由激活展现时数据就已经有了，提高体验;而且，对于加载失败的情况也能作相应处理 封装服务，实现Resolve接口，进行数据获取，获取成功，返回结果Data，继续激活路由;否则，不允许激活，一般会导航到首页 注入服务到对应模块，在路由配置中添加对应服务 组件使用时，直接使用路由保存的data 封装服务： import { Injectable } from &apos;@angular/core&apos;; import { Observable } from &apos;rxjs/Observable&apos;; import { Router, Resolve, RouterStateSnapshot, ActivatedRouteSnapshot } from &apos;@angular/router&apos;; import { Crisis, CrisisService } from &apos;./crisis.service&apos;; @Injectable() export class DataResolver implements Resolve&lt;User&gt; { constructor(private userService: UserService, private router: Router) {} resolve(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable&lt;Crisis&gt; { return this.userService.getUser(id).map(res =&gt; { if (res) { return res; } else { this.router.navigate([&apos;/login&apos;]); return null; } }); } } 配置路由： const appRoutes: Routes = [ { path: &apos;templateForm&apos;, component: TemplateFormComponent, canDeactivate: [CanDeactivateGuard]， resolve： { user: DataResolver } ]; 组件使用： export class TemplateFormComponent { name : any; user : any; constructor(public dialogService : DialogService,private route: ActivatedRoute) { this.route.data .subscribe((data: { user: any }) =&gt; { this.user = data.user; }); } } 模块访问守卫CanLoad守卫，对懒加载模块的加载限制，加载前进行逻辑处理，满足条件才加载该模块 封装服务，实现CanLoad接口，进行逻辑判断，若返回true，则加载模块并路由;否则，不再加载 注入服务到对应模块，在路由配置中添加对应服务 封装服务： import { Injectable } from &apos;@angular/core&apos;; import { Router, ActivatedRouteSnapshot, RouterStateSnapshot, CanLoad,Route } from &apos;@angular/router&apos;; import { appService } from &apos;./app.service&apos;; @Injectable() export class AuthGuard implements CanLoad { constructor(private appS: appService, private router: Router) {} canLoad(route: Route): boolean { let url = `/${route.path}`; if (this.appS.isLogin) { return true; } this.appS.redirectUrl = url; this.router.navigate([&apos;/controls&apos;]); return false; } } 配置路由： const appRoutes: Routes = [ { path: &apos;controls&apos;, component: ControlComponent }, { path: &apos;reactiveForm&apos;, loadChildren: &apos;app/reactive-form/reactive-form.module#ReactiveModule&apos;, canLoad: [AuthGuard] } ]; 模块预加载在每次成功的导航后，路由器会在自己的配置中查找尚未加载并且可以预加载的模块。 是否加载某个模块，以及要加载哪些模块，取决于预加载策略。Router内置了两种预加载策略： 完全不预加载，这是默认值。惰性加载的特性区仍然会按需加载。 预加载所有惰性加载的特性区。 默认情况下，路由器或者完全不预加载或者预加载每个惰性加载模块。 路由器还支持自定义预加载策略，以便完全控制要预加载哪些模块以及何时加载。 1) 预加载所有模块 只需在根路由模块的forRoot方法传入附加参数即可，将加载策略设置preloadingStrategy设置为PreloadAllModules import { NgModule } from &apos;@angular/core&apos;; import { RouterModule, Routes, PreloadAllModules } from &apos;@angular/router&apos;; import { ControlComponent } from &apos;./control/control.component&apos;; import { TemplateFormComponent } from &apos;./template-form/template-form.component&apos;; import { CanDeactivateGuard } from &apos;./can-deactivate-guard.service&apos;; import { CanDeactivateGuard2 } from &apos;./can-deactivate-guard2.service&apos;; import { AuthGuard } from &apos;./auth-guard.service&apos;; const appRoutes: Routes = [ { path: &apos;controls&apos;, component: ControlComponent }, { path: &apos;templateForm&apos;, component: TemplateFormComponent, canDeactivate: [CanDeactivateGuard2]}, { path: &apos;reactiveForm&apos;, loadChildren: &apos;app/reactive-form/reactive-form.module#ReactiveModule&apos;, canLoad: [AuthGuard] }, { path: &apos;login&apos;, loadChildren: &apos;app/login/login.module#LoginModule&apos; }, { path: &apos;&apos;, redirectTo: &apos;/controls&apos;, pathMatch: &apos;full&apos; } ]; @NgModule({ imports: [ RouterModule.forRoot(appRoutes, { enableTracing: true, preloadingStrategy: PreloadAllModules }) ], exports: [ RouterModule ] }) 加载策略只能在根路由模块里设置，因为只有forRoot()可以配置参数，forChild()不行 CanLoad守卫级别高于策略，会阻塞模块加载 2） 自定义加载策略 使用自定义预加载策略，可以控制路由器预加载哪些路由以及如何加载，作为例子，我们将只预加载那些data.preload标志为true的路由 设置路由标识，标识哪些模块被预先加载 定义策略服务，根据标识来判断并加载模块 配置策略服务到路由模块 策略服务 import &apos;rxjs/add/observable/of&apos;; import { Injectable } from &apos;@angular/core&apos;; import { PreloadingStrategy, Route } from &apos;@angular/router&apos;; import { Observable } from &apos;rxjs/Observable&apos;; @Injectable() export class SelectivePreloadingStrategy implements PreloadingStrategy { preloadedModules: string[] = []; preload(route: Route, load: () =&gt; Observable&lt;any&gt;): Observable&lt;any&gt; { if (route.data &amp;&amp; route.data[&apos;preload&apos;]) { // add the route path to the preloaded module array this.preloadedModules.push(route.path); // log the route path to the console console.log(&apos;Preloaded: &apos; + route.path); return load(); } else { return Observable.of(null); } } } 策略配置 const appRoutes: Routes = [ { path: &apos;controls&apos;, component: ControlComponent }, { path: &apos;templateForm&apos;, component: TemplateFormComponent, canDeactivate: [CanDeactivateGuard2]}, { path: &apos;reactiveForm&apos;, loadChildren: &apos;app/reactive-form/reactive-form.module#ReactiveModule&apos;, data: {Preloaded: false} }, { path: &apos;login&apos;, loadChildren: &apos;app/login/login.module#LoginModule&apos;, data: {Preloaded: true} }, { path: &apos;&apos;, redirectTo: &apos;/controls&apos;, pathMatch: &apos;full&apos; } ]; @NgModule({ imports: [ RouterModule.forRoot(appRoutes, { enableTracing: true, preloadingStrategy: SelectivePreloadingStrategy }) ], exports: [ RouterModule ]， providers: [SelectivePreloadingStrategy] }) export class AppRoutingModule {} 在分层路由的每个级别上，你都可以设置多个守卫。 路由器会先按照从最深的子路由由下往上检查的顺序来检查 CanDeactivate() 和 CanActivateChild() 守卫。 然后它会按照从上到下的顺序检查 CanActivate() 守卫。如果特性模块是异步加载的，在加载它之前还会检查 CanLoad() 守卫。","tags":[{"name":"Augular","slug":"Augular","permalink":"http://blueskyawen.com/tags/Augular/"}]},{"title":"表单-响应式构建表单","date":"2017-11-26T10:09:52.000Z","path":"2017/11/26/reactive-form/","text":"什么是响应式表单响应式表单主要是数据管理的方式不同，它是在类中显式的管理我们的数据流和数据模型，直接操作数据模型进行状态控制。同时，它还以可以直接在组件类中创建表单控件树，并绑定到相应的标签上来构建表单，简单方便。响应式表单有以下特点： 显式的管理数据方式，方便了校验和测试 表单的控件值和有效性状态的更新是同步的，不会有更新时序问题，更易单元测试;而之前的模板驱动表单是更新异步的，存在更新的时序和效率问题，在有些场景下会存在使用瓶颈 由于表单数据模型是自定义的，所以可以根据数据对象的结构来定义结构类似的模型树满足，这样数据更新更方便 基本组成AbstractControl： 三个具体表单类的抽象基类。 并为它们提供了一些共同的行为和属性，其中有些是可观察对象（Observable）。 FormControlDirective/FormControlName : 用于跟踪一个单独的表单控件的值和有效性状态。它对应于一个HTML表单控件，比如输入框和下拉框。请FormControlDirective可单独使用，FormControlName和Group结合使用 FormGroupDirective/FormGroupName : 用于 跟踪一组AbstractControl的实例的值和有效性状态。 该组的属性中包含了它的子控件。 组件中的顶级表单就是一个FormGroup。而FormGroupName在多级group结构使用 FormArray/FormArrayName : 用于跟踪AbstractControl实例组成的有序数组的值和有效性状态。 这些指令都包含在ReactiveFormModule，使用只要包含即可： import { ReactiveFormsModule } from &apos;@angular/forms&apos;; import { FormControl } from &apos;@angular/forms&apos;; @NgModule({ imports: [ ReactiveFormsModule ], declarations: [ AppComponent, FormControl ] } 控件指令的使用上面的指令一般可以单独使用，也可以组合使用，下面描述几种常用的使用场景,为简单标识，我们约定各指令简写： FormGroup – FG FormControl – FC FormArray – FA （1）FormControl单独使用这是最常见的方式，可以使用单独创建formControl并绑定到表单输入框上，而在模板驱动表单里这个是自动创建的.ts import { Component } from &apos;@angular/core&apos;; import { FormControl, Validators } from &apos;@angular/forms&apos;; import { forbiddenNameValidator } from &apos;../forbinden-name.directive&apos;; @Component({ selector: &apos;reactive-form&apos;, templateUrl: &apos;./reactive-form.component.html&apos;, styleUrls: [&apos;../template-form/template-form.component.css&apos;] }) export class ReactiveFormComponent { name : any; constructor() { this.name = new FormControl(&apos;Jack&apos;, [Validators.required, Validators.minLength(4), forbiddenNameValidator(/[@\\$&amp;0-9]/)]); } } .html &lt;form&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;name&quot;&gt;姓名&lt;/label&gt; &lt;div class=&quot;form-right&quot;&gt; &lt;input type=&quot;text&quot; id=&quot;name&quot; [formControl]=&quot;name&quot;/&gt; &lt;/div&gt; &lt;span class=&quot;reqiured&quot;&gt; * &lt;/span&gt; &lt;/div&gt; &lt;/form&gt; &lt;div class=&quot;error&quot; *ngIf=&quot;(!name.pristine || name.dirty) &amp;&amp; name.touched&quot;&gt; &lt;p *ngIf=&quot;name.errors?.required&quot;&gt;Name is requred!!&lt;/p&gt; &lt;p *ngIf=&quot;name.errors?.minlength&quot;&gt;Name length is under 3!!&lt;/p&gt; &lt;p *ngIf=&quot;name.errors?.forbiddenName&quot;&gt;Name can not has @ $ &amp; and number!!&lt;/p&gt; &lt;/div&gt; &lt;p&gt;{{name.value}}&lt;/p&gt; &lt;p&gt;errors:{{name.errors | json}}&lt;/p&gt; 可以看到，我们是在组件类里定义的控件实例，并绑定到控件标签使用：FormControl(初始值，同步校验函数，异步校验函数)表单校验直接使用的是函数形式,多个校验函数组成数据作为实例化入参，我们在模板同样可以像模板驱动表单一样直接额只用name去获取控件的状态和错误信息，用来显示提示其中errors信息值这样的，当输入ja3： { &quot;minlength&quot;: { &quot;requiredLength&quot;: 4, &quot;actualLength&quot;: 3 }, &quot;forbiddenName&quot;: { &quot;value&quot;: &quot;ja3&quot; } } （2）FormControl/FormGroup组合使用主要是多属性组合使用，FG：[FC, FC, … ] import { Component } from &apos;@angular/core&apos;; import { FormControl, Validators, FormGroup } from &apos;@angular/forms&apos;; import { forbiddenNameValidator } from &apos;../forbinden-name.directive&apos;; @Component({ selector: &apos;reactive-form&apos;, templateUrl: &apos;./reactive-form.component.html&apos;, styleUrls: [&apos;../template-form/template-form.component.css&apos;] }) export class ReactiveFormComponent { myForm : any; constructor() { this.myForm = new FormGroup({ name: new FormControl(&apos;Jack&apos;, [Validators.required, Validators.minLength(4), forbiddenNameValidator(/[@\\$&amp;0-9]/)]), password: new FormControl(&apos;&apos;,Validators.required) }); } get name() { return this.myForm.get(&apos;name&apos;);} get password() { return this.myForm.get(&apos;password&apos;);} } &lt;form [formGroup]=&quot;myForm&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;name&quot;&gt;姓名&lt;/label&gt; &lt;div class=&quot;form-right&quot;&gt; &lt;input type=&quot;text&quot; id=&quot;name&quot; formControlName=&quot;name&quot;/&gt; &lt;/div&gt; &lt;span class=&quot;reqiured&quot;&gt; * &lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;error&quot; *ngIf=&quot;(!name.pristine || name.dirty) &amp;&amp; name.touched&quot;&gt; &lt;p *ngIf=&quot;name.errors?.required&quot;&gt;Name is requred!!&lt;/p&gt; &lt;p *ngIf=&quot;name.errors?.minlength&quot;&gt;Name length is under 3!!&lt;/p&gt; &lt;p *ngIf=&quot;name.errors?.forbiddenName&quot;&gt;Name can not has @ $ &amp; and number!!&lt;/p&gt; &lt;/div&gt; &lt;p&gt;{{name.errors | json}}&lt;/p&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;password&quot;&gt;密码&lt;/label&gt; &lt;div class=&quot;form-right&quot;&gt; &lt;input type=&quot;password&quot; id=&quot;password&quot; formControlName=&quot;password&quot;/&gt; &lt;/div&gt; &lt;span class=&quot;reqiured&quot;&gt; * &lt;/span&gt; &lt;/div&gt; &lt;/form&gt; &lt;p&gt;{{myForm.value | json}}&lt;/p&gt; 其中form值为： { &quot;name&quot;: &quot;Jack&quot;, &quot;password&quot;: &quot;&quot; } 还有一些不一样的特点： 跟单独使用不一样，FormControl在标签中的使用为formControlName,用来绑定formGroup里的一个属性 不能再直接使用formControl,而要通过formGroup来获取其他的formControl实例来访问，这里可以声明一个同名getter得到属性实例,然后就可以像单独使用一样访问了 当然，new实例可以使用FormBuilder类替代，上面代码可以改写为： import { Component } from &apos;@angular/core&apos;; import { FormControl, Validators, FormGroup, FormBuilder } from &apos;@angular/forms&apos;; import { forbiddenNameValidator } from &apos;../forbinden-name.directive&apos;; @Component({ selector: &apos;reactive-form&apos;, templateUrl: &apos;./reactive-form.component.html&apos;, styleUrls: [&apos;../template-form/template-form.component.css&apos;] }) export class ReactiveFormComponent { myForm : FormGroup; constructor(private fb : FormBuilder) { this.myForm = this.fb.group({ name: [&apos;Jack&apos;, [Validators.required,Validators.minLength(4),forbiddenNameValidator(/[@\\$&amp;0-9]/)]], password: [&apos;&apos;,Validators.required] }); } get name() { return this.myForm.get(&apos;name&apos;);} get password() { return this.myForm.get(&apos;password&apos;);} } (3) 多级FormGroup主要是多Group和Control嵌套使用，FG：[FC, FG, … ] &lt;form #tForm=&quot;ngForm&quot; (ngSubmit)=&quot;save()&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;姓名&lt;/label&gt; &lt;div class=&quot;form-right&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot; [(ngModel)]=&quot;name&quot; minlength=&quot;3&quot; required [forbiddenName]=&quot;name&quot; #name1=&quot;ngModel&quot;/&gt; &lt;/div&gt; &lt;span class=&quot;reqiured&quot;&gt; * &lt;/span&gt; &lt;/div&gt; &lt;fieldset ngModelGroup=&quot;address&quot; #address=&quot;ngModelGroup&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;国家&lt;/label&gt; &lt;div class=&quot;form-right&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;coun&quot; [(ngModel)]=&quot;address.country&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;城市&lt;/label&gt; &lt;div class=&quot;form-right&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;city&quot; [(ngModel)]=&quot;address.city&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/fieldset&gt; &lt;/form&gt; this.myForm = this.fb.group({ name: [&apos;Jack&apos;, [Validators.required,Validators.minLength(4),forbiddenNameValidator(/[@\\$&amp;0-9]/)]], address: this.fb.group({ country: &apos;&apos;, city: &apos;&apos; }), }); (4) FormControl数组FA：[FC, FC, … ] &lt;form [formGroup]=&quot;myForm&quot; novalidate&gt; &lt;div formArrayName=&quot;skills&quot;&gt; &lt;div class=&quot;form-group&quot; *ngFor=&quot;let skill of skills.controls;let i=index&quot;&gt; &lt;label *ngIf=&quot;i === 0&quot; class=&quot;yes&quot;&gt;技能&lt;/label&gt; &lt;label *ngIf=&quot;i !== 0&quot; class=&quot;no&quot;&gt;&lt;/label&gt; &lt;div class=&quot;form-right&quot;&gt; &lt;input type=&quot;text&quot; [formControlName]=&quot;i&quot; /&gt; &lt;/div&gt; &lt;a (click)=&quot;delSkill(i)&quot; class=&quot;del&quot;&gt; - &lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label class=&quot;no&quot;&gt;&lt;/label&gt; &lt;div class=&quot;add&quot;&gt; &lt;a (click)=&quot;addSkill()&quot;&gt; + &lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; import { Component, OnInit } from &apos;@angular/core&apos;; import { FormControl, Validators, FormGroup, FormBuilder,FormArray } from &apos;@angular/forms&apos;; export class ReactiveFormComponent implements OnInit { myForm : FormGroup; skillList : any[] = [{&apos;value&apos;:&apos;Java&apos;},{&apos;value&apos;:&apos;Scala&apos;}]; constructor(private fb : FormBuilder) { this.myForm = this.fb.group({ skills: this.fb.array([]) }); } ngOnInit() { this.initSkillList(); } initSkillList() { const tempArray = this.skillList.map((skill) =&gt; new FormControl(skill.value)); const skillFormArray = this.fb.array(tempArray); this.myForm.setControl(&apos;skills&apos;, skillFormArray) } addSkill() { let temp = new FormControl(); this.skills.push(temp); } delSkill(index : any) { this.skills.removeAt(index); } get skills(): FormArray { return this.myForm.get(&apos;skills&apos;) as FormArray; }; } 可以看到，必须使用getter来访问控件数组，并使用.controls来访问控件 (5) FormGroup数组FA：[FG, FG, … ] &lt;form [formGroup]=&quot;myForm&quot; novalidate&gt; &lt;fieldset formArrayName=&quot;address&quot;&gt; &lt;div *ngFor=&quot;let oneAddress of address.controls; let i=index&quot; [formGroupName]=&quot;i&quot;&gt; &lt;h4&gt;Address #{{i + 1}}&lt;/h4&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;国家&lt;/label&gt; &lt;div class=&quot;form-right&quot;&gt; &lt;input type=&quot;text&quot; formControlName=&quot;country&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;城市&lt;/label&gt; &lt;div class=&quot;form-right&quot;&gt; &lt;input type=&quot;text&quot; formControlName=&quot;city&quot; /&gt; &lt;/div&gt; &lt;a (click)=&quot;delAdress(i)&quot; class=&quot;del&quot;&gt; - &lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label class=&quot;no&quot;&gt;&lt;/label&gt; &lt;div class=&quot;add&quot;&gt; &lt;a (click)=&quot;addAdress()&quot;&gt; + &lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/fieldset&gt; &lt;/form&gt; myForm : FormGroup; constructor(private fb : FormBuilder) { this.myForm = this.fb.group({ address: this.fb.array([]),) }); } ngOnInit() { this.initAdressList(); } initAdressList() { const tempArray = [this.fb.group({country: &apos;China&apos;, city: &apos;shanghai&apos;})]; const adressFormArray = this.fb.array(tempArray); this.myForm.setControl(&apos;address&apos;, adressFormArray) } addAdress() { let temp = this.fb.group({country: &apos;&apos;, city: &apos;&apos;}); this.address.push(temp); } delAdress(index : any) { this.address.removeAt(index); } get address(): FormArray { return this.myForm.get(&apos;address&apos;) as FormArray; }; 完整表单例子本节使用响应式构建与模板驱动表单一节中效果相同的表单 component.ts import { Component, OnInit } from &apos;@angular/core&apos;; import { FormControl, Validators, FormGroup, FormBuilder,FormArray } from &apos;@angular/forms&apos;; import { forbiddenNameValidator } from &apos;../forbinden-name.directive&apos;; @Component({ selector: &apos;reactive-form&apos;, templateUrl: &apos;./reactive-form.component.html&apos;, styleUrls: [&apos;../template-form/template-form.component.css&apos;] }) export class ReactiveFormComponent implements OnInit { myForm : FormGroup; sexs : any[] = [{&apos;name&apos;:&apos;女&apos;,&apos;value&apos;:&apos;famale&apos;},{&apos;name&apos;:&apos;男&apos;,&apos;value&apos;:&apos;male&apos;}]; likes : any[] = [{&apos;name&apos;:&apos;看电视&apos;,&apos;value&apos;:&apos;Watch Tv&apos;,&apos;isChecked&apos;:false}, {&apos;name&apos;:&apos;读书&apos;,&apos;value&apos;:&apos;Book&apos;,&apos;isChecked&apos;:false}]; selectedLikes : any[] = []; baocuns : any[] = [{&apos;name&apos;:&apos;是&apos;,&apos;value&apos;:&apos;Yes&apos;,&apos;isChecked&apos;:false},{&apos;name&apos;:&apos;否&apos;,&apos;value&apos;:&apos;No&apos;,&apos;isChecked&apos;:false}]; skillList : any[] = [{&apos;value&apos;:&apos;Java&apos;},{&apos;value&apos;:&apos;Scala&apos;}]; constructor(private fb : FormBuilder) { this.myForm = this.fb.group({ name: [&apos;Jack&apos;, [Validators.required,Validators.minLength(4),forbiddenNameValidator(/[@\\$&amp;0-9]/)]], sex: [&apos;male&apos;,Validators.required], shengri: [&apos;1990-01-01&apos;,Validators.required], password: [&apos;&apos;,Validators.required], address: this.fb.array([]), like: [], baocun:&apos;&apos;, skills: this.fb.array([]) }); } ngOnInit() { this.initAdressList(); this.initSkillList(); } get name() { return this.myForm.get(&apos;name&apos;);} get password() { return this.myForm.get(&apos;password&apos;);} selectLikes(flag: any,value : any) { if(flag.target.checked) { this.selectedLikes.push(value); } else { this.selectedLikes = this.selectedLikes.filter((like) =&gt; { return like !== value; }); } this.myForm.patchValue({ like: this.selectedLikes }); } initAdressList() { const tempArray = [this.fb.group({country: &apos;China&apos;, city: &apos;shanghai&apos;})]; const adressFormArray = this.fb.array(tempArray); this.myForm.setControl(&apos;address&apos;, adressFormArray) } addAdress() { let temp = this.fb.group({country: &apos;&apos;, city: &apos;&apos;}); this.address.push(temp); } delAdress(index : any) { this.address.removeAt(index); } get address(): FormArray { return this.myForm.get(&apos;address&apos;) as FormArray; }; initSkillList() { const tempArray = this.skillList.map((skill) =&gt; new FormControl(skill.value)); const skillFormArray = this.fb.array(tempArray); this.myForm.setControl(&apos;skills&apos;, skillFormArray) } addSkill() { let temp = new FormControl(); this.skills.push(temp); } delSkill(index : any) { this.skills.removeAt(index); } get skills(): FormArray { return this.myForm.get(&apos;skills&apos;) as FormArray; }; } component.html &lt;form [formGroup]=&quot;myForm&quot; novalidate&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;name&quot;&gt;姓名&lt;/label&gt; &lt;div class=&quot;form-right&quot;&gt; &lt;input type=&quot;text&quot; id=&quot;name&quot; formControlName=&quot;name&quot;/&gt; &lt;/div&gt; &lt;span class=&quot;reqiured&quot;&gt; * &lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;性别&lt;/label&gt; &lt;div class=&quot;form-right&quot;&gt; &lt;select name=&quot;Sex&quot; formControlName=&quot;sex&quot;&gt; &lt;option *ngFor=&quot;let sex of sexs&quot; [value]=&quot;sex.value&quot;&gt;{{sex.name}}&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;span class=&quot;reqiured&quot;&gt; * &lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;出生年月&lt;/label&gt; &lt;div class=&quot;form-right&quot;&gt; &lt;input type=&quot;date&quot; formControlName=&quot;shengri&quot; required/&gt; &lt;/div&gt; &lt;span class=&quot;reqiured&quot;&gt; * &lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;password&quot;&gt;密码&lt;/label&gt; &lt;div class=&quot;form-right&quot;&gt; &lt;input type=&quot;password&quot; id=&quot;password&quot; formControlName=&quot;password&quot;/&gt; &lt;/div&gt; &lt;span class=&quot;reqiured&quot;&gt; * &lt;/span&gt; &lt;/div&gt; &lt;fieldset formArrayName=&quot;address&quot;&gt; &lt;div *ngFor=&quot;let oneAddress of address.controls; let i=index&quot; [formGroupName]=&quot;i&quot;&gt; &lt;h4&gt;Address #{{i + 1}}&lt;/h4&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;国家&lt;/label&gt; &lt;div class=&quot;form-right&quot;&gt; &lt;input type=&quot;text&quot; formControlName=&quot;country&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;城市&lt;/label&gt; &lt;div class=&quot;form-right&quot;&gt; &lt;input type=&quot;text&quot; formControlName=&quot;city&quot; /&gt; &lt;/div&gt; &lt;a (click)=&quot;delAdress(i)&quot; class=&quot;del&quot;&gt; - &lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label class=&quot;no&quot;&gt;&lt;/label&gt; &lt;div class=&quot;add&quot;&gt; &lt;a (click)=&quot;addAdress()&quot;&gt; + &lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/fieldset&gt; &lt;div class=&quot;form-group&quot; *ngFor=&quot;let like2 of likes;let i=index&quot;&gt; &lt;label *ngIf=&quot;i ===0&quot; class=&quot;yes&quot;&gt;兴趣爱好&lt;/label&gt; &lt;label *ngIf=&quot;i !==0&quot; class=&quot;no&quot;&gt;&lt;/label&gt; &lt;div&gt; &lt;input type=&quot;checkbox&quot; #lock formControlName=&quot;like&quot; [value]=&quot;like2.value&quot; (change)=&quot;selectLikes($event,lock.value)&quot;/&gt;{{like2.name}} &lt;/div&gt; &lt;/div&gt; &lt;div formArrayName=&quot;skills&quot;&gt; &lt;div class=&quot;form-group&quot; *ngFor=&quot;let skill of skills.controls;let i=index&quot;&gt; &lt;label *ngIf=&quot;i === 0&quot; class=&quot;yes&quot;&gt;技能&lt;/label&gt; &lt;label *ngIf=&quot;i !== 0&quot; class=&quot;no&quot;&gt;&lt;/label&gt; &lt;div class=&quot;form-right&quot;&gt; &lt;input type=&quot;text&quot; [formControlName]=&quot;i&quot; /&gt; &lt;/div&gt; &lt;a (click)=&quot;delSkill(i)&quot; class=&quot;del&quot;&gt; - &lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label class=&quot;no&quot;&gt;&lt;/label&gt; &lt;div class=&quot;add&quot;&gt; &lt;a (click)=&quot;addSkill()&quot;&gt; + &lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div *ngFor=&quot;let bao of baocuns;let i=index&quot; class=&quot;form-group&quot;&gt; &lt;label *ngIf=&quot;i === 0&quot; class=&quot;yes&quot;&gt;是否保存&lt;/label&gt; &lt;label *ngIf=&quot;i !== 0&quot; class=&quot;no&quot;&gt;&lt;/label&gt; &lt;div&gt; &lt;input type=&quot;radio&quot; formControlName=&quot;baocun&quot; [value]=&quot;bao.value&quot;/&gt;{{bao.name}} &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;button-group&quot;&gt; &lt;button class=&quot;confirm&quot; [disabled]=&quot;!myForm.valid&quot;&gt;提交&lt;/button&gt; &lt;button class=&quot;concel&quot; (click)=&quot;myForm.reset()&quot;&gt;取消&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;p&gt;{{myForm.value | json}}&lt;/p&gt; 样子如下： 其他有用的东西：1 . 同步和异步更新 响应式表单是同步的。使用响应式表单，我们会在代码中创建整个表单控件树。 我们可以立即更新一个值或者深入到表单中的任意节点，因为所有的控件都始终是可用的。 模板驱动表单是异步的。模板驱动表单会委托指令来创建它们的表单控件。 为了消除“检查完后又变化了”的错误，这些指令需要消耗一个以上的变更检测周期来构建整个控件树。 这意味着在从组件类中操纵任何控件之前，我们都必须先等待一个节拍。比如，如果我们用@ViewChild(NgForm)查询来注入表单控件，并在生命周期钩子ngAfterViewInit中检查它，就会发现它没有子控件。 我们必须使用setTimeout等待一个节拍才能从控件中提取值、测试有效性，或把它设置为新值。 2 . 模板驱动表单和响应式表单的区别 模板驱动表单 数据更新是异步的，更新流程多，依赖于变更周期 表单控件在模板中通过指令创建和更新操作，如：ngModel 表单校验使用指令验证，指令包装校验函数 每次数据更新只是更新部分值，在变更周期后触法 难测试 响应式表单 数据更新是同步的，更新流程少 表单控件在ts中直接创建和更新操作,如：FormControl 表单校验使用校验函数进行验证 每次数据更新都是返回一个新实例 易测试 数据更新流程","tags":[{"name":"Augular","slug":"Augular","permalink":"http://blueskyawen.com/tags/Augular/"}]},{"title":"表单-模板驱动构建表单和校验","date":"2017-11-21T16:36:58.000Z","path":"2017/11/22/Form-templateForm/","text":"什么是模板驱动表单模板驱动表单是angular构建表单的一种方式，特点是使用常用html标签来构建表单框架，而内部的逻辑由angular自动完成，比如：form,会自动创建ngForm指令，来表单整体的数据和校验处理 构建结构模板驱动表单构建包含输入，校验，提交等一些常用的交互，主要结构图如下： 1.ngForm 表单的整体架构，遇到&lt;form&gt;标签时会自动为表单创建ngForm指令，用以管理表单，它有有以下作用： 存在整体表单的数据和状态，比如：value，valid，可以通过模板引用变量直接访问它们 管理表单内部的子控件，比如：根据name和ngModel来创建FormControl指令，等等 &lt;form #myform=&quot;ngForm&quot;&gt; &lt;input type=&quot;text&quot; [(ngModel)]=&quot;name&quot; name=&quot;name&quot;&gt; &lt;input type=&quot;text&quot; [(ngModel)]=&quot;age&quot; name=&quot;age&quot;&gt; &lt;div ngModelGroup=&quot;address&quot; #address=&quot;ngModelGroup&quot;&gt; &lt;input type=&quot;text&quot; [(ngModel)]=&quot;country&quot; name=&quot;country&quot;&gt; &lt;input type=&quot;text&quot; [(ngModel)]=&quot;city&quot; name=&quot;city&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; &lt;p&gt;{{myform.value}}&lt;/p&gt; 它的value是所有控件的数据对象： { &apos;name&apos;: &apos;aaa&apos;, &apos;age&apos;: 18, &apos;address: { &apos;country&apos;: &apos;&apos;, &apos;city&apos;: &apos;&apos; } } 2.ngModel表单控件的主要指令，用户和用户的数据交互，一般用于input标签中，进行数据绑定 &lt;input type=&quot;text&quot; [(ngModel)]=&quot;name&quot; name=&quot;name&quot;&gt; 其中，name是必须的，系统需要以name为唯一标识来为ngModel创建控件FormControl指令，加入到ngForm管理的FormControl指令集合中，而name是管理的key 3.ngModelGroup用来组合一组的数据输入，比如地址包括：国家，城市，街道，这三个是独立的输入，组合成一个输入Group,它也有自己的value和状态 &lt;div ngModelGroup=&quot;address&quot; #address=&quot;ngModelGroup&quot;&gt; &lt;input type=&quot;text&quot; [(ngModel)]=&quot;country&quot; name=&quot;country&quot;&gt; &lt;input type=&quot;text&quot; [(ngModel)]=&quot;city&quot; name=&quot;city&quot;&gt; &lt;/div&gt; &lt;p&gt;{{address.value}}&lt;/p&gt; 它的value是所有控件的数据对象： address: { &apos;country&apos;: &apos;&apos;, &apos;city&apos;: &apos;&apos; } 4.ngSubmit用来进行表单的提交，当button标签不指定type时，默认type就是submit，所以点击时候会出发提交事件，而form就捕获了这个事件，来完成提交的自定义动作;当然也可以制定type=”button”来避免这个事件，这样就可以直接使用点击事件来处理提交动作了例如，下面两种写法的结果是一样的： &lt;form #myform=&quot;ngForm&quot; (ngSubmit)=&quot;add()&quot;&gt; &lt;input type=&quot;text&quot; [(ngModel)]=&quot;name&quot; name=&quot;name&quot;&gt; &lt;input type=&quot;text&quot; [(ngModel)]=&quot;age&quot; name=&quot;age&quot;&gt; &lt;button&gt;OK&lt;/button&gt; &lt;/div&gt; &lt;form #myform=&quot;ngForm&quot;&gt; &lt;input type=&quot;text&quot; [(ngModel)]=&quot;name&quot; name=&quot;name&quot;&gt; &lt;input type=&quot;text&quot; [(ngModel)]=&quot;age&quot; name=&quot;age&quot;&gt; &lt;button type=&quot;button&quot; (click)=&quot;add()&quot;&gt;OK&lt;/button&gt; &lt;/div&gt; 5.内置状态跟踪和校验表单控件和输入控件都有内置的状态，可以进行状态判断： valid: 表单或控件是否有效，当requied控件的值都有效的时候true pristine： 表单或控件的值是否是纯的和未改变过的，初始值为true dirty: 表单或控件的值是否已改变过，初始值为false touched: 表单或控件的值是否已访问过，初始值为false,访问过后失去焦点以后变为true untouched: 表单或控件的值是否已访问过，初始值为true 常用内置校验指令： required minlength maxlength pattern 直接在标签上使用即可，angular会自动为之创建指令实例 6.表单状态样式类对应于状态值，有相应的内置样式： valid –&gt; ng-valid ng-invalid dirty –&gt; ng-dirty ng-pristine touch –&gt; ng-touched ng-untouched 完整表单例子上面描述了模板驱动表单的一些东西，下面是一个完整的构建例子，代码如下： Component.ts import { Component } from &apos;@angular/core&apos;; @Component({ selector: &apos;template-form&apos;, templateUrl: &apos;./template-form.component.html&apos;, styleUrls: [&apos;./template-form.component.css&apos;] }) export class TemplateFormComponent { name : any; sexs : any[] = [{&apos;name&apos;:&apos;女&apos;,&apos;value&apos;:&apos;famale&apos;},{&apos;name&apos;:&apos;男&apos;,&apos;value&apos;:&apos;male&apos;}]; age : any = 18; selectSex : any = &apos;male&apos;; password : any; address : any = {&apos;country&apos;: &apos;&apos;,&apos;city&apos;: &apos;&apos;}; shengri : any = &apos;1990-01-01&apos;; likes : any[] = [{&apos;name&apos;:&apos;看电视&apos;,&apos;value&apos;:&apos;Watch Tv&apos;,&apos;isChecked&apos;:false}, {&apos;name&apos;:&apos;读书&apos;,&apos;value&apos;:&apos;Book&apos;,&apos;isChecked&apos;:false}]; selectLike : any = &apos;&apos;; skills : any[] = [{&apos;value&apos;:&apos;&apos;,&apos;isChecked&apos;:false}]; baocuns : any[] = [{&apos;name&apos;:&apos;是&apos;,&apos;value&apos;:&apos;Yes&apos;,&apos;isChecked&apos;:false},{&apos;name&apos;:&apos;否&apos;,&apos;value&apos;:&apos;No&apos;,&apos;isChecked&apos;:false}]; selectbao : any; selectLikes() { this.selectLike = &apos;&apos;; this.likes.forEach((like) =&gt; { if(like.isChecked) { this.selectLike += like.value + &apos;; &apos;; } }); } addSkill() { let temp = {&apos;value&apos;:&apos;&apos;,&apos;isChecked&apos;:false}; this.skills.push(temp); } delSkill(item : any) { let index = this.skills.indexOf(item); if(index !== -1) { this.skills.splice(index,1); } } save() { console.log(&apos;===save===&apos;); } } Component.html &lt;form #tForm=&quot;ngForm&quot; (ngSubmit)=&quot;save()&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;姓名&lt;/label&gt; &lt;div class=&quot;form-right&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot; [(ngModel)]=&quot;name&quot; minlength=&quot;3&quot; required #name1=&quot;ngModel&quot;/&gt; &lt;/div&gt; &lt;span class=&quot;reqiured&quot;&gt; * &lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;error&quot; *ngIf=&quot;(!name1.pristine || name1.dirty) &amp;&amp; name1.touched&quot;&gt; &lt;p *ngIf=&quot;name1.errors?.required&quot;&gt;Name is requred!!&lt;/p&gt; &lt;p *ngIf=&quot;name1.errors?.minlength&quot;&gt;Name length is under 3!!&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;性别&lt;/label&gt; &lt;div class=&quot;form-right&quot;&gt; &lt;select name=&quot;Sex&quot; [(ngModel)]=&quot;selectSex&quot;&gt; &lt;option *ngFor=&quot;let sex of sexs&quot; [value]=&quot;sex.value&quot;&gt;{{sex.name}}&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;span class=&quot;reqiured&quot;&gt; * &lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;出生年月&lt;/label&gt; &lt;div class=&quot;form-right&quot;&gt; &lt;input type=&quot;date&quot; name=&quot;shengti&quot; [(ngModel)]=&quot;shengri&quot; [value]=&quot;shengri&quot; required/&gt; &lt;/div&gt; &lt;span class=&quot;reqiured&quot;&gt; * &lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;密码&lt;/label&gt; &lt;div class=&quot;form-right&quot;&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; [(ngModel)]=&quot;password&quot; required/&gt; &lt;/div&gt; &lt;span class=&quot;reqiured&quot;&gt; * &lt;/span&gt; &lt;/div&gt; &lt;fieldset ngModelGroup=&quot;address&quot; #address=&quot;ngModelGroup&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;国家&lt;/label&gt; &lt;div class=&quot;form-right&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;coun&quot; [(ngModel)]=&quot;address.country&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;城市&lt;/label&gt; &lt;div class=&quot;form-right&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;city&quot; [(ngModel)]=&quot;address.city&quot; /&gt; &lt;/div&gt; &lt;/div? &lt;/fieldset&gt; &lt;div class=&quot;form-group&quot; *ngFor=&quot;let like of likes;let i=index&quot;&gt; &lt;label *ngIf=&quot;i ===0&quot; class=&quot;yes&quot;&gt;兴趣爱好&lt;/label&gt; &lt;label *ngIf=&quot;i !==0&quot; class=&quot;no&quot;&gt;&lt;/label&gt; &lt;div&gt; &lt;input type=&quot;checkbox&quot; [(ngModel)]=&quot;like.isChecked&quot; name=&quot;like&quot; (ngModelChange)=&quot;selectLikes()&quot; /&gt;{{like.name}} &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot; *ngFor=&quot;let skill of skills;let i=index&quot;&gt; &lt;label *ngIf=&quot;i ===0&quot; class=&quot;yes&quot;&gt;技能&lt;/label&gt; &lt;label *ngIf=&quot;i !==0&quot; class=&quot;no&quot;&gt;&lt;/label&gt; &lt;div class=&quot;form-right&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;coun&quot; [(ngModel)]=&quot;address.country&quot; /&gt; &lt;/div&gt; &lt;a (click)=&quot;delSkill(skill)&quot; class=&quot;del&quot;&gt; - &lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label class=&quot;no&quot;&gt;&lt;/label&gt; &lt;div class=&quot;add&quot;&gt; &lt;a (click)=&quot;addSkill()&quot;&gt; + &lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div *ngFor=&quot;let bao of baocuns;let i=index&quot; class=&quot;form-group&quot;&gt; &lt;label *ngIf=&quot;i === 0&quot; class=&quot;yes&quot;&gt;是否保存&lt;/label&gt; &lt;label *ngIf=&quot;i !== 0&quot; class=&quot;no&quot;&gt;&lt;/label&gt; &lt;div&gt; &lt;input type=&quot;radio&quot; [(ngModel)]=&quot;selectbao&quot; name=&quot;bao&quot; [value]=&quot;bao.value&quot; /&gt;{{bao.name}} &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;button-group&quot;&gt; &lt;button class=&quot;confirm&quot; [disabled]=&quot;!tForm.form.valid&quot;&gt;提交&lt;/button&gt; &lt;button class=&quot;concel&quot; (click)=&quot;tForm.reset()&quot;&gt;取消&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; 效果如下： 自定义校验规则1）校验的内部表单的校验本质上是校验函数的调用，包括内置校验函数和自定义校验，比如: &lt;input type=&quot;text&quot; minlength=&quot;3&quot; required&gt; angular会将两个校验属性转化成函数来处理 required：调用的Validators.required() minlength=“3”： 调用的Validators.minlength(3) 这是在模板驱动表单控件里校验，将校验函数转换成属性指令，这样模板标签就可以直接使用校验属性而在响应驱动表单中，可以直接使用校验函数了解校验的实现，不难了解自定义校验是实现一个校验函数 2）自定义校验属性 例子要实现：输入文本不能包含特殊字符@ ￥ &amp; 和 数字，否则提示错误 校验函数，有检查的字符就返回响应字符值，否则返回空： import { AbstractControl, ValidatorFn } from &apos;@angular/forms&apos;; export function forbiddenNameValidator(nameRe: RegExp): ValidatorFn { return (control: AbstractControl): {[key: string]: any} =&gt; { const forbidden = nameRe.test(control.value); return forbidden ? {&apos;forbiddenName&apos;: {value: control.value}} : null; }; } 在模板驱动表单中使用需要转换成属性指令： import { Directive, Input } from &apos;@angular/core&apos;; import { AbstractControl, NG_VALIDATORS, Validator, Validators } from &apos;@angular/forms&apos;; @Directive({ selector: &apos;[forbiddenName]&apos;, providers: [{provide: NG_VALIDATORS, useExisting: ForbiddenValidatorDirective, multi: true}] }) export class ForbiddenValidatorDirective implements Validator { @Input(forbiddenName) name: string; validate(control: AbstractControl): {[key: string]: any} { return this.name ? forbiddenNameValidator(new RegExp(&quot;[@\\$&amp;0-9]&quot;))(control) : null; } } &lt;input type=&quot;text&quot; forbiddenName=&quot;name&quot; required&gt; &lt;div class=&quot;error&quot; *ngIf=&quot;(!name1.pristine || name1.dirty) &amp;&amp; name1.touched&quot;&gt; &lt;p *ngIf=&quot;name1.errors?.forbiddenName&quot;&gt; Name can not has @ $ &amp; and number!!&lt;/p&gt; &lt;/div&gt; 3）跨字段交叉验证 例子要实现：输入文本不能包含特殊字符@ ￥ &amp; 和 数字，否则提示错误 校验函数，有检查的字符就返回响应字符值，否则返回空： import { AbstractControl, ValidatorFn } from &apos;@angular/forms&apos;; export const identityRevealedValidator: ValidatorFn = (control: FormGroup): ValidationErrors | null =&gt; { const name = control.get(&apos;name&apos;); const alterEgo = control.get(&apos;alterEgo&apos;); return name &amp;&amp; alterEgo &amp;&amp; name.value === alterEgo.value ? { &apos;identityRevealed&apos;: true } : null; }; //跨字段校验器不能用到单个控件上，一般用在控件组上，比如表单 const heroForm = new FormGroup({ &apos;name&apos;: new FormControl(), &apos;alterEgo&apos;: new FormControl(), &apos;power&apos;: new FormControl() }, { validators: identityRevealedValidator }); 在模板驱动表单中使用需要转换成属性指令： import { Directive, Input } from &apos;@angular/core&apos;; import { AbstractControl, NG_VALIDATORS, Validator, Validators } from &apos;@angular/forms&apos;; @Directive({ selector: &apos;[appIdentityRevealed]&apos;, providers: [{ provide: NG_VALIDATORS, useExisting: IdentityRevealedValidatorDirective, multi: true }] }) export class IdentityRevealedValidatorDirective implements Validator { validate(control: AbstractControl): ValidationErrors { return identityRevealedValidator(control) } } &lt;form #heroForm=&quot;ngForm&quot; appIdentityRevealed&gt; ... &lt;/form&gt; 自定义异步验证器可以参看官方文档","tags":[{"name":"Augular","slug":"Augular","permalink":"http://blueskyawen.com/tags/Augular/"}]},{"title":"Angular-表单","date":"2017-11-19T14:28:04.000Z","path":"2017/11/19/Angular-Form/","text":".form-group { display:block; } .form-group label { display:inline-block; width:60px; } .form-group label[name]:after { content: \" : \"; } .form-group .form-right { display:inline-block; width:260px; } 什么是表单表单主要是数据交互，主要变现为用户的输入和交互，应用场景十分广泛。我们的网络生活中几乎离不开表单，比如：用户注册，用户登录，问卷调查，等等都是表单使用的场景。Angular在表单构建这块很强大，它封装了很多表单相关的控件和指令，使得开发者可以很方便的构建一个复杂的表单，这也是很多网站软件在框架选型的时候选择angular的一个原因。 表单特征表单一般都具备一些和用户交互的特点，比如： 输入 数据获取/处理 输入提示 错误提示 表单校验 表单提交 后面将基于这些特点来个构建完整的表单 表单构建方式Augular提供了两种构建表单的方式：模板驱动表单和响应式驱动表单，主要区别如下： 模板驱动表单：使用angular内置的构建指令和校验指令来构建，比如：NgForm,NgModel;主要工作在模板搭建，一些指令实例化和校验的工作angular内部已经实现 响应型驱动表单：使用angular提供的自定义表单额校验指令自由的进行构建，比如：FormGroup,FormControl等，主要工作在ts逻辑代码 常用表单控件下面是一些常用表单控件的简单实现，后续将做成单独的控件 1.普通输入&lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;姓名&lt;/label&gt; &lt;div class=&quot;form-right&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot; [(ngModel)]=&quot;name&quot; /&gt; &lt;/div&gt; &lt;/div&gt; Name 2.单选项-Radiosexs : any[] = [{&apos;name&apos;:&apos;女&apos;,&apos;value&apos;:&apos;famale&apos;}, {&apos;name&apos;:&apos;男&apos;,&apos;value&apos;:&apos;male&apos;}]; selectSex : any; &lt;div *ngFor=&quot;let sex of sexs;let i=index&quot; class=&quot;form-group&quot;&gt; &lt;label *ngIf=&quot;i === 0&quot; class=&quot;yes&quot;&gt;Sex&lt;/label&gt; &lt;label *ngIf=&quot;i !== 0&quot; class=&quot;no&quot;&gt;&lt;/label&gt; &lt;div class=&quot;form-right&quot;&gt; &lt;input type=&quot;radio&quot; [(ngModel)]=&quot;selectSex&quot; name=&quot;sex&quot; [value]=&quot;sex.value&quot; /&gt;{{sex.name}} &lt;/div&gt; &lt;/div&gt; 性别 男 女 3.复选框-Checkboxlikes : any[] = [{&apos;name&apos;:&apos;看电视&apos;,&apos;value&apos;:&apos;Watch Tv&apos;,&apos;isChecked&apos;:false}, {&apos;name&apos;:&apos;读书&apos;,&apos;value&apos;:&apos;Book&apos;,&apos;isChecked&apos;:false}]; selectLike : any = &apos;&apos;; &lt;div *ngFor=&quot;let like of likes;let i=index&quot; class=&quot;form-group&quot;&gt; &lt;label *ngIf=&quot;i === 0&quot; class=&quot;yes&quot;&gt;Likes&lt;/label&gt; &lt;label *ngIf=&quot;i !== 0&quot; class=&quot;no&quot;&gt;&lt;/label&gt; &lt;div class=&quot;form-right&quot;&gt; &lt;input type=&quot;checkbox&quot; [(ngModel)]=&quot;like.isChecked&quot; name=&quot;like&quot; (ngModelChange)=&quot;selectLikes()&quot; /&gt;{{like.name}} &lt;/div&gt; &lt;/div&gt; 爱好 看电视 读书 4.数字输入框-Number&lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;Age&lt;/label&gt; &lt;div class=&quot;form-right&quot;&gt; &lt;input type=&quot;number&quot; name=&quot;age&quot; [(ngModel)]=&quot;age&quot; min=&quot;0&quot; max=&quot;100&quot; step=&quot;5&quot; /&gt; &lt;/div&gt; &lt;/div&gt; 年龄 5.日期选择-Date&lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;生日&lt;/label&gt; &lt;div class=&quot;form-right&quot;&gt; &lt;input type=&quot;date&quot; name=&quot;shengti&quot; [(ngModel)]=&quot;shengti&quot; [value]=&quot;shengti&quot; /&gt; &lt;/div&gt; &lt;/div&gt; 生日 6.下拉选择-Selectphones : any[] = [{&apos;name&apos;:&apos;Apple&apos;,&apos;value&apos;:&apos;Apple&apos;}, {&apos;name&apos;:&apos;Oppo&apos;,&apos;value&apos;:&apos;Oppo&apos;}, {&apos;name&apos;:&apos;Vivi&apos;,&apos;value&apos;:&apos;Vivi&apos;}]; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;Phones&lt;/label&gt; &lt;div class=&quot;form-right&quot;&gt; &lt;select name=&quot;phone&quot; [(ngModel)]=&quot;myPhone&quot;&gt; &lt;option *ngFor=&quot;let phone of phones&quot; [value]=&quot;phone.value&quot;&gt;{{phone.name}}&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;Phones&lt;/label&gt; &lt;div class=&quot;form-right&quot;&gt; &lt;select name=&quot;phone&quot; [(ngModel)]=&quot;myPhone2&quot;&gt; &lt;option *ngFor=&quot;let phone of phones&quot; [ngValue]=&quot;phone&quot;&gt;{{phone.name}}&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;/div&gt; 手机 Apple Oppo Vivi [value]和[ngValue]的区别在于select最后返回ngModel数据的不同，value是得到值，ngValue的话得到的是所选择的整条记录 7.多选择-MutilSelect&lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;Phones&lt;/label&gt; &lt;div class=&quot;form-right&quot;&gt; &lt;select multiple name=&quot;phone&quot; [(ngModel)]=&quot;myPhone3&quot;&gt; &lt;option *ngFor=&quot;let phone of phones&quot; [value]=&quot;phone.value&quot;&gt;{{phone.name}}&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;/div&gt; 手机 Apple Oppo Vivi 8.颜色选择-color&lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;Phones&lt;/label&gt; &lt;div class=&quot;form-right&quot;&gt; &lt;select multiple name=&quot;phone&quot; [(ngModel)]=&quot;myPhone3&quot;&gt; &lt;option *ngFor=&quot;let phone of phones&quot; [value]=&quot;phone.value&quot;&gt;{{phone.name}}&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;/div&gt; 颜色 9.文件选择-file&lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;生日&lt;/label&gt; &lt;div class=&quot;form-right&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; [(ngModel)]=&quot;file&quot; /&gt; &lt;/div&gt; &lt;/div&gt; 文件 10.数字范围-Range&lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;生日&lt;/label&gt; &lt;div class=&quot;form-right&quot;&gt; &lt;input type=&quot;range&quot; name=&quot;range&quot; [(ngModel)]=&quot;range&quot; min=&quot;5&quot; max=&quot;100&quot; /&gt; &lt;/div&gt; &lt;/div&gt; 生日","tags":[{"name":"Augular","slug":"Augular","permalink":"http://blueskyawen.com/tags/Augular/"}]},{"title":"Angular-指令","date":"2017-11-09T16:13:25.000Z","path":"2017/11/10/angular-directive/","text":"指令在angular里是一种主要的存在，它可以改变元素的结构，改变元素的属性，甚至改变元素的行为angular有许多内置的指令，我们也可以自定义指令，在属性指令和结构指令里面描述过，而组件作为一种特殊的指令，描述着带模板的指令下面主要介绍内置的一些常用指令： 1.通用指令包含在CommonModule模块中ngClassngStylengIfngForngSwitch,ngSwitchCase,ngSwitchDefaultngTemplateOutletngPlural,ngPluralCase 这些是一些常用的结构和属性指令，之前介绍过 2.路由指令包含在RouterModule模块中RouterOutlet：路由占位符， &lt;router-outlet&gt;&lt;/router-outlet&gt; Routerlink: 路由url链接 &lt;button routerLink=&quot;{{'/hero/' + crisis.id}}&quot; routerLinkActive=&quot;Active&quot;&gt; &lt;/button&gt; RouterlinkActive：属性绑定，用于在路由激活时把CSS类添加到该元素 &lt;button [routerLink]=&quot;[&apos;/hero&apos;, hero.id]&quot; [routerLinkActive]=&quot;[&apos;Active&apos;,&apos;classA&apos;]&quot;&gt;&lt;/button&gt; 3.表单指令(1) 模板驱动表单指令包含在FormModule模块中ngModel：双向数据绑定 &lt;input type=&quot;text&quot; id=&quot;name&quot; [(ngModel)]=&quot;model.name&quot; name=&quot;name&quot; required&gt; ngModelGroup:双向数据绑定组 ngForm：模板驱动表单是为form自动添加的指令 &lt;form #heroForm=&quot;ngForm&quot;&gt; Angular会在标签上自动创建并附加一个NgForm指令。NgForm指令为form增补了一些额外特性。 它会控制那些带有ngModel指令和name属性的元素，监听他们的属性（包括其有效性）。 它还有自己的valid属性，这个属性只有在它包含的每个控件都有效时才是真。 (2) 响应式表单指令包含在ReactiveFormModule模块中FormControlDirectiveFormControlNameFormArrayNameFormGroupDirectiveFormGroupName 这些指令用户创建响应式表单，在表单一文中将详细描述 FormControl–用于跟踪一个单独的表单控件的值和有效性状态。它对应于一个HTML表单控件，比如输入框和下拉框。FormGroup–用于跟踪一组AbstractControl的实例的值和有效性状态。 该组的属性中包含了它的子控件。 组件中的顶级表单就是一个FormGroup。FormArray–用于跟踪AbstractControl实例组成的有序数组的值和有效性状态。 (3) 表单内置指令包含在InternalFormSharedModule模块中 单复选框选项指令和框状态控制指令ngSelectOption,ngSelectMultipleOptionngControlStatus,ngControlStatusGroup 各种类型输入框的值控制指令DefaultValueAccessor,CheckboxControlValueAccessor,RadioControlValueAccessor,NumberValueAccessor,SelectControlAccessor 输入约束指令RequiredValidator,MinLentthValidtor,MaxLengthValidtor,PatternValidtor 以上指令是angular为表单建设而实现的一部分内部指令，在使用模板驱动或响应式构建表单和表单控件时angular自动对表单的一些调用和控制，用户不需要显式的使用她们，一般也不需要过多的了解实现细节，有兴趣的可上官网api文档库查看研究 这里举几个例子：DefaultValueAccessor控制如下的值设定 &lt;input type=&quot;text&quot; id=&quot;name&quot; [(ngModel)]=&quot;model.name&quot; name=&quot;name&gt; RequiredValidator用于输入框的required属性实现，会有相应的非法状态，css类等 &lt;input type=&quot;text&quot; [(ngModel)]=&quot;model.name&quot; name=&quot;name&quot; required&gt;","tags":[{"name":"Augular","slug":"Augular","permalink":"http://blueskyawen.com/tags/Augular/"}]},{"title":"Angular-变更检测","date":"2017-10-15T10:34:55.000Z","path":"2017/10/15/angular-jianceqi/","text":"前面讲了angular的一些属性绑定，事件绑定，以及双向绑定之类的语法，但angular时如何响应这些绑定操作并及时更新数据模型的呢？当然是事件驱动的，触发的来源有以下三大事件: 用户操作 http交互 定时器超时 这几项形式不同，但都可以理解为事件的形式，而且还有一个共同点：都是异步的，而且我们进行的每一个动作都会转化为相应的事件angular通过NgZone来捕获这些时间的发生，并决定要不要通知检测机制进行变更检测，大概的示意图如下： 如图所示：1） NgZone继承于开源的zone.js，并进行了响应的扩展，比如：可控制不通知变更检测等，zone通过”猴子补丁“的方式强制重写了浏览器关于时间的捕获处理，所以可以捕获几乎所有事件来处理想要的处理；2) NgZone会在每一次事件发生完之后通知angular检测机制执行变更检测，当然也提供了接口来控制通不通知，以及何时通知； onTurnStart()： 事件开始事前发射，一个浏览器任务只处理一个 onTurnDone() ：当事件处理完，调度到其他任务钱发射 onEventDone()：当onTurnDone调用完发射，也就是发送检测通知的时间 通过zone.runOutsideAngular()可以控制子zone不向parent-zone冒泡 3) angular应用内部在创建每一个组件实例的同时，会使用变更检测器类创建一个对应的检测器实例，用来记录组件的数据变化状态，所以在应用形式组件树的同时，也形成了检测器实例的树型结构；变更检测类主要接口：123456class ChangeDetectorRef &#123; markForCheck() : void; detach() : void; reattach() : void; detectChanges() : void;&#125; 其中：markForCheck()：使用于子组件，将该子组件到根组件之间的路径标记起来，通知angular检测器下次变化检测时一定检查次路径上的组件;detach()：将组件的检测器从检测器数中脱离，不再受检测机制的控制，除非重新attach上;reattach()：把脱离的检测器重新链接到检测器树上;detectChanges():手动发起该组件到各个子组件的变更检测;通过这些接口我们可以手动控制变化检测1234567891011121314151617181920212223242526272829@component(&#123; selector: &apos;hero-list&apos;, template: ` &lt;ul&gt; &lt;li*ngFor=&quot;let hero of heroList&quot; (click)=&quot;select(hero)&quot;&gt; &#123;&#123;hero.name&#125;&#125;&lt;/li&gt; &lt;hero-detail [hero]=&quot;selectHero&quot;&gt;&lt;/hero-detail&gt; &lt;/ul&gt; `&#125;)export class HeroListComponent implements OnInit,OnDestroy &#123; heroList : any[] = []; refreshTimer : any; constructor(private Cdr : ChangeDetectorRef,private heroServce : HeroServce) &#123; Cdr.detach(); &#125; ngOnInit() &#123; this.heroList = this.heroServce.getHeros(); this.refreshTimer = setInterval(() =&gt; &#123; this.Cdr.detectChanges(); &#125;,5000); &#125; ngOnDestroy() &#123; clearInterval(this.refreshTimer); this.refreshTimer = undefined; &#125;&#125; 4) 当angular接收到事件通知时，便从根组件对应的检测器实例开始，由上而下来遍历整个树，检测那些遍历发生了变化，并及时进行更新；5) 应用中可以注入ngzone和检测器实例来在逻辑上控制通知的发送以及检测器的行为;6) 变更检测还可以在组件里设置检测策略，有两种： default: 每次变更检测都会检查组件的所有数据，包括引用型变量内部的字段值，效率不高; Onpush: 每次变更检测只检查变量值是否变化，对于引用型变量如果地址不变的话不再检测; 所以可根据使用的情况对部分组件的检测设置Onpush策略，提高效率 1234@component(&#123; selector: &apos;hero-list&apos;, changeDetection: ChangeDetectionStrategy.Onpush&#125;) 对于引用型变量可以通过拷贝改变他们的地址来加入检测，比如使用Immiutable变量声明,clone()等;","tags":[{"name":"Augular","slug":"Augular","permalink":"http://blueskyawen.com/tags/Augular/"}]},{"title":"类与接口","date":"2017-10-06T17:09:48.000Z","path":"2017/10/07/class-and-interface/","text":"作为javascript的超集，typescript遵循了ES6标准，同时扩展了多方面的能力，而类和接口时Typescript两个十分重要的特性 一. 类Typescript支持基于类的面向对象编程，类作为面向对象具有三大特性：封装性，继承性，多态 1) 封装 类将属性和方法封装成独立的个体，作为模板供实例化使用 class Car { public engine : string; private distance : number; protected price : number; constructor(engine : string,price : number) { this.distance = 0; this.engine = engine; this.price = price; } drive(distance :number) { this.distance = distance; } } let mycar = new Car(&apos;Aodi&apos;,200); mycar.drive(10); 2) 继承 基类可派生出多个子类，子类可继承基类的基本属性 class Moto extends Car { constructor(engine : string,price : number) { super(engine,price) } } let myMoto = new Moto(&apos;Aodi&apos;,30); myMoto.drive(10); 3) 多态 class Moto extends Car { constructor(engine : string,price : number) { super(engine,price) } drive(distance :number) { this.distance = distance; } } let myMoto ： Car = new Moto(&apos;Aodi&apos;,30); myMoto.drive(10); //调用子类方法 4) 抽象类继承 抽象类不能实例化，只提供子类继承，用于提炼声明一些公共的属性和方法 abstract class basicCar { color : string; abstract drive(distance :number) : void; } class Car extends basicCar { drive() : void { ///...// } } 二. 接口 接口在面向对象设计中用来声明可复用的模板单位，比如：属性接口，类接口等，同时接口也只是用来严格限制类型使用的，是设计模式的一种设计方式，比如使用属性接口定义的变量需要严格进行参数检测的，而继承类接口的class必须实现接口里的方法，否则将会检测报错 1) 属性接口 属性型接口可将一些字段集合在一些以供声明，类似于结构体，但使用属性接口定义的变量在赋值时需要进行接口检查器的检测，所赋予的值里必须存在接口声明中存在的字段且类型一致，否则报错，十分严格 interface Name { firstName : string; secondName ?: string; } let name : Name = {firstName: &apos;Mical&apos;,secondName: &apos;Jordon&apos;}; let name2 : Name = {firstName: &apos;Mical&apos;}; let name3 : Name = {firstName: &apos;Mical&apos;,secondName: &apos;Jordon&apos;,age: 33}; //ok 2) 函数接口 函数型接口主要声明严格类型的方法原型，包括入参的个数/类型以及返回值的类型，使用此接口定义的变量可接受与声明方式一致的函数，不可接受其他类型的函数赋值 interface Function { (aa : string,bb: number): string } let myfun1 : Function = function(a : string,b : number) { return a + b; } myfun1(&apos;mybaby&apos;, 9); //ok let myfun1 : Function = function(a : string,b : string) { return a + b; } //No ok!! 3) 索引接口 索引型接口主要声明可又索引值来访问其中value值的结构性变量模板，包括数组和一般的接口 //Array interface aRRAY { [aa : number]: string } let aa : aRRAY = [&apos;11&apos;,&apos;ddd&apos;]; //interface interface aRRAY { [aa : string]: string } let bbb : aRRAY = [&apos;name&apos;:&apos;ssas&apos;]; 3) 类接口 类接口主要为了给引用的class来提供一些共有的属性和方法，本身并不实现这些方法，而class引用了它就必须实现这些，相当严格；相关类似于抽象类 interface basic { name: string; eat() : void; } interface basic2 extends basic { walk() : void; } class IT implements basic2 { name : string; constructor(name : string) { this.name = name; } eat() : void { //eat } walk() : void { //walk } } 类和接口的区别 接口是为了数据声明而设计，拥有严格接口检测，而类是为了对象和数据封装 类需要实例化且调用构造函数，接口不需要，类接口也不需要 接口在使用上和类是本质不同的 类的继承使用extends，而引用接口使用implements 类可以实现自己的方法，类接口不行","tags":[{"name":"Typescript","slug":"Typescript","permalink":"http://blueskyawen.com/tags/Typescript/"}]},{"title":"Angular-组件通信","date":"2017-09-10T15:48:14.000Z","path":"2017/09/10/angular-zujiantonxing/","text":"在应用组件过程中，很多时候需要不同的组件之间进行数据共享，或者数据通讯，尤其的父子组件之间，angular提供了几种典型的方式完成这类需求 输入变量通过@Input()声明输入变量，来进行父组件对子组件的数据输入 import { Component, Input } from &apos;@angular/core&apos;; export class HeroChildComponent { @Input() hero: Hero; @Input(&apos;master&apos;) masterName: string; //定义别名 } setter和getter使用一个输入属性的setter，可以拦截父组件中值的变化，并进行相关处理；使用getter，又可以将处理之后的数据返回给调用者 import { Component, Input } from &apos;@angular/core&apos;; export class NameChildComponent { private _name = &apos;&apos;; @Input() set name(name: string) { this._name = (name &amp;&amp; name.trim()) || &apos;&lt;no name set&gt;&apos;; } get name(): string { return this._name + ‘AAA’; } } OnChanges使用OnChanges生命周期钩子接口的ngOnChanges()方法来监测输入属性值的变化并做出回应 注意，此方法只能检测纯变量的输入变化，不能检测结构型变量（比如：数据/对象等）内容的变更 import { Component, Input, OnChanges, SimpleChange } from &apos;@angular/core&apos;; export class VersionChildComponent implements OnChanges { @Input() major: number; @Input() minor: number; changeLog: string[] = []; ngOnChanges(changes: {[propKey: string]: SimpleChange}) { let log: string[] = []; for (let propName in changes) { let changedProp = changes[propName]; let to = JSON.stringify(changedProp.currentValue); if (changedProp.isFirstChange()) { log.push(`Initial value of ${propName} set to ${to}`); } else { let from = JSON.stringify(changedProp.previousValue); log.push(`${propName} changed from ${from} to ${to}`); } } this.changeLog.push(log.join(&apos;, &apos;)); } } 变量SimpleChange时所有输入变量变更的一个对象，每个变量名作为key，value值是个对象，对象里有变量上一次值，当前值和是否首次变化；比如上面例子的变量内容时这样的： { ‘major’：{ ‘currentValue’:6, &apos;firstChange&apos;: true, &apos;previousValue&apos;:3 }, ‘minor’：{ ‘currentValue’:8, &apos;firstChange&apos;: false, &apos;previousValue&apos;:3 } } 事件监听子组件暴露一个EventEmitter属性，当事件发生时，子组件利用该属性emits(向上弹射)事件。父组件绑定到这个事件属性，并在事件发生时作出回应 import { Component, EventEmitter, Input, Output } from &apos;@angular/core&apos;; export class VoterComponent { @Input() name: string; @Output() onVoted = new EventEmitter&lt;boolean&gt;(); vote(agreed: boolean) { this.onVoted.emit(agreed); } } //父组件 import { Component } from &apos;@angular/core&apos;; @Component({ selector: &apos;vote-taker&apos;, template: ` &lt;my-voter *ngFor=&quot;let voter of voters&quot; [name]=&quot;voter&quot; (onVoted)=&quot;onVoted($event)&quot;&gt; &lt;/my-voter&gt; ` }) export class VoteTakerComponent { agreed = 0; disagreed = 0; voters = [&apos;Mr. IQ&apos;, &apos;Ms. Universe&apos;, &apos;Bombasto&apos;]; onVoted(agreed: boolean) { agreed ? this.agreed++ : this.disagreed++; } } 输入和输出变量有两种写法，效果等价：组件类里声明:@Input(别名) a;@Output(别名) b;元数据里声明：Inputs:[‘a : 别名’]，Outputs:[‘b : 别名’]， 使用引用变量获取组件在父组件模板里，可以通过设置引用变量代表子组件，然后利用这个变量来读取子组件的属性和调用子组件的方法 模板引用变量的使用只限制于在模板中使用 //子组件 import { Component, OnDestroy, OnInit } from &apos;@angular/core&apos;; export class CountdownTimerComponent implements OnInit, OnDestroy { intervalId = 0; message = &apos;&apos;; seconds = 11; clearTimer() { clearInterval(this.intervalId); } ngOnInit() { this.start(); } ngOnDestroy() { this.clearTimer(); } start() { this.countDown(); } stop() { this.clearTimer(); this.message = `Holding at T-${this.seconds} seconds`; } private countDown() {} } //父组件 import { Component } from &apos;@angular/core&apos;; import { CountdownTimerComponent } from &apos;./countdown-timer.component&apos;; @Component({ selector: &apos;countdown-parent-lv&apos;, template: ` &lt;h3&gt;Countdown to Liftoff (via local variable)&lt;/h3&gt; &lt;button (click)=&quot;timer.start()&quot;&gt;Start&lt;/button&gt; &lt;button (click)=&quot;timer.stop()&quot;&gt;Stop&lt;/button&gt; &lt;div class=&quot;seconds&quot;&gt;{{timer.seconds}}&lt;/div&gt; &lt;countdown-timer #timer&gt;&lt;/countdown-timer&gt; `, styleUrls: [&apos;demo.css&apos;] }) export class CountdownLocalVarParentComponent { } ViewChild模板引用变量方法有局限性，只能在模板中进行，父组件本身的代码对子组件没有访问权；要让父组件直接访问子组件的变量或方法，可使用ViewChild将子组件注入到父组件里面 import { AfterViewInit, ViewChild } from &apos;@angular/core&apos;; import { Component } from &apos;@angular/core&apos;; import { CountdownTimerComponent } from &apos;./countdown-timer.component&apos;; @Component({ selector: &apos;countdown-parent-vc&apos;, template: ` &lt;h3&gt;Countdown to Liftoff (via ViewChild)&lt;/h3&gt; &lt;button (click)=&quot;start()&quot;&gt;Start&lt;/button&gt; &lt;button (click)=&quot;stop()&quot;&gt;Stop&lt;/button&gt; &lt;div class=&quot;seconds&quot;&gt;{{ seconds() }}&lt;/div&gt; &lt;countdown-timer&gt;&lt;/countdown-timer&gt; ` }) export class CountdownViewChildParentComponent implements AfterViewInit { @ViewChild(CountdownTimerComponent) private timerComponent: CountdownTimerComponent; seconds() { return 0; } ngAfterViewInit() { setTimeout(() =&gt; this.seconds = () =&gt; this.timerComponent.seconds, 0); } start() { this.timerComponent.start(); } stop() { this.timerComponent.stop(); } } 注意：ngAfterViewInit()生命周期钩子是非常重要的一步。被注入的计时器组件只有在Angular显示了父组件视图之后才能访问，所以我们先把秒数显示为0；然后Angular会调用ngAfterViewInit生命周期钩子，但这时候再更新父组件视图的倒计时就已经太晚了。Angular的单向数据流规则会阻止在同一个周期内更新父组件视图。我们在显示秒数之前会被迫再等一轮。使用setTimeout()来等下一轮，然后改写seconds()方法，这样它接下来就会从注入的这个计时器组件里获取秒数的值 服务共享数据可以通过服务在父子组件之间来共享数据，因为在他们之间这个服务可以时单例的，父子组件使用服务的同一个实例，自然可以共享，这个在依赖注入里以及说的很多，这里不再阐述","tags":[{"name":"Augular","slug":"Augular","permalink":"http://blueskyawen.com/tags/Augular/"}]},{"title":"Angular-预编译和摇树","date":"2017-09-03T09:48:48.000Z","path":"2017/09/03/angular-aot/","text":"AOT预编译使用AOT，编译器仅仅使用一组库在构建期间运行一次；使用JIT，编译器在每个用户的每次运行期间都要用不同的库运行一次，更适合实时开发AOT编译的好处： 渲染得更快使用AOT，浏览器下载预编译版本的应用程序。 浏览器直接加载运行代码，所以它可以立即渲染该应用，而不用等应用完成首次编译。 需要的异步请求更少编译器把外部HTML模板和CSS样式表内联到了该应用的JavaScript中。 消除了用来下载那些源文件的Ajax请求。 需要下载的Angular框架体积更小如果应用已经编译过了，自然不需要再下载Angular编译器了。 该编译器差不多占了Angular自身体积的一半儿，所以，省略它可以显著减小应用的体积。 提早检测模板错误AOT编译器在构建过程中检测和报告模板绑定错误，避免用户遇到这些错误。 更安全AOT编译远在HTML模版和组件被服务到客户端之前，将它们编译到JavaScript文件。 没有模版可以阅读，没有高风险客户端HTML或JavaScript可利用，所以注入攻击的机会较少。 Aot设置首先,使用git clone https://github.com/angular/quickstart.git quickstart 设置本地简单的项目开发环境在项目根目录/quickstart，安装依赖 npm install @angular/compiler-cli @angular/platform-server --save 复制原tsconfig.json到项目根目录tsconfig-aot.json文件，修改如下 //tsconfig-aot.json { &quot;compilerOptions&quot;: { &quot;target&quot;: &quot;es5&quot;, &quot;module&quot;: &quot;es2015&quot;, &quot;moduleResolution&quot;: &quot;node&quot;, &quot;sourceMap&quot;: true, &quot;emitDecoratorMetadata&quot;: true, &quot;experimentalDecorators&quot;: true, &quot;lib&quot;: [&quot;es2015&quot;, &quot;dom&quot;], &quot;noImplicitAny&quot;: true, &quot;suppressImplicitAnyIndexErrors&quot;: true, &quot;typeRoots&quot;: [ &quot;./node_modules/@types/&quot; ] }, &quot;files&quot;: [ &quot;src/app/app.module.ts&quot;, &quot;src/main.ts&quot; ], &quot;angularCompilerOptions&quot;: { &quot;genDir&quot;: &quot;aot&quot;, &quot;skipMetadataEmit&quot; : true } } 执行命令ngc编译器来启动AOT编译 node_modules/.bin/ngc -p tsconfig-aot.json ngc希望-p选项指向一个tsconfig.json文件，或者一个包含tsconfig.json文件的目录。在ngc完成时，会在aot目录下看到一组NgFactory文件（该目录是在tsconfig-aot.json的genDir属性中指定的）。这些工厂文件对于编译后的应用是必要的。 每个组件工厂都可以在运行时创建一个组件的实例，其中带有一个原始的类文件和一个用JavaScript表示的组件模板。注意，原始的组件类依然是由所生成的这个工厂进行内部引用的。 修改启动备份原main.ts为main-jit.ts，将main.ts改为 import { platformBrowser } from &apos;@angular/platform-browser&apos;; import { AppModuleNgFactory } from &apos;../aot/src/app/app.module.ngfactory&apos;; console.log(&apos;Running AOT compiled&apos;); platformBrowser().bootstrapModuleFactory(AppModuleNgFactory); 重新编译应用 Rollup摇树优化Rollup会通过跟踪import和export语句来对本应用进行静态分析。 它所生成的最终代码捆中会排除那些被导出过但又从未被导入的代码。Rollup只能对ES2015模块摇树，因为那里有import和export语句安装Rollup依赖 npm install rollup rollup-plugin-node-resolve rollup-plugin-commonjs rollup-plugin-uglify --save-dev 在项目根目录新建一个配置文件（rollup-config.js），来告诉Rollup如何处理应用 //rollup-config.js import nodeResolve from &apos;rollup-plugin-node-resolve&apos;; import commonjs from &apos;rollup-plugin-commonjs&apos;; import uglify from &apos;rollup-plugin-uglify&apos;; export default { entry: &apos;src/main.js&apos;, dest: &apos;src/build.js&apos;, // output a single application bundle sourceMap: false, format: &apos;iife&apos;, onwarn: function(warning) { // Skip certain warnings // should intercept ... but doesn&apos;t in some rollup versions if ( warning.code === &apos;THIS_IS_UNDEFINED&apos; ) { return; } // console.warn everything else console.warn( warning.message ); }, plugins: [ nodeResolve({jsnext: true, module: true}), commonjs({ include: &apos;node_modules/rxjs/**&apos;, }), uglify() ] }; 执行摇树优化 node_modules/.bin/rollup -c rollup-config.js 备份原index.html为index-jit.html，修改脚本配置： System.import(&apos;main-jit.js&apos;).catch(function(err){ console.error(err); }); 修改index.html &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Ahead of time compilation&lt;/title&gt; &lt;base href=&quot;/&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;styles.css&quot;&gt; &lt;script src=&quot;node_modules/core-js/client/shim.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;node_modules/zone.js/dist/zone.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;my-app&gt;Loading...&lt;/my-app&gt; &lt;/body&gt; &lt;script src=&quot;build.js&quot;&gt;&lt;/script&gt; &lt;/html&gt; 在package,json的scripts加上 &quot;build:aot&quot;: &quot;ngc -p tsconfig-aot.json &amp;&amp; rollup -c rollup-config.js&quot;, 可通过npm run build:aot同时进行编译和摇树优化 此时，npm start可启动应用，但这时候时按AOT方式启动的，修改内容不会即时编译生效；在url后面加上index-jit.html，比如 http://localhost:3000/index-jit.html 可切换值jit开发方式，可以实时编译，实现了aot和jit同时存在 项目根目录添加文件copy-dist-files.js var fs = require(&apos;fs&apos;); var resources = [ &apos;node_modules/core-js/client/shim.min.js&apos;, &apos;node_modules/zone.js/dist/zone.min.js&apos;, &apos;src/styles.css&apos; ]; resources.map(function(f) { var path = f.split(&apos;/&apos;); var t = &apos;aot/&apos; + path[path.length-1]; fs.createReadStream(f).pipe(fs.createWriteStream(t)); }); 使用node copy-dist-files拷贝AOT发布文件到/aot/目录 在package,json的scripts加上 &quot;serve:aot&quot;: &quot;lite-server -c bs-config.aot.json&quot; 使用 npm run build:aot &amp;&amp; npm run serve:aot 同时编译和启动应用，但这时是AOT预编译的，不能实时开发","tags":[{"name":"Augular","slug":"Augular","permalink":"http://blueskyawen.com/tags/Augular/"}]},{"title":"Angular-Http","date":"2017-08-27T04:26:40.000Z","path":"2017/08/27/anular-http/","text":"前端应用需要通过http协议与后端服务器通讯,现代浏览器支持使用两种不同的 API 发起 HTTP 请求：XMLHttpRequest 接口和 fetch() API。@angular/common/http中的HttpClient类(旧版的时Http)，Angular 为应用程序提供了一个简化的 API 来实现 HTTP 功能。它基于浏览器提供的XMLHttpRequest接口。 HttpClient带来的其它优点包括：可测试性、强类型的请求和响应对象、发起请求与接收响应时的拦截器支持，以及更好的、基于可观察（Observable）对象的错误处理机制 引入Http模块在应用根模块引入一次即可，这样可在全应用范围内可用 import {HttpClientModule} from &apos;@angular/common/http&apos;; @NgModule({ imports: [ BrowserModule, HttpClientModule, ], }) export class AppModule {} 引入之后，在应用的各个组件和服务里就可以通过依赖注入来使用此服务了 基本应用（1）获取数据基本格式 import {Observable} from &quot;rxjs/Observable&quot;; import {HttpClient} from &quot;@angular/common/http&quot;; http.get(url).pipe( map(...), catchError(...) ).subscribe( data =&gt; {...}, err =&gt; { console.log(&apos;Something went wrong!&apos;); } }); 比如： this.http.get(&apos;/api/items&apos;).pipe( map(res =&gt; res.items || []), ).subscribe(data =&gt; { this.results = data[&apos;results&apos;]; }); 限制强类型参数 http.get&lt;Config&gt;(url).subscribe((data : Config) =&gt; { this.results = data.results; }); 或 http.get&lt;Config&gt;(url).subscribe((data : Config) =&gt; { this.result = {...data}; }); 比如： interface ItemsResponse { results: string[]; } this.http.get&lt;ItemsResponse&gt;(&apos;/api/items&apos;).pipe( map((res : ItemsResponse) =&gt; res.results || []), ).subscribe(data =&gt; { this.results = data; }); 或 getItems(url) : Observable&lt;ItemsResponse&gt; { return this.http.get&lt;ItemsResponse&gt;(&apos;/api/items&apos;).pipe( map((res : ItemsResponse) =&gt; res.results || []); } 读取完整的响应体读取完整的响应体，包括特殊的响应头或状态码 //get返回对象Observable&lt;HttpResponse&lt;Config&gt;&gt; http.get&lt;Config&gt;(url, {observe: &apos;response&apos;}) .subscribe(resp =&gt; { console.log(resp.headers.get(&apos;X-Custom-Header&apos;)); console.log(resp.body.someField); }); 比如： this.http.get&lt;ItemsResponse&gt;(&apos;/api/items&apos;，{observe: &apos;response&apos;}) .subscribe(resp =&gt; { console.log(resp.headers.get(&apos;X-Custom-Header&apos;)); this.results = resp.body; }); 错误处理和失败重试 handleError(error: HttpErrorResponse) { ... return of([]); } 比如： private handleError(error: HttpErrorResponse) { if (error.error instanceof ErrorEvent) { console.error(&apos;An error occurred:&apos;, error.error.message); } else { console.error(`Backend returned code ${error.status}, ` +`body was: ${error.error}`); } return throwError(&apos;Something bad happened！&apos;); }; this.http.get(&apos;/api/items&apos;).pipe( retry(3), catchError(handleError) ).subscribe(data =&gt; { this.results = data[&apos;results&apos;]; },error =&gt; { console.error(&apos;error is &apos;+error); }); 请求非 JSON 数据 this.http.get(url, {responseType: &apos;text&apos;}) .pipe( tap( data =&gt; this.log(filename, data), error =&gt; this.logError(filename, error) ) ); 比如： this.http.get(&apos;assets/not-json.txt&apos;, {responseType: &apos;text&apos;}) .pipe( tap( data =&gt; this.log(filename, data), error =&gt; this.logError(filename, error) ) ).subscribe(data =&gt; { this.content = data; }); （2）添加数据基本格式 http.post(url, body, {headers: new HttpHeaders()}) .pipe( map(...), catchError(...) ).subscribe(...); 比如： const body = {name: &apos;Brad&apos;}; const url = &apos;/api/developers/add&apos;; http.post(url, body, {headers: new HttpHeaders()}) .pipe( catchError(this.handeError) ).subscribe(data =&gt; { this.data = data }); 添加请求头配置 import {HttpHeaders} from &quot;@angular/common/http&quot;; http.post(url, body, {headers: new HttpHeaders().set(‘Authorization’, ‘my-auth-token’)}) .pipe( catchError(this.handeError) ).subscribe(...); 你无法直接修改前述配置对象中的现有头，因为HttpHeaders实例是不可变的，如果需要增加或修改头配置，则clone一份即可 headers = new HttpHeaders().set(&apos;AuthToken&apos;, &apos;a123456&apos;); 携带附加参数 import {HttpParams} from &quot;@angular/common/http&quot;; http.post(url, body, {params: new HttpParams().set(&apos;id&apos;, &apos;3&apos;)}) .subscribe(...); 效果同下 http.post(url+&apos;?id=3&apos;, body) .subscribe(); 同样的，HttpParams实例是不可变的，如果需要增加或修改配置，需要clone一份 params = new HttpParams().set(&apos;name&apos;, &apos;a123456&apos;); （3）修改数据与post类似，只是换成了put而已 http.put(url, body, {headers: new HttpHeaders().set(‘Authorization’, ‘my-auth-token’)}) .pipe( catchError(this.handeError) ).subscribe(...); （4）删除数据http.delete(url, id) .pipe( catchError(this.handeError) ).subscribe(); 注意：delete操作虽然返回没什么可处理的，但是subscribe必须要有，否则不会执行 参考示例：configTextLoad","tags":[{"name":"Augular","slug":"Augular","permalink":"http://blueskyawen.com/tags/Augular/"}]},{"title":"Angular-结构指令","date":"2017-07-30T17:11:43.000Z","path":"2017/07/31/angular-structDirective/","text":"结构型指令可以很方便的DOM结构树，Angular有一个强力的模板引擎来支持这一些，比如：添加、移除或维护DOM元素例如： &lt;div *ngIf=&quot;hero&quot; &gt;{{hero.name}}&lt;/div&gt; 内置结构指令（1）NgIf &lt;div *ngIf=&quot;hero&quot; &gt;{{hero.name}}&lt;/div&gt; 接受一个条件值，当条件为假时，从DOM中移除它的宿主元素，取消它监听过的那些DOM事件，从Angular变更检测中移除该组件，并销毁它，DOM节点可以被当做垃圾收集起来，并且释放它们占用的内存；否则，则添加它们解开语法糖： &lt;div *ngIf=&quot;hero&quot; class=&quot;active&quot;&gt;{{hero.name}}&lt;/div&gt; --&gt; &lt;div template=&quot;ngIf hero&quot; class=&quot;active&quot;&gt;{{hero.name}}&lt;/div&gt; --&gt; &lt;ng-template [ngIf]=&quot;hero&quot;&gt; &lt;div class=&quot;active&quot;&gt;{{hero.name}}&lt;/div&gt; &lt;/ng-template&gt; 上述解开的形式不会真的渲染出来，angular渲染时会移除ng-template，并辅以标记性注释占位，真正添加到DOM树里的是里面的div部分 （2）NgFor &lt;div *ngFor=&quot;let hero of heroes&quot;&gt;{{hero.name}}&lt;/div&gt; 指令接受一个模板表达式，对数据列表进行迭代，应用于宿主元素，并将宿主元素及其子元素一起克隆多份置于DOM树上解开语法糖： &lt;div *ngFor=&quot;let hero of heroes; let i=index; let odd=odd; trackBy: trackById&quot; [class.odd]=&quot;odd&quot;&gt; ({{i}}) {{hero.name}} &lt;/div&gt; --&gt; &lt;div template=&quot;ngFor let hero of heroes; let i=index; let odd=odd; trackBy: trackById&quot; [class.odd]=&quot;odd&quot;&gt; ({{i}}) {{hero.name}} &lt;/div&gt; --&gt; &lt;ng-template ngFor let-hero [ngForOf]=&quot;heroes&quot; let-i=&quot;index&quot; let-odd=&quot;odd&quot; [ngForTrackBy]=&quot;trackById&quot;&gt; &lt;div [class.odd]=&quot;odd&quot;&gt;({{i}}) {{hero.name}}&lt;/div&gt; &lt;/ng-template&gt; 这个比较复杂： let关键字声明一个模板输入变量，本例中就是hero、i和odd； 解析器会把let hero、let i和let odd翻译成命名变量let-hero、let-i和let-odd 微语法解析器接收of和trackby，把它们首字母大写（of -&gt; Of, trackBy -&gt; TrackBy）， 并且给它们加上指令的属性名（ngFor）前缀，最终生成的名字是ngForOf和ngForTrackBy 两个NgFor的输入属性分别是，列表heroes，track-by函数是trackById NgFor指令在列表上循环，每个循环中都会设置和重置它自己的上下文对象上的属性。 这些属性包括index和odd以及一个特殊的属性名$implicit（隐式变量，let-hero） （3）NgSwitch &lt;div [ngSwitch]=&quot;hero?.emotion&quot;&gt; &lt;happy-hero *ngSwitchCase=&quot;&apos;happy&apos;&quot; [hero]=&quot;hero&quot;&gt;&lt;/happy-hero&gt; &lt;sad-hero *ngSwitchCase=&quot;&apos;sad&apos;&quot; [hero]=&quot;hero&quot;&gt;&lt;/sad-hero&gt; &lt;confused-hero *ngSwitchCase=&quot;&apos;confused&apos;&quot; [hero]=&quot;hero&quot;&gt;&lt;/confused-hero&gt; &lt;unknown-hero *ngSwitchDefault [hero]=&quot;hero&quot;&gt;&lt;/unknown-hero&gt; &lt;/div&gt; NgSwitch不是结构指令，只是属性指令，用来接受“状态值”；NgSwitchCase和NgSwitchDefault是结构型指令，用来根据状态来匹配显示不同的分支DOM,用法额原理都类似于NGIF解开语法糖： &lt;div [ngSwitch]=&quot;hero?.emotion&quot;&gt; &lt;ng-template [ngSwitchCase]=&quot;&apos;happy&apos;&quot;&gt; &lt;happy-hero [hero]=&quot;hero&quot;&gt;&lt;/happy-hero&gt; &lt;/ng-template&gt; &lt;ng-template [ngSwitchCase]=&quot;&apos;sad&apos;&quot;&gt; &lt;sad-hero [hero]=&quot;hero&quot;&gt;&lt;/sad-hero&gt; &lt;/ng-template&gt; &lt;ng-template [ngSwitchCase]=&quot;&apos;confused&apos;&quot;&gt; &lt;confused-hero [hero]=&quot;hero&quot;&gt;&lt;/confused-hero&gt; &lt;/ng-template &gt; &lt;ng-template ngSwitchDefault&gt; &lt;unknown-hero [hero]=&quot;hero&quot;&gt;&lt;/unknown-hero&gt; &lt;/ng-template&gt; &lt;/div&gt; 注意： 模板输入变量时一个模块实例的变量值，可以使用到当前实例中；而模板引用变量时引用的元素，代表的时那个元素本身，可在当前整个文档中使用；两种有不同的命名空间 一个元素不同时使用两个结构型实例 ng-template/ng-container（1）ng-template&lt;ng-template&gt;是一类html标签，是angular用来解释渲染结构性指令的一种方式，不会直接显示在html,最后会替换成同意义的注释；比如ngif中，当条件为false，angular将移除相应分支元素，取而代之的时一段注释这个标签直接单独使用的时候也有次效果，比如： &lt;ng-template&gt;&lt;p&gt;AA&lt;/p&gt;&lt;/ng-template&gt; 包裹的元素内容在渲染时会消失，而代之的是注释 （2）ng-container&lt;ng-container&gt;是一种不影响当前样式/布局的组合元素,angular只是用它来包裹控制内部元素的显示不显示，最后是不会添加渲染到DOM树上的，也不会有注释，使用起来就像普通语言中的if条件一样；它可直接包裹任何元素，包括文本 &lt;p&gt; I turned the corner &lt;ng-container *ngIf=&quot;hero&quot;&gt; and saw {{hero.name}}. I waved &lt;/ng-container&gt; and continued on my way. &lt;/p&gt; 有些元素不能直接使用其他标签包裹，比如select中的option，必须和select挨着，否则会出问题；这是不能使用ngif或ng-template，但可以使用ng-container，它不会有副作用，因为最后都会移除掉 &lt;select [(ngModel)]=&quot;hero&quot;&gt; &lt;ng-container *ngFor=&quot;let h of heroes&quot;&gt; &lt;ng-container *ngIf=&quot;showSad || h.emotion !== &apos;sad&apos;&quot;&gt; &lt;option [ngValue]=&quot;h&quot;&gt;{{h.name}} ({{h.emotion}})&lt;/option&gt; &lt;/ng-container&gt; &lt;/ng-container&gt; &lt;/select&gt; 会根据heros动态显示option,而所有的ng-container标签最后都会移除，否则会影响option显示 自定义结构指令指令作用：使用数字来控制元素的增加和移除，类似于ngIf，接受源字符串，当输入是数字时添加；输入是非数字或空串，移除宿主元素 import { Directive, Input, TemplateRef, ViewContainerRef} from &apos;@angular/core&apos;; @Directive({ selector: &apos;[numIf]&apos; }) export class NumIfDirective { private hasView = false; constructor(private templateRef: TemplateRef&lt;any&gt;, private viewContainer: ViewContainerRef) { } @Input() set numIf(condition: any) { if (condition &amp;&amp; !isNaN(condition) &amp;&amp; !this.hasView) { this.viewContainer.createEmbeddedView(this.templateRef); this.hasView = true; } else if (isNaN(condition) &amp;&amp; this.hasView) { this.viewContainer.clear(); this.hasView = false; } } } 使用的地方 &lt;div&gt; &lt;label&gt;请输入： &lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;input&quot; [(ngModel)]=&quot;myValue&quot;&gt; &lt;/div&gt; &lt;p *numIf=&quot;myValue&quot;&gt;输入的值是： {{myValue}}&lt;/p&gt; 效果如下： 其他一些好东西：1 . 自定义结构指令里头，有几个新的概念，这里简单说一下 embedview,内嵌视图 TemplateRef，内嵌视图创建模板，存有指令宿主元素模板 viewContainer,视图容器,view列表 viewcontainerRef,描绘视图容器，用于管理container,可同时创建内嵌view和组件视图，类里有不同的方法来创建，还有一个container的锚点，用于指定容器，可当做列表的头地址，新创建的view一个个作为兄弟成员存放，方便管理；类中injector存有TemplateRef 几个概念的大概关系如下：","tags":[{"name":"Augular","slug":"Augular","permalink":"http://blueskyawen.com/tags/Augular/"}]},{"title":"Angular-管道","date":"2017-07-27T17:24:09.000Z","path":"2017/07/28/angular-pipe/","text":"管道是什么简单来说，是一种值转换器，用于在模板中对变量或数据进行转换后显示，好比数据输入进入一个管道，得到期望的数据输出，示意图：其实，在本质上，就是把一些通用的转换函数封装成管道类，供各个组件模块在应用中实例化使用，比如：字符串转化成大写/数字四舍五入等 使用方法输入值 | 管道：参数输入值流向管道进行处理，并返回处理后的数据| 是管道操作符，熟悉C++的同学可理解管道类的一种运算符重载，赋予它特殊的作用，虽然实际可能只是函数参数的重载管道可带参数值，用于指导数据的处理方式，比如： {{ birthday | date:\"MM/dd/yy\" }} 常用的管道常用内置管道：DatePipe、UpperCasePipe、LowerCasePipe、CurrencyPipe、JsonPipe和PercentPipe等，看名字就能知道各个管道的作用，点击这里进入API文档，搜索pipe可学习更多内置管道多个可选参数管道可以接受任何数量的可选参数来对它的输出进行微调，在管道名后面添加一个或者多个参数，参数间使用冒号( : )隔开，比如 {{data | currency:'EUR'}} {{data | slice:1:5}} 参数可以是字符串常量和组件属性变量，我们可以在组件里利用属性控制显示的格式规则链式调用多个管道链式调用，将从左至右顺序执行，最终的效果时各个管道效果的叠加 {{ birthday | date:'fullDate' | uppercase}} 自定义管道管道作用：存储单位转化器，输入为mb，如果输入小于1,显示kb；小于1024，显示MB;大于1024，显示GB;其他输入值或非数字输入，显示error import { Pipe, PipeTransform } from &apos;@angular/core&apos;; @Pipe({ name: &apos;transverter&apos; }) export class TransverterPipe implements PipeTransform { transform(value: any, args?: any): any { if(isNaN(value)) { return &apos;error&apos; } let tempValue = +value; if(tempValue &lt; 0) { return &apos;error&apos;; } else if(tempValue &lt; 1) { tempValue *= 1024; return tempValue + &apos;KB&apos;; } else if(tempValue &lt; 1024) { return value + &apos;MB&apos;; } else { tempValue = tempValue/1024; return tempValue + &apos;GB&apos;; } } } 管道类只要继承PipeTransform接口，实现transform方法即可，其他第一个参数value是输入数据，后面的args是可选参数，使用管道 &lt;div&gt; &lt;label&gt;请输入： &lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;input&quot; [(ngModel)]=&quot;inputValue&quot;&gt; &lt;span&gt;MB&lt;/span&gt; &lt;/div&gt; &lt;p&gt;使用管道转换后： {{inputValue | transverter}}&lt;/p&gt; 效果： 管道的变更检测一般情况下，管道对输入数据的变更检测属于纯检测，相应的管道叫纯管道；相应的，非纯管道执行非纯的变更检测策略(1) 纯检测只对原始类型值(String、Number、Boolean、Symbol)的更改进行检测， 或者对对象引用(Date、Array、Function、Object)的更改变化进行检测，而对于对象内的成员值变化不做检测比如，有数组A[10],如下使用管道 let arrayData = A[10]; {{arrayData | PipeName}} 如果数组内成员的值发生变化，纯检测检测不到变更，应为数组引用并无变化使用纯检测方式的管道是纯管道，定义时元数据如下设置： @Pipe({ name: &apos;flyImpure&apos;, }) 或 @Pipe({ name: &apos;flyImpure&apos;, pure: true }) (2) 非纯检测对输入值和数据成员都进行检测，包括组合对象的成员变更，但是每个变更检测周期都会触发检测，次数多，代价较大使用非纯检测方式的管道是非纯管道，定义时元数据如下设置： @Pipe({ name: &apos;flyingHeroesImpure&apos;, pure: false }) 两种管道的定义和使用方式相同，只是变更检测方式不同而已 管道的替代品(1) 使用纯管道实现替代非纯管道由于非纯管道的变更检测次数频繁，代价大，所以一般不会使用它，在需要用到非纯管道的场景，我们也可以用在组件内使用的时候进行特别的设计，使得纯管道也能达到预期效果，比如： let arrayData = A[10]; arrayData = clone(arrayData); {{arrayData | PipeName}} (2) 管道的替代品管道作用就是数据转化，这些工作都可以放在组件内完成，或者定义服务来做，服务也能用来备多个组件共享 其他一些好东西1 . Date和Currency管道需要ECMAScript国际化（I18n）API，但Safari和其它老式浏览器不支持它，该问题可以用垫片（Polyfill）解决 &lt;script src=&quot;https://cdn.polyfill.io/v2/polyfill.min.js?features=Intl.~locale.en&quot;&gt; &lt;/script&gt; 2 . 纯管道与纯函数：纯函数是指在处理输入并返回结果时，不会产生任何副作用的函数。 给定相同的输入，它们总是返回相同的输出,纯管道必须总是用纯函数实现 3 . 非纯AsyncPipe,AsyncPipe接受一个Promise或Observable作为输入，并且自动订阅这个输入，最终返回它们给出的值 4 . 在多种值绑定语法中，Angular通过变更检测过程来查找绑定值的更改，并在每一次JavaScript事件之后运行：每次按键、鼠标移动、定时器以及服务器的响应。这可能会让变更检测显得很昂贵，但是Angular会尽可能降低变更检测的成本","tags":[{"name":"Augular","slug":"Augular","permalink":"http://blueskyawen.com/tags/Augular/"}]},{"title":"Angular-生命周期钩子","date":"2017-07-23T14:58:58.000Z","path":"2017/07/23/angular-lifecysle-hook/","text":"在开发angular应用书写组件或者指令的时候，我们从来没有去手动的new或者deletet来管理它们的实例，angular系统管理着这一切组件/指令像普通的事物一样，有着自己的声明周期：生，变更，销毁..等等，这个过程有angular自动管理着 生命周期钩子生命周期显而易见，但是当用户想在这个过程中做点什么呢？于是angular便在生命过程中的关键时间点上提供了相应的介入接口和钩子方法，让用户可以介入其中两个概念： 接口,生命周期的暴露点，开发介入点，比如初始化接口：OnInit 钩子，接口对应的函数方法，供开发使用，只要实现相应的钩子方法即看介入对应的生命周期点，比如初始化钩子：ngOnInit() 接口和钩子是一一对应的，钩子方式是：ng接口名，比如OnInit和ngOnInit()，在实现时继承相应接口并实现对应钩子函数即可，当然，接口继承并非强制型的，可以直接实现钩子函数，当清晰起见，最后先继承接口再实现钩子 钩子在组件和指令实例的生命周期里，有多个不同的生命点，angular都为其设置了接口和钩子，按照时间先后有 生命点接口 生命周期钩子 调用方式 OnChanges ngOnChanges() 简单输入变量本值发生变化时调用，第一次调用在OnInit之前 OnInit ngOnInit（） 初始化时调用 DoCheck ngDoCheck（） 周期更改检测，每次变更周期都会调用 AfterContentInit ngAfterContentInit（） 内容完成初始化投影后调用 AfterContentChecked ngAfterContentChecked（） 紧跟上一条完成初始化投影后调用，以及每次变更周期在DoCheck之后调用 AfterViewInit ngAfterViewInit（） 组件和子组件完成视图初始化时调用 AfterViewChecked ngAfterViewChecked（） 紧跟上一条完成组件和子组件完成视图后调用，每次变更周期在AfterContentChecked之后调用 OnDestroy ngOnDestroy（） 销毁时调用 生命周期各个钩子的调用都在构造函数之后 生命钩子的使用（1）OnInit实现组件初始化时需要作的复杂逻辑处理，比如和服务端进行数据交互等，保持构造函数的简单，方便测试 （2）OnDestroy实例销毁时调用，用于在组件或指令销毁时的资源回收，比如：取消可观察对象的订阅，停止定时器等，特别时调用第三方库时的内存回收一个特别的例子，使用echart等第三方库封装图表控件的时候，在初始化图表后，销毁实例时务必调用相关借口释放内存，否则浏览器内存泄露，会变慢，这些工作一般都放在ngOnDestroy（）里来做 （3）OnChanges一般用于父子组件的交互和通讯，可用于子组件对输入变量的变更检测，以便采取一定的行动，当然变更检测能检测到的也只是常规变量引用的值变化，对于对象/组件这种结构型变量的成员变化则无法检测ngOnChanges（）钩子函数接受一个数组变量，存放所有输入变量的变化信息，每个变量有3个字段：“输入变量名” : {“当前值”：””,”是否首次变更”: true,”上一次的值”：””} import { Component, OnInit, Input, SimpleChanges} from &apos;@angular/core&apos;; @Input() inputValue : any = &apos;&apos;; ngOnChanges(changes: SimpleChanges) { console.log(changes); } 控制台打印： （4）DoCheck每个变更周期都会调用，可用于检测各种变量的变化，但调用次数频繁，且大部分是无用调用，所以使用时需谨慎，实现逻辑需简单 （5）AfterViewInit一般使用于完成子组件初始化后需要做的工作","tags":[{"name":"Augular","slug":"Augular","permalink":"http://blueskyawen.com/tags/Augular/"}]},{"title":"Angular/cli-命令集","date":"2017-07-23T13:52:01.000Z","path":"2017/07/23/angular-cli-comand/","text":"Angular CLI是一个命令行界面工具，它可以创建项目、添加文件以及执行一大堆开发任务，比如测试、打包和发布等使用Angular-CLI工具可以快速创建代码框架，减少重复性开发的工作量，而且创建的应用和文件符合风格指南的推荐风格，开发者可以从中获益 基本命令查询版本,获取帮助 ng help ng -v 新建项目，启动应用 ng new projectName cd projectName ng serve --open 指定主机和端口号启动 ng serve --host 0.0.0.0 --port 4201 --open 工具支持相对目录形式的创建命令，比如,当前所处目录/home/app： ng g component login //在/home/app目录下创建 ng g component login ../my //在/home/my目录下创建 ng g component login AA //在/home/app/AA目录下创建 核心命令ng newng new my-app默认生成同名目录，并初始化一个angular应用框架Option选项： --directory (简写:-dir) ，指定新建项目的目录名，比如：ng new my-app -dir AAA;不指定则默认以应用名命名目录 –dry-run (简写:-d) ，默认值: false，生成项目后立即run起来，列出所有生成的项目文件 –inline-style (简写: -is) ，默认不加时为false，，指定生成应用的组件为行内样式，即样式表位于元数据的styles[]内 –inline-template (简写: -it) ，默认不加时为 false，指定生成应用的组件为行内模板，即模板位于元数据的templates[]内 –minimal，默认值: false，创建最小化APP –prefix (简写: -p) 默认: app，指定生成文件的选择器selector的前缀，也可在.angular-cli.json文件中修改 –routing， 默认不加时为 false，指定生成相应的路由模块 –skip-commit (简写: -sc) 默认不加时为 false，指定忽略掉应用提到到库 –skip-git (简写: -sg) 默认不加时为 false，指定忽略掉初始化git仓库 –skip-install (简写: -si) 默认不加时为: false，指定忽略掉安装packages –skip-tests (简写: -st) 默认不加时为: false，指定忽略掉安装测试文件spec/e2e –source-dir (简写: -sd) 默认值: src，指定生成项目的源文件目录名，也可在.angular-cli.json (apps[0].root)中修改 –style，默认值: css，指定css文件类型（css/scss/less/sass/styl (stylus)），也可在文件.angular-cli.json (defaults.styleExt)中修改 –verbose (简写: -v)， 默认不加时为: false，生成时输出log日志 ng serveng serve编译应用并启动web服务Option选项： --host (简写: -H)， 不加时的默认值: localhost，指定启动的主机 –hmr，不加时的默认值: false，是否启动热模块替换 –live-reload (简写: -lr)，不加时的默认值: true，是否在页面变更时重新载入 –public-host (简写: –live-reload-client)，说明浏览器使用的URL –disable-host-check，默认值: false，不检测已连接的host –open (简写: -o)， 不加时默认值: false，指定启动后自动打开浏览器呈现 –port (简写: -p)， 默认值 4200，指定服务的监听端口 –ssl，使用HTTPS –ssl-cert (简写: -)，默认值SSL: –ssl-key，指定使用 serving HTTPS的SSL key –aot，指定进行预编译 –base-href (简写: -bh)，指定应用项目的基准路径,指的是其他应用文件现对于index.html的相对路径，在.angular-cli.json文件可设置根目录和index的路径，如root/src/index,可设-bh ../ –deploy-url (简写: -d)，指定文件部署的URL –environment (简写: -e)，定义编译环境 –extract-css (简写: -ec)，指定从全局样式表抽取样式 –i18n-file，使用i18n国际化 –i18n-format，指定–i18n-file国际化文件的格式 –locale，Locale to use for i18n. –output-hashing (简写: -oh) ，定义the output filename cache-busting hashing mode. Possible values: none, all, media, bundles –output-path (简写: -op) ，指定输出文件的路径 –poll，Enable and define the file watching poll time period (milliseconds) . –progress (简写: -pr)， 默认值: true，是否显示构建过程 –sourcemap (简写: -sm, sourcemaps)，Output sourcemaps. –target (简写: -t, -dev, -prod) 默认值: development，指定编译方式 –vendor-chunk (简写: -vc)，默认值: true，Use a separate bundle containing only vendor libraries. –verbose (简写: -v)， 默认值: false，生成时输出log日志 –watch (aliases: -w)，添加后文件变更会触发重新构建 ng generateng generate 类型 文件名 或 ng g 类型 文件名帮助开发者生成开发文件，类和相应代码骨架，比如：模块，组件，指令等，方便快捷开发，下面一行命令将自动生成组件的目录，和相关的css/ts/html文件 ng g component my-comp （1） moduleng g module module_name生成特性模块Option选项： --app (简写: -a)， 默认值: 1st app –flat，指定是否新建同名目录存放模块文件ng g module 或 ng g module –flat=false ： 新建同名目录ng g module –flat或 ng g module –flat=true : 不新建同名目录 –module (简写: -m)，说明模块在哪导入 –spec，指定是否连带创建spec测试文件ng g module 或 ng g module –spec=false： 同步创建specng g module –spec 或 ng g module –spec=非false: 不创建同名spec –routing，指定是否连带创建路由模块，forChild()ng g module 或 ng g module –routing=false： 不同步创建路由模块ng g module –routing 或 ng g module –routing=非false : 创建路由模块 （2） componentng g component生成组件Option选项： --app (简写: -a) 默认值: 1st app –change-detection (简写: -cd)，不知道什么用 –flat， 默认值: false，指定是否新建组件目录ng g component 或 ng g component –flat=false: 新建目录ng g component –flat 或 ng g component –flat=true: 不新建目录 –export，默认值: false，指定是否公开该组件ng g component 或 ng g component –export=false: 不公开ng g component –export 或 ng g component –export=true: 公开 –inline-style (简写: -is)，默认值: false，指定组件是否行内样式ng g component 或 ng g component -is=false: 不是行内样式ng g component -is 或 ng g component -is=true: 是行内样式 –inline-template (简写: -it)， 默认值: false，指定组件是否行内模板ng g component 或 ng g component -it=false: 不是行内模板ng g component -it 或 ng g component -it=true: 是行内模板 –module (简写: -m)，指定是否更新模块，默认更新 –prefix，指定是否去掉组件selector选择器的前缀ng g component 或 ng g component –prefix=false: 不加前缀ng g component –prefix 或 ng g component –prefix=true: 默认加前缀 –skip-import，默认值: false，Allows for skipping the module import. –spec，指定是否连带创建spec测试文件ng g component –spec=false: 不创建specng g component –spec=true 或 ng g component –spec 或 ng g component: 创建spec –view-encapsulation (简写: -ve)，Specifies the view encapsulation strategy 命令生成的组件默认更新于距离最近的module模块的declares数组里，比如当前所处目录为：/app/main/login/,生成组件后自动注册到本目录的模块中，如果本目录下无模块，则查找上一层目录的模块进行注册，指导根模块 （3） directiveng g directive name用于生成属性指令相关文件和类 ，选项使用方式基本和component类似Option选项： --app (简写: -a) 默认值: 1st app –export default value: false –flat，ng g component –flat=false: 新建目录，其他情况均不新建 –module (aliases: -m) –prefix –skip-import –spec 生成的指令类默认是这样的 mport { Directive } from &apos;@angular/core&apos;; @Directive({selector: &apos;[appA]&apos;}) export class ADirective { constructor() { } } （4） pipeng g pipe name用于生成管道相关文件和类 ，选项使用方式和directive类似Option选项： --app –export –flat –module (aliases: -m) –skip-import –spec 生成的管道类默认是这样的 import { Pipe, PipeTransform } from &apos;@angular/core&apos;; @Pipe({ name: &apos;my&apos;}) export class MyPipe implements PipeTransform { transform(value: any, args?: any): any { return null; } } （5） serviceng g service name用于生成服务相关文件和类 ，选项使用方式和directive类似Option选项： --app (aliases: -a) –flat –module (aliases: -m) –spec 生成的可注入服务默认是这样的 import { Injectable } from &apos;@angular/core&apos;; @Injectable() export class LoginService { constructor() { } } （6） guardng g guard name生成路由守卫类和相关文件Option选项： --app –flat –module (aliases: -m) –spec 生成的守卫类默认是这样的 import { Injectable } from &apos;@angular/core&apos;; import { CanActivate, ActivatedRouteSnapshot, RouterStateSnapshot } from &apos;@angular/router&apos;; import { Observable } from &apos;rxjs/Observable&apos;; @Injectable() export class AdminGuard implements CanActivate { canActivate( next: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable&lt;boolean&gt; | Promise&lt;boolean&gt; | boolean { return true; } } （7） classng g class name生成类Option选项： --app –spec 生成的类默认是这样的 export class Hero { } （8） interfaceng g interface name typeOption选项： --app type 生成的接口默认是这样的 export interface Name { } （） enumng g enum nameOption选项： --app 生成的enum默认是这样的 export enum HERO { } ng lintng lint命令使用应用配置的tslint规则文件进行lint检查ng lint命令使用应用配置的tslint规则文件进行lint检查Option选项： --fix, 默认值: false，指定检查时是否同步修正lint错误 –force，默认值 false，是否强制检查失败加上后就说有lint错误也成功 –type-check，默认值: false，是否类型检查 –format (简写: -t), 默认值: prose,指定lint输出文件格式，有下列选择：prose, json, stylish, verbose, pmd, msbuild, checkstyle, vso, fileslist ng testng test编译应用后生成输入文件，并运行测试UT ng e2eng e2e命令部署应用并运行e2e测试用例 ng buildng build编译应用并生成目标文件，一般存放于dist/ directory下面命令是等效的 ng build --target=production --environment=prod ng build --prod --env=prod ng build --prod 下面也是等效的 ng build --target=development --environment=dev ng build --dev --e=dev ng build --dev ng build 而已编译时修改index.html配置的基准路径 ng build --base-href /myUrl/ ng build --bh /myUrl/ 下面时两种模式编译默认携带的选项–dev模式： –aot false；–environment dev；–output-hashing media；–sourcemaps true；–extract-css false；–prod模式：–aot true；–environment prod；–output-hashing all；–sourcemaps false；–extract-css true；Options选项： aot， app base-href deploy-url environment extract-css i18n-file i18n-format locale output-hashing output-path delete-output-path poll progress sourcemap stats-json target vendor-chunk verbose watch show-circular-dependencies ng get/ng setng get获取配置文件的内容ng set设置配置文件的内容比如： ng get angular-cli.json //获取整个文件内容 ng get app.name //获取文件内容中app的name属性值 ng set app.name myApp //修改文件内容中app的name属性值 ng docng doc [search term]命令将自动在浏览器打开官方文档angular.io，并调到指定字段处 ng ejectng ejectejects your app and output the proper webpack configuration and scripts ng xi18nng xi18n从应用的默版中收集i18n国际化的信息","tags":[{"name":"Augular","slug":"Augular","permalink":"http://blueskyawen.com/tags/Augular/"}]},{"title":"Angular/cli-安装部署(ubuntu环境)","date":"2017-07-23T13:51:24.000Z","path":"2017/07/23/angular-cli-install-deploy/","text":"安装angular/cli1. npm普通方式(1). 安装升级nodejs进入nodejs官网获取所需的版本，鼠标浮动在相应版本上获取下载路径，本机获取的版本时linux-64的：https://nodejs.org/dist/v6.11.1/node-v6.11.1-linux-x64.tar.xz使用wget下载nodejs包 /home$ wget https://nodejs.org/dist/v6.11.1/node-v6.11.1-linux-x64.tar.xz /home$ tar xvf node-v6.11.1-linux-x64.tar.xz 添加软连接 /home$ sudo ln -s /home/node-v6.11.1-linux-x64/bin/node /usr/local/bin/node /home$ sudo ln -s /home/node-v6.11.1-linux-x64/bin/npm /usr/local/bin/npm 查看版本号： /home$ node -v v8.0.0 /home$ npm -v 5.0.0 (2). 部署angular/cli全局安装angular/cli，等待安装完成 /home$ npm install -g @angular/cli 创建链接 /home$ sudo ln -s /home/node-v6.11.1-linux-x64/bin/ng /usr/local/bin/ng ng -v查看是否安装成功，成功则有版本信息 注意：如果如果之前已存在或安装过，需先清理npm uninstall -g angular-clinpm uninstall –save-dev angular-clinpm cache cleannpm uninstall -g @angular/clinpm cache cleannpm install -g @angular/cli@latest重新安装本地文件rm -rf node_modules distnpm install –save-dev @angular/cli@latestnpm install 2. cnpm普通方式使用为国内程序员定制的cnpm安装更为方便 npm i -g cnpm cnpm i -g @angular/cli 如果如果之前已存在或安装过，需先清理 npm uninstall -g angular-cli npm cache clean npm prune 试用angular/cli通过创建一个新项目来试验下刚刚安装的angular/cli工具打开终端窗口，运行命令生成新的项目和应用程序框架：安装依赖包 cd my-app npm install 启动服务 ng serve --open ng serve该命令启动服务器，监视您的文件更改，重新构建应用程序;添加–open选项将在构建成功后自动打开您的浏览器进行呈现如果想让加载的包更小，可以添加选项prod ng serve --prod --open 效果相同：","tags":[{"name":"Augular","slug":"Augular","permalink":"http://blueskyawen.com/tags/Augular/"}]},{"title":"Angular-属性指令","date":"2017-07-20T17:26:02.000Z","path":"2017/07/21/angular-attr-directive/","text":"属性型指令是angular中三大指令之一，主要用于改变一个DOM元素的外观或操作行为，比如：可以改变元素的样式和事件响应等，可以像原生属性一样直接使用于标签元素，故此得名本节将会介绍几个最常用的属性型指令： 三大指令：组件，属性指令，结构指令 常用内置属性指令（1）NgClassngClass用于动态添加或移除一组CSS类，从而控制元素的显示效果，通过绑定到NgClass，可以同时添加或移除多个类当然，还有一种动态添加/移除单个类的CSS绑定，也能实现类似效果下面两种写法效果相同 .active { font-size: 36px; background-color: #ff2312; } .deactive { font-size: 16px; background-color: #fffff; } &lt;div [class.active]=&quot;isSpecial&quot; [class.deactive]=&quot;!isSpecial&quot;&gt;binding Class&lt;/div&gt; &lt;div [ngClass]=&quot;{active: isSpecial,deactive: !isSpecial}&quot;&gt;binding Class&lt;/div&gt; 上面当变量isSpecial为true时添加类active，否则添加deactive还可以同时添加或移除多个CSS类，像这样 .special { color: red; } currentClasses = {active: isSpecial,special: isSpecial,deactive: !isSpecial} &lt;div [ngClass]=&quot;currentClasses&quot;&gt;binding Class&lt;/div&gt; （2）NgStylengStyle用于动态内联样式，从而控制元素的显示效果，通过绑定到NgStyle，可以同时设置多个内联样式。当然，还有一种动态单一样式值的样式绑定，也能实现类似效果下面两种写法效果相同 &lt;div [style.font-size]=&quot;isSpecial ? &apos;large&apos; : &apos;small&apos;&quot; &gt; bind styles &lt;/div&gt; &lt;div [ngStyle]=&quot;{&apos;font-size&apos;:isSpecial ? &apos;large&apos; : &apos;small&apos;}&quot; &gt; bind styles &lt;/div&gt; 上面根据变量isSpecial为true或false给元素设置不同的字体大小要同时设置多个内联样式，NgStyle指令更好，像这样 currentStyles = { &apos;font-style&apos;: iscanSave ? &apos;italic&apos; : &apos;normal&apos;, &apos;font-weight&apos;: !isUnchanged ? &apos;bold&apos; : &apos;normal&apos;, &apos;font-size&apos;: isSpecial ? &apos;24px&apos; : &apos;12px&apos; }; &lt;div [ngStyle]=&quot;currentStyles&quot;&gt; bind styles &lt;/div&gt; （3）NgModel（1）使用方式开发输入表单时，通常都要既显示数据属性又要修改这个属性，使用NgModel指令进行双向数据绑定可以简化这种工作，使用方式如下： &lt;input [(ngModel)]=&quot;currentHero.name&quot; name=&quot;input&quot;&gt; 还有导入表单支持模块 import { FormsModule } from &apos;@angular/forms&apos;; 使用此指令需要指定name值。一个表单中可能有多个这样的双向绑定，在Angular内部为这些绑定创建了一些FormControl，并把它们注册到NgForm指令，再将该指令附加到&lt;form&gt;标签，而注册每个FormControl时，就是使用name属性值作为每个双向绑定的键值 （2）跟踪修改和输入验证NgModel指令更够跟踪输入状态，动态给宿主元素添加/移除CSS类，以反映当前状态，我们可以这一特性来修改控件的外观，显示和隐藏消息在输入各个不同状态下添加的类： 被访问过的时候添加ng-touched类，否则添加ng-untouched 值变化了的时候添加ng-dirty类，否则添加ng-pristine 输入值有效的时候添加ng-valid类，否则添加ng-invalid 我么可以重新定义这些CSS类，控制着些状态按照期望来显示，比如： .ng-valid[required] { border-left: 5px solid #42A948; } .ng-invalid:not(form) { border-left: 5px solid #a94442; } 还有，这些css类对应一些只是输入状态的标志位，比如：ng-pristine-&gt;pristine,ng-valid-&gt;valid，可以通过他们来显示/移除输入提示，比如： &lt;label for=&quot;name&quot;&gt;Name&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;name&quot; required [(ngModel)]=&quot;model.name&quot; name=&quot;name&quot; #name=&quot;ngModel&quot;&gt; &lt;div [hidden]=&quot;name.valid || name.pristine&quot; class=&quot;alert alert-danger&quot;&gt; Name is required &lt;/div&gt; 当输入有效或没变更时，隐藏提示；否则，显示提示 （3）双向绑定指令的内部原理在元素层面上，既要设置元素属性，又要监听元素事件变化,普通方式 &lt;input [value]=&quot;name&quot; (input)=&quot;name=$event.target.value&quot;&gt; ngular 为此提供一种特殊的双向数据绑定语法：[(x)]，该语法结合了属性绑定的方括号[x]和事件绑定的圆括号(x) &lt;input [(ngModel)]=&quot;name&quot;&gt; 双向绑定语法实际上是属性绑定和事件绑定的语法糖,Angular将绑定分解成这样： &lt;input [ngModel]=&quot;name&quot; (ngModelChange)=&quot;name=$event&quot;&gt; 当一个元素拥有可以设置的属性x和对应的事件xChange时，解释[(x)]语法就容易的多，而ngModel指令即使通过自己的输入属性ngModel和输出属性ngModelChange隐藏了那些细节 [ngModel]指令的实现如下： @Directive({ selector:&quot;[ngModel]&quot;, host: { &quot;[value]&quot;: &quot;ngModel&quot;, &quot;(input)&quot;: &quot;ngModelChange.next($event.target.value)&quot; } }) class ngModelDirective { @Input() ngModel : any; @Output() ngModelChange = new EventEmitter(); } 绑定的写法: [value] 或 bind-aa : 属性绑定(oper) 或 on-oper : 事件绑定[(value)] 或 bindon-value : 双向绑定 （4）自定义双向绑定指令根据[(x)]语法的特点，可以实现自己双向绑定,使用方式ngModel类似定义子组件： //.ts import { Component, OnInit, EventEmitter, Input, Output } from &apos;@angular/core&apos;; @Component({ selector: &apos;app-test&apos;, templateUrl: &apos;./test.component.html&apos;, styleUrls: [&apos;./test.component.css&apos;] }) export class TestComponent implements OnInit { @Output() myNumberChange = new EventEmitter&lt;any&gt;(); id : any; personList : any[] = [{&apos;id&apos;:1, &apos;name&apos;:&apos;Jack&apos;, &apos;age&apos;:10}, {&apos;id&apos;:5, &apos;name&apos;:&apos;Tom&apos;, &apos;age&apos;:18}, {&apos;id&apos;:8, &apos;name&apos;:&apos;Luccy&apos;, &apos;age&apos;:24}]; constructor() { } @Input() set myNumber(num : any) { this.id = num; } add() { this.id++; this.getPerson(); } des() { this.id--; this.getPerson(); } getPerson() { for(let person of this.personList) { if(person.id === this.id) { this.myNumberChange.emit(person.age); return; } } this.myNumberChange.emit(99); } ngOnInit() { } } //.html &lt;div class=&quot;form-group&quot;&gt; &lt;label class=&quot;form-input-label&quot;&gt;id： &lt;/label&gt; &lt;div class=&quot;form-input-content&quot;&gt; {{id}} &lt;/div&gt; &lt;/div&gt; &lt;button class=&quot;button&quot; (click)=&quot;add()&quot;&gt;增加&lt;/button&gt; &lt;button class=&quot;button&quot; (click)=&quot;des()&quot;&gt;减少&lt;/button&gt; 子组件通过输入变量myNumber获取值，处理后使用输出事件myNumberChange返回给宿主结果父组件在用时可以使用双向绑定的语法方式： //login.comonent inputNum : any = 0; &lt;div class=&quot;form-group&quot;&gt; &lt;label class=&quot;form-input-label&quot;&gt;输入变量值： &lt;/label&gt; &lt;div class=&quot;form-input-content&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;inputNum&quot; [(ngModel)]=&quot;inputNum&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;app-test [(myNumber)]=&quot;inputNum&quot;&gt;&lt;/app-test&gt; &lt;p&gt;返回的值： {{inputNum}}&lt;/p&gt; 如下时两个瞬间大概是点击“增加”，组件id变为5，并返回父组件变更了inputNum的值为18，inputNum变更后反过来又把值传入给子组件输入变量 自定义属性指令属性型指令可以同时实现元素多个普通属性所能达到效果的集合，这是属性指令比普通属性的优势。在开发过程中可以根据需要自定义属性型指令，避免元素上过多的属性添加下面的例子需要实现一个文本框，要求：只能呈现数字，可以通过鼠标点击增长/减少数值，可以手动输入数值，不能粘贴数值，能限制数值范围，输入时不能输入超出范围的数值，不能输入非数字的字母,输入聚焦时底色变更；以上可以通过一个属性型指令来实现通过@Directive装饰器来定义指令 import { Directive, ElementRef,HostListener,Input } from &apos;@angular/core&apos;; @Directive({ selector: &apos;[myInputNumber]&apos; }) export class InputNumberDirective { @Input(&apos;myInputNumber&apos;) min_number: any; constructor(private el: ElementRef) { } @HostListener(&apos;focusin&apos;) onFocusIn() { this.el.nativeElement.style.backgroundColor = &apos;yellow&apos;; } @HostListener(&apos;focusout&apos;) onFocusOut() { this.el.nativeElement.style.backgroundColor = &apos;#ffffff&apos;; } @HostListener(&apos;keyup&apos;) onkeyup() { if(!Number(this.el.nativeElement.value) || (Number(this.el.nativeElement.value) &lt; this.min_number)) { this.el.nativeElement.value = this.min_number; } } @HostListener(&apos;paste&apos;) onPaste() { return false; } @HostListener(&apos;keypress&apos;) onkeypress() { return true; } @HostListener(&apos;keydown&apos;) onkeydown() { return true; } } 使用该属性指令的父组件 //loginComponent.ts import { Component, OnInit } from &apos;@angular/core&apos;; @Component({ selector: &apos;app-login&apos;, templateUrl: &apos;./login.component.html&apos;, styleUrls: [&apos;./login.component.css&apos;] }) export class LoginComponent implements OnInit { number : any = 0; minNumber : any = 3; constructor() { this.number = this.minNumber; } ngOnInit() { } aggreNum() { this.number++; } deagreNum() { if(this.number &gt; this.minNumber) { this.number--; } } minMunChange() { this.number = this.minNumber; } } //loginComponent.html &lt;div class=&quot;form-group&quot;&gt; &lt;label class=&quot;form-input-label&quot;&gt;最小值： &lt;/label&gt; &lt;div class=&quot;form-input-content&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;inutMinNumber&quot; [(ngModel)]=&quot;minNumber&quot; (ngModelChange)=&quot;minMunChange()&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label class=&quot;form-input-label&quot;&gt;请输入： &lt;/label&gt; &lt;div class=&quot;form-input-content&quot;&gt; &lt;input type=&quot;text&quot; [myInputNumber]=&quot;minNumber&quot; name=&quot;inutNumber&quot; [(ngModel)]=&quot;number&quot;&gt; &lt;/div&gt; &lt;div class=&quot;input-number&quot;&gt; &lt;div class=&quot;input-aggre&quot; (click)=&quot;aggreNum()&quot;&gt;+&lt;/div&gt; &lt;div class=&quot;input-desgre&quot; (click)=&quot;deagreNum()&quot;&gt;-&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; （1）angular会为在指令使用时创建一个指令控制器类的实例，并把angular的ElementRef和Renderer注入进构造函数，ElementRef是一个服务，它赋予我们通过它的nativeElement属性直接访问 DOM 元素的能力（2）Renderer服务允许通过代码设置元素的样式（3）使用HostListener装饰器添加两个事件处理器（4）使用简单语法，[myInputNumber]在这里同时实现了两点：把指令应用到了宿主元素上，并且通过属性绑定设置了输入变量指令使用的效果大概如下 附录1 . 组件自己的模板可以绑定到组件的任意属性，不需要使用了@Input装饰器，因为Angular把组件的模板看做从属于该组件的，它们之间相互信任；但是组件或指令不应该盲目信任其它组件或指令， 因此组件或指令的属性默认是不能被绑定的，从Angular绑定机制的角度来看，它们是私有的，而当添加了@Input时，它们变成了公共的，只有这样，它们才能被其它组件或属性绑定 2 . 如果有两个同名指令，都叫做HighlightDirective，只要在 import 时使用as关键字来为第二个指令创建个别名即可，比如： import {HighlightDirective as myHighlight} from &apos;&apos;; 3 . EventEmitter自定义事件EventEmitter用于触发自定义事件，指令或子组件创建一个EventEmitter实例，并且把它作为属性暴露出来，调用EventEmitter.emit(payload)来触发事件，可以传入任何东西作为消息载荷。 父指令通过绑定到这个属性来监听事件，并通过$event对象来访问载荷，下面例子： //hero-detail.component.html &lt;div&gt; &lt;img src=&quot;{{heroImageUrl}}&quot;&gt; &lt;span [style.text-decoration]=&quot;lineThrough&quot;&gt; {{prefix}} {{hero?.name}} &lt;/span&gt; &lt;button (click)=&quot;delete()&quot;&gt;Delete&lt;/button&gt; &lt;/div&gt;` //hero-detail.component.ts deleteRequest = new EventEmitter&lt;Hero&gt;(); delete() { this.deleteRequest.emit(this.hero); } 组件定义了deleteRequest属性，它是EventEmitter实例。 当用户点击删除时，组件会调用delete()方法，让EventEmitter发出一个Hero对父组件绑定这个事件: &lt;hero-detail (deleteRequest)=&quot;deleteHero($event)&quot; [hero]=&quot;currentHero&quot;&gt; &lt;/hero-detail&gt; 当deleteRequest事件触发时，Angular 调用父组件的deleteHero方法， 在$event变量中传入要删除的英雄","tags":[{"name":"Augular","slug":"Augular","permalink":"http://blueskyawen.com/tags/Augular/"}]},{"title":"Angular-组件样式表","date":"2017-07-19T17:43:48.000Z","path":"2017/07/20/angular-component-styles/","text":"在angular应用中可以使用所有的CSS样式来修饰我们的模板元素，渲染我们的页面，还可以把样式的有效范围限制在组件模板中 样式在组件的使用方式（1）在模板中直接使用//外联样式文件 &lt;link src=&quot;common.css&quot;&gt; //模板内样式 &lt;style&gt; h1 { font-size: 24px; color: red; } &lt;/style&gt; //元素内联样式 &lt;div style=&quot;display:inline;&quot;&gt;&lt;/div&gt; （2）在组件元数据配置//通过URL路径加载CSS文件 @Component({ selector: &apos;app-root&apos;, styleUrls: [&apos;./app.component.css&apos;] }) //通过CSS字符串数组 @Component({ selector: &apos;app-root&apos;, styles: [&apos;h1 {color: green;}&apos;] }) //通过模块打包器载入CSS字符串 @Component({ selector: &apos;app-root&apos;, styles: [require(&apos;./app.component.css&apos;)] }) 第三种与第二种实例，都是设置的styles数据，只不过后者是直接加载的css字符串，不用手动在数据里写，推荐第一种写法 这几种方式可以同时声明在元数据中，但后声明的同类样式会覆盖前面，所以，为清晰起见，建议只使用一种 样式限定范围在组件angular默认采用Emulated仿真式模式来设置组件元数据的视图封装模式仿真式模式，是通过预处理CSS 代码来模拟Shadow DOM的行为，把CSS 样式的有效范围局限在组件视图中。就是“只进不出”，全局样式能够在组件模板中使用生效，但本组件的CSS样式不能正常在组件外部使用究其内部，其实只是angular对组件的CSS/模板进行预处理后，在组件模板元素上添加特定的属性，并且同时在CSS也添加相应的属性，来达到限制范围在目的，比如： //appComponen.ts @Component({ selector: &apos;app-root&apos;, templateUrl: &apos;./app.component.html&apos;, styleUrls: [&apos;./app.component.css&apos;] }) export class AppComponent { title = &apos;app&apos;; } //appComponen.html &lt;div style=&quot;text-align:center&quot;&gt; &lt;h1 class=&quot;HAHA&quot;&gt; Welcome to {{title}}! &lt;/h1&gt; &lt;img width=&quot;300&quot; src=&quot;data:image/svg+xml“&gt; &lt;/div&gt; &lt;h2&gt;Here are some links to help you start: &lt;/h2&gt; //appComponen.css .HAHA { color: red; } 运行应用偶打开浏览器查看元素 特殊选择器（1）:host {}表示组件的宿主元素，以宿主元素的属性来控制本组件模板内的样式表现，但是不能控制宿主的样式，比如组件Logincomponent的元数据如下： //logincomponent.ts import { Component, OnInit } from &apos;@angular/core&apos;; @Component({ selector: &apos;app-login&apos;, templateUrl: &apos;./login.component.html&apos;, styles: [&apos;:host(.AAA) p { color: orange;font-size: 36px;}&apos;] }) export class LoginComponent implements OnInit { constructor() { } } //logincomponent.html &lt;p&gt; login works! &lt;/p&gt; //父组件调用 &lt;app-login&gt;&lt;/app-login&gt; 组件Login的宿主元素就是它的选择器组成的&lt;app-login&gt;&lt;/app-login&gt;，此时组件样式是没有效果的要想生效必须在宿主元素中加上条件 &lt;app-login class=&quot;AAA&quot;&gt;&lt;/app-login&gt; 效果： （2）:host-context {}表示组件的祖先元素，不限于宿主元素，以祖先元素的属性来控制本组件内的样式表现，不能控制祖先宿主的样式还是上面那个例子，在父组件使用时改成 @Component({ selector: &apos;app-login&apos;, templateUrl: &apos;./login.component.html&apos;, styles: [&apos;:host-context(.AAA) p { color: orange;font-size: 36px;}&apos;] }) export class LoginComponent implements OnInit { constructor() { } } //父组件调用 &lt;div&gt; &lt;app-login&gt;&lt;/app-login&gt; &lt;/div&gt; 其中div和app-login都是组件的祖先宿主宿主元素，适用此选择器，此时组件样式时不生效的，要想生效需修改如下 &lt;div class=&quot;AAA&quot;&gt; &lt;app-login&gt;&lt;/app-login&gt; &lt;/div&gt; 或 &lt;div&gt; &lt;app-login class=&quot;AAA&quot;&gt;&lt;/app-login&gt; &lt;/div&gt; （3）/deep/ &gt;&gt;&gt;组件样式默认只在本组件内生效，CSS定义时加上这个生效范围会扩大到其子组件的模板视图这里说的子组件指的是在组件模板内直接使用其他组件的选择器的，比如上面例子的组件login就是其调用者的子组件这么写 :host &gt;&gt;&gt; h1 {color:red;} 或 :host /deep/ h1 {color:red;} 表示本组件的h1适用，甚至子组件的h1也适用于这个选择器","tags":[{"name":"Augular","slug":"Augular","permalink":"http://blueskyawen.com/tags/Augular/"}]},{"title":"Angular-路由器","date":"2017-07-16T16:56:10.000Z","path":"2017/07/17/angular-router/","text":"路由与导航是组织多页面应用的基本需求，也是angular最重要的几个特性之一。Angular提供了强大的路由机制来保证页面之间的跳转，根据配置的地址导航对应视图页面，并将地址值更新到浏览器地址栏中，将应用的所以页面有机的组织在了一起 路由树路由树是angular三大基本树结构之一，有着自己的配置方式，一般以单独的路由模块提供，伴随着模块的导入和导出，形成树状路由，如下图时一个典型的伴随着模块的组织而形成的路由树状结构： 路由路径导航模块直接导入之后，相应的路由模块的配置与准入模块的路由进行了合并，成为树的同级枝丫，下面是根据上一节路由树所描绘处理的导航示意图，以及形成的URL与组件的对应关系：如图所示，每一个url路径对应一个组件，路由器会根据在浏览器地址栏输入的地址或者代码里命令形式导航的地址去匹配相应的url，渲染对应组件的视图 路由配置关于angular路由请点击这里查看官方指导文档基本的路由配置就几个步骤： 1 基准地址配置angular使用pushState方式构造url，必须设置基准地址，pushState才能正常工作设置方式： 1 ). 如果app目录是应用的根目录，可以在index.html设置：&lt;base href=&quot;/&quot;&gt;2 ). 在根模块中使用适当的APP_BASE_HREF值配置provide路由器，不过这种配置方式，应用中图片、CSS文件等的引用要使用绝对路径，比如: providers: [{provide: APP_BASE_HREF, useValue: &apos;/my/app&apos;}] 当两种方式同时都有设置的时候，provide注入的优先级更高 配置作用： 告诉路由器该如何合成导航用的url 方便引用CSS文件、脚本和图片，浏览器会用基准地址的值作为相对URL的前缀 2 路由列表配置路由列表以路由模块的方式来提供，下面是一个典型的简单路由列表： import { NgModule } from &apos;@angular/core&apos;; import { RouterModule, Routes } from &apos;@angular/router&apos;; import { CrisisListComponent } from &apos;./crisis-list.component&apos;; import { HeroListComponent } from &apos;./hero-list.component&apos;; import { PageNotFoundComponent } from &apos;./not-found.component&apos;; const appRoutes: Routes = [ { path: &apos;crisis-center&apos;, component: CrisisListComponent }, { path: &apos;heroe/:id&apos;, component: HeroComponent }, { path: &apos;&apos;, redirectTo: &apos;/heroes&apos;, pathMatch: &apos;full&apos; }, { path: &apos;**&apos;, component: PageNotFoundComponent } ]; @NgModule({ imports: [ RouterModule.forRoot(appRoutes) ], exports: [ RouterModule ] }) export class AppRoutingModule {} （1）路由项以{path:,component:}为基本定义格式，保存路由的注册映射表，当浏览器的URL变化或代码中直接导航到某一url路径时，路由器就会翻出映射表,激活或生成对应组件的实例，用来显示视图，更新url到地址栏（2）path不需要以斜杠（/）开头，路由器会为解析和构建最终的URL（3）路由匹配是第一次最先匹配即停止原则，所以声明顺序很重要，建议顺序：具体路由-&gt;空路由-&gt;通配路由，通配path(**)可放置在最后作为错误url的默认页面提示（4）注册路由方式：RouterModule.forRoot只能用于根模块；RouterModule.forChild用于特性模块 路由器在每一层的路由配置中只会处理一次重定向，既单级不能出现多次的重定向，比如 ‘’ -&gt; ‘/main’ -&gt; ‘admin’ -&gt; .. 这样可以防止出现无限循环的重定向。 3 路由导航导航的声明方式有链接式和命令式导航两种： 链接式，routerLink=&quot;/hero/undefined&quot; 命令式，this.router.navigate([&#39;/hero&#39;, hero.id]) 假如要导航到一个英雄的详情页面，下面3中方式是等效的 &lt;button type=&quot;button&quot; routerLink=&quot;{{'/hero/' + crisis.id}}&quot; routerLinkActive=&quot;Active&quot;&gt; &lt;/button&gt; &lt;button type=&quot;button&quot; [routerLink]=&quot;[&apos;/hero&apos;, hero.id]&quot; [routerLinkActive]=&quot;[&apos;Active&apos;,&apos;classA&apos;]&quot;&gt;&lt;/button&gt; &lt;button type=&quot;button&quot; (click)=&quot;gotoDetail()&quot; routerLinkActive=&quot;Active&quot;&gt;&lt;/button&gt; gotoDetail() {this.router.navigate([&apos;/hero&apos;, hero.id]);} （1） routerLinkActive:RouterLinkActive指令属性绑定，用于在路由激活时把CSS类添加到该元素上,反之则移除（2）RouterLinkActive可以绑定到一个CSS类组成的数组，绑定方式有[routerLinkActive]=”[‘A’,’B’]” 或 routerLinkActive=“A B” 注意：当使用button标签进行路由时，务必制定type=”button”,如果不指定默认是“submit”类型，会默认出发表单提交 （3）RouterLinkActive还可以绑定到多个链接组里，当其中一个匹配到就添加样式类，适合用于菜单项的激活显示 &lt;div outerLinkActiver=&quot;Active&quot;&gt; &lt;button type=&quot;button&quot; routerLink=&quot;{{'/hero/'}}&quot; &gt; &lt;/button&gt; &lt;button type=&quot;button&quot; routerLink=&quot;{{'/power/'}}&quot;&gt; &lt;/button&gt; &lt;/div&gt; 4 路由参数提取(1) 参数提取对象ActivatedRoute，可以通过注入此路由服务来获取路由的路径和参数，它有很多有用的信息： url //路由路径的Observable对象，它的值是一个由路径中各个部件组成的字符串数组 data //该路由提供的data对象的一个Observable对象，还包含从resolve守卫中解析出来的值 params //包含该路由的必选参数和可选参数的Observable对象 queryParams //一个包含对所有路由都有效的查询参数的Observable对象。 fragment //一个包含对所有路由都有效的片段值的Observable对象。 outlet //RouterOutlet的名字，用于指示渲染该路由的位置,对于未命名的RouterOutlet，这个名字是primary routeConfig //与该路由的原始路径对应的配置信息。 parent //当使用子路由时，它是一个包含父路由信息的ActivatedRoute对象 firstChild //包含子路由列表中的第一个ActivatedRoute对象。 children //包含当前路由下激活的全部子路由。 注意：当在组件中订阅一个可观察对象时，我们通常总是要在组件销毁时取消这个订阅,但是也有少数例外情况不需要取消订阅，而ActivateRoute中的各种可观察对象就是属于这种情况。ActivateRoute及其可观察对象都是由Router本身负责管理的。 Router会在不再需要时销毁这个路由组件，而注入进去的ActivateRoute也随之销毁了 注意： 新版本使用paramsMap替代params，queryParamsMap替代queryParams，它们拥有如下方法: has(key)-&gt; 判断是否有此参数，true/false get(key)-&gt; 获取参数值，value/null getAll(key) -&gt; 获取所以参数值数组，[value,…] / [] key –&gt; 获取所以键值数组，[key,…] / []比如：router.snapshot.params.get(‘id’); （2）提取参数的方式使用可观察对象订阅的方式，下面两种方式效果相同switchMapswitchMap允许你在Observable的当前值上执行一个动作，并将它映射一个新的Observable,然后再使用subscribe方法解析Observable对象获取值 import { ActivateRoute } from ‘@angular/router’; constructor(private route: ActivateRoute) { this.route.params .switchMap((params: Params) =&gt; this.service.getHero(+params[&apos;id&apos;])) .subscribe((hero: Hero) =&gt; this.hero = hero); } subscribe使用subscribe方法直接解析params参数信息，获取数据值 import { ActivateRoute } from ‘@angular/router’; constructor(private route: ActivateRoute) { this.route.params .subscribe((params: Params) =&gt; { this.hero = this.service.getHero(+params[&apos;id&apos;]); }); } 快照如果组件的实例不会被复用，可以使用一次性的快照route.snapshot来简化实现，它提供了路由参数的初始值，可以通过它来直接访问参数，而不用订阅或者添加 import { ActivateRoute } from ‘@angular/router’; constructor(private route: ActivateRoute) { this.hero = this.service.getHero(+this.route.snapshot.params[&apos;id&apos;]); } 注意事项：1）像许多其它rxjs操作符一样，switchMap既可以处理Observable也可以处理Promise发射的值。并且，如果用户重新导航到该路由，并且它正在获取一个英雄时，switchMap操作符还会取消任何正在执行的请求2）默认情况，如果没有访问过其它组件就导航到了同一个组件实例，路由器倾向于复用组件实例,比如：搜索功能，这就需要Observable对象的方法来动态处理 可选参数的定义和提取可选参数是导航期间传送任意复杂信息的理想载体，可选参数不涉及到模式匹配，在表达上提供了巨大的灵活性1）定义方式只要在必要参数之后，通过一个独立的对象来定义可选参数，比如： this.router.navigate([&apos;/heroes&apos;, heroId, { foo: &apos;123&apos; }]); 合成的URL为：/heroes/123456;foo=foo1 ，可选的路由参数在url中没有使用“？”和“&amp;”符号分隔，而是以;和主url相隔2）提取方式 this.heroes = this.route.params .switchMap((params: Params) =&gt; { this.foo = +params[&apos;foo&apos;]; return this.service.getHeroes(); }); 通常，对于强制性的值（比如用于区分两个路由路径的）使用必备参数；当这个值是可选的、复杂的或多值的时，使用可选参数。 路由视图目标出口的选择理由器在为组件选择显示出口的时候，是以距离最近为原则，就是选择距离组件最近的上层outlet目标进行呈现，比如： { path: &apos;crisis-center&apos;, component: CrisisCenterComponent, children: [ { path: &apos;compose&apos;, component: ComposeMessageComponent }, { path: &apos;&apos;, component: CrisisListComponent, children: [ { path: &apos;:id&apos;, component: CrisisDetailComponent }, { path: &apos;&apos;, component: CrisisCenterHomeComponent } ] } ] } 本例中，组件CrisisCenterComponent和CrisisListComponent的模板中都有outlet出口定义，所以 ComposeMessageComponent将在CrisisCenterComponent的outlet渲染呈现 CrisisCenterHomeComponent和CrisisDetailComponent在CrisisListComponent的outlet呈现； 若距离最近的父组件没有outlet，则往上匹配，在更上一级父组件的outlet；举个例子，如果把path: ‘compose’放在于crisis-center同级，将直接匹配appcomponent的outlet位置；同理，如果放在于CrisisDetail同级作为list的子路由，则将优先匹配CrisisListComponent的outlet位置，不行再往上匹配 相对路由特性模块内部应该优先考试使用相对路由，以减少对上层路由的依赖“目录式”语法 ./或无前导斜线形式是相对于当前级别的。 ../会回到当前路由路径的上一级。 ../导航到一个兄弟路由，先回到上一级，然后进入兄弟路由路径 使用例子： this.router.navigate([crisis.id], { relativeTo: this.route })； this.router.navigate([&apos;../&apos;, { id: crisisId, foo: &apos;foo&apos; }], { relativeTo: this.route }); 使用RouterLink来进行导航，使用相同的链接参数数组，不过不需要提供relativeTo属性，因为ActivatedRoute已经隐含在了RouterLink指令中，下面定义与上面等效： &lt;a [routerLink]=&quot;[crisis.id]&quot;&gt; 最后，一些好东西：1 ) RouterLinkActive指令会基于当前的RouterState对象来为激活的RouterLink切换CSS类,这会一直沿着路由树往下进行级联处理，所以父路由链接和子路由链接可能会同时激活。使用routerLinkActiveOptions属性可以改变这种行为，比如： &lt;a routerLink=&quot;/contact&quot; routerLinkActive=&quot;Active&quot; [routerLinkActiveOptions]=&quot;{exact: true}&quot;&gt; &lt;/a&gt; 如上设置可以限制只有在其URL与当前URL精确匹配时才会激活指定的RouterLink 2 ) 路由器中的一些关键词 Router，路由器，为激活的URL显示应用组件，并管理从组件之间的导航 RouterModule，路由器模块，一个独立的Angular模块，用于提供所需的服务提供商，以及用来在应用视图之间进行导航的指令 Routes，路由数组，数组里每个成员都会把一个URL路径映射到一个组件。 Route，路由成员，定义路由器该如何根据URL模式（pattern）来导航到组件，大多数路由都由路径和组件类构成 RouterOutlet，路由出口，用来标记出路由器该在哪里显示视图 RouterLink，路由链接routerLink，该指令用来把一个可点击的HTML元素绑定到路由，点击带有绑定到字符串或链接参数数组的routerLink指令的元素就会触发一次导航 RouterLinkActiv，活动路由链接routerLinkActive，当HTML元素上或元素内的routerLink变为激活或非激活状态时，该指令为这个HTML元素添加或移除CSS类 ActivatedRoute，激活的路由，为每个路由组件提供提供的一个服务，它包含特定于路由的信息，比如路由参数、静态数据、解析数据、全局查询参数和全局碎片（fragment） RouterState，路由器状态，路由器的当前状态包含了一棵由程序中激活的路由构成的树。它包含一些用于遍历路由树的快捷方法 链接参数数组，这个数组会被路由器解释成一个路由操作指南。我们可以把一个RouterLink绑定到该数组，或者把它作为参数传给Router.navigate方法 路由组件，一个带有RouterOutlet的Angular组件，它根据路由器的导航来显示相应的视图 3 ) 特性领域的路由特征： 每个特性都有自己的路由模块。 每个特性区都有自己的根组件。 每个特性区的根组件中都有自己的路由出口及其子路由。 特性区的路由很少（或完全不）与其它特性区的路由交叉 4 ) 多路由出口在模板中，路由器只能支持一个无名主路由出口,但可以有多个命名的路由出口每个命名出口都自己有一组带组件的路由。多重出口可以在同一时间根据不同的路由来显示不同的内容 出口定义: &lt;router-outlet&gt;&lt;/router-outlet&gt; &lt;router-outlet name=&quot;popup1&quot;&gt;&lt;/router-outlet&gt; &lt;router-outlet name=&quot;popup2&quot;&gt;&lt;/router-outlet&gt; 配置路由对象： { path: &apos;compose&apos;, component: ComposeMessageComponent, outlet: &apos;popup&apos; } 使用方式： &lt;a [routerLink]=&quot;[{ outlets: { popup: [&apos;compose&apos;] } }]&quot;&gt;Contact&lt;/a&gt; 链接参数数组包含一个只有一个outlets属性的对象，它的值是另一个对象，这个对象以一个或多个路由的出口名作为属性名。 在这里，它只有一个出口名“popup”，它的值则是另一个链接参数数组，用于指定compose路由 注意：当有且只有一个无名出口时，外部对象中的这个outlets对象不是必须的，路由器假设这个路由指向了无名的主出口，并为我们创建这些对象。当路由到一个命名出口时，我们就会发现这个隐藏的真相 关闭命名出口： this.router.navigate([{ outlets: { popup: null }}]); 各个outlet出口独立导航：路由器在导航树中可以对多个独立的分支保持追踪，并在URL中对这棵树进行表达。我们可以添加更多出口和更多路由（无论是在顶层还是在嵌套的子层）来创建一个带有多个分支的导航树， 路由器将会生成相应的URL。通过像前面那样填充outlets对象，我们可以告诉路由器立即导航到一棵完整的树。 然后把这个对象通过一个链接参数数组传给router.navigate方法 5 ) 各类路由参数的定义提取的区别 path参数：url/:id使用方式：router.navigate([url,123]); [routerLink]=”[url, 123]”表现形式：url/123提取方式：this.activateRoute.params.subscribe((params: Params)) =&gt; { let id = params[‘id’]; }); 可选参数使用方式：router.navigate([url,{id: 123}]); [routerLink]=”[url, {id: 123}]”表现形式：url;id=123提取方式：this.activateRoute.params.subscribe((params: Params)) =&gt; { let id = params[‘id’]; }); 查询参数使用方式：router.navigate([url], {queryParams: {id: 123}}); [routerLink]=”[url]” [queryParams]=”{id: 123}”表现形式：url?id=123提取方式：this.activateRoute.queryParams.subscribe((params: queryParams)) =&gt; { let id = params[‘id’]; }); 片段使用方式： router.navigate([url], {fragment: ‘anchor’}); [routerLink]=”[url]” [fragment]=”‘anchor’” 表现形式：url?fragment=anchor提取方式： this.activateRoute.fragment.subscribe((fragment: any) =&gt; { let fragment = fragment || &apos;None&apos;; }); 查询参数和片段经常用来携带需要持久化的信息，来为每个页面都提供的信息，如认证令牌或会话的 ID 等。 6 ) navigate和navigateByUrl相同点：底层都是调用的相同的方法router.scheduleNavigation()进行处理和导航不同点：a. 使用方式不同：navigate([]) ; navigateByUrl(url) 比如下面两个效果是一样: navigate([url, 123]);navigateByUrl(‘url/123’);b. navigate可以实现相对路由，而navigateByUrl不行 7 ) 导航事件在每次导航中，Router 都会通过 Router.events 属性发布一些导航事件: NavigationStart,导航开始时触发 RouteConfigLoadStart,惰性加载某个路由配置之前触发。 RouteConfigLoadEnd,惰性加载了某个路由后触发。 RoutesRecognized,在路由器解析完 URL，并识别出了相应的路由时触发 GuardsCheckStart,在路由器开始 Guard 阶段之前触发。 ChildActivationStart,路由器开始激活路由的子路由时触发。 ActivationStart,路由器开始激活某个路由时触发。 GuardsCheckEnd,路由器成功完成了 Guard 阶段时触发。 ResolveStart,开始解析（Resolve）阶段时触发。 ResolveEnd,路由器成功完成了路由的解析（Resolve）阶段时触发。 ChildActivationEnd,路由器激活了路由的子路由时触发。 ActivationEnd,路由器激活了某个路由时触发。 NavigationEnd,导航成功结束之后触发。 NavigationCancel,导航被取消之后触发 NavigationError,导航由于意料之外的错误而失败时触发。 Scroll,一个滚动事件 想要看到这些事件，可以使用路由器默认配置中的 enableTracing 选项，它会把每个导航生命周期中的事件输出到浏览器的控制台，一般只用于调试 @NgModule({ imports: [ RouterModule.forRoot( appRoutes, { enableTracing: true } ) ... ], ... })","tags":[{"name":"Augular","slug":"Augular","permalink":"http://blueskyawen.com/tags/Augular/"}]},{"title":"Angular-注入器","date":"2017-07-16T09:16:49.000Z","path":"2017/07/16/angular-Injector/","text":"依赖注入是一种程序设计模式，指的是在应用构建里将所需的服务或者部件委托给第三方厂商提供，自身只关注应用逻辑，需要什么服务只需从厂商请求即可，而不用关心服务具体的创建过程和升级相对于以前大而全的设计方式，这种思路的转变，可以使应用本身和所需的服务相对独立的开发和升级，而不用存在太大的耦合，下面是简单的示意图：在angular里，自带的“依赖注入框架”和注入器就扮演着这样的一个角色，为构建angular应用的服务需求提供了可靠的提供机制，简便了应用的搭建 一. 注入器树注入器树时angular基本树之一，在官方的angular高级文档-多级注入器一章里已经作了相对清晰的讲解，描述的是和另一基本树-组件树平级对应的注入器，组件树里的每一个组件节点都可以拥有自己的注入器，于是便有了这个注入器树，这个很好理解这里不再赘述，这里要描述的是由angular中多个不同类型注入器组成的多级注入器树在angular中，根据注入器的启动时间和使用范围的不同，可划分为以下几种: 根注入器在main.ts里引导启动应用时，即创建了根注入器，整个应用范围内有效；除了根模块的privodes里的供应商直接注册到根注入器之外，直接导入到根模块的其他模块里的供应商也是注册根注入器 模块子注入器指懒加载模块内的注入器，在加载后启动，使用范围限于本模块，供应商注册在子注入器中，包括被导入模块的供应商 组件注入器指组件内的注入器，供应商在组件的privode数组内声明，只在组件和子组件范围内有效，且每个组件实例都有一份属于自己的注入器。在组件级提供服务可以确保组件的每个实例都得到一个自己的、私有的服务实例 多级注入器树由这些不同的注入器构成，树的结构与模块/组件的组织有着相似的层级和对应关系，下图是一个简单的注入器树示意： 为什么惰性加载模块会创建一个子注入器？ 原因来自于 Angular 依赖注入系统的一个基本特征： 在注入器还没有被第一次使用之前，可以不断为其添加提供商。 一旦注入器已经创建和开始交付服务，它的提供商列表就被冻结了，不再接受新的提供商。当应用启动时，Angular 会首先使用所有主动加载模块中的提供商来配置根注入器，这发生在它创建第一个组件以及注入任何服务之前。 一旦应用开始工作，应用的根注入器就不再接受新的提供商了。之后，应用逻辑开始惰性加载某个模块，Angular 必须把这个惰性加载模块中的提供商添加到某个注入器中。 但是它无法将它们添加到应用的根注入器中，因为根注入器已经不再接受新的提供商了。 于是，Angular 在惰性加载模块的上下文中创建了一个新的子注入器。对于组件内的子注入器原理也一样。。 二.服务的注入angular应用中配置使用注入服务需要定义可注入服务，注册供应商，服务请求等几个步骤，下面描述一下： 1) 声明可注入服务使用@Injectable()声明可注入服务，Injectable标识一个类可以被注入器实例化，示例如下： import { Injectable } from &apos;@angular/core&apos;; import { HEROES } from &apos;./mock-heroes&apos;; import { Logger } from &apos;../logger.service&apos;; @Injectable() export class HeroService { constructor(private logger: Logger) { } getHeroes() { this.logger.log(&apos;Getting heroes ...&apos;); return HEROES; } } @Injectable()装饰器把一个类标识为注入器实例化的目标，试图实例化没有被标识Injectable的类时，注入器会报错。 2) 注册提供商什么是提供商提供商即服务供应商，提供了依赖值的一个具体的版本，指导注入器如何创建服务。注入器依靠提供商提供的版本来创建服务实例，然后将服务的实例注入组件或其它服务 提供商的种类提供商没有严格的定义，可以有很多种，只要它们能交付一个行为类似的对象即可，比如：类、对象、工厂函数、变量值等 提供商声明(1) 类供应商providers：[{ provide: key令牌, useClass: 对象实例 }] 比如： providers：[{ provide: Logger, useClass: Logger }] providers：[Logger] //简化版 (2) 备选服务供应商使用超类作key令牌，子类作为实例化类，例如： @Injectable() class EvenBetterLogger extends Logger { constructor(private userService: UserService) { super(); } log(message: string) { let name = this.userService.user.name; super.log(`Message to ${name}: ${message}`); } } providers：[{ provide: Logger, useClass: EvenBetterLogger}] (3) 别名服务供应商使用已定义的类作为实例化类，其他类名作key令牌，例如： providers：[NewLogger， { provide: Logger, useExisting: NewLogger}] (3) 值依赖供应商使用一个对象或者变量作为供应商对像，这在一些全局参数配置中有重要的用处，例如： const silentLogger = { logs: [&apos;Silent logger says &quot;Shhhhh!&quot;. Provided via &quot;useValue&quot;&apos;], log: () =&gt; {} }; providers：[{ provide: Logger, useValue: silentLogger}] 注意：供应商在一个注入器中不能重复注册，否则会出现多个相同的实例，这是不被期望的 3) 服务注入请求作为重要的一步是用户如何进行注入请求，因为服务最终是要用于应用中，否则前面的配置都没有什么意义，服务注入分为隐式注入和显式注入两种 （1）隐式注入最常见的注入配置时在我们组件构造函数里通过供应商令牌进行服务申请，比如： constructor(private logger: Logger) {} constructor声明 + @component + provide供应商数组 共同指示注入器要注入服务实例，以及怎么进行注入注意，我们在请求时是使用的供应商令牌来向注入器请求的，即上一节中的provide字段，而不管对应的实际供应商类或对象时哪个，注入器会自动根据令牌匹配一个服务实例来给组件使用，如果匹配不到，则创建一个,并将实例引用赋予变量logger实际上，在angular实现中，向注入器注册提供商时，会把这个提供商和一个DI令牌关联起来了，注入器自身会维护一个内部的令牌-提供商映射表，在请求依赖会从这个映射表查找提供商实例，而令牌就是这个表的键值，这就是为什么请求时使用的是令牌 （2）显式注入有两种显示注入方式，不过不提倡这么使用方式一：直接创建注入器 injector : any; constructor() { this.injector = ReflectiveInjector.resolveAndCreate([Logger, HeroService]); let logger = injector.get(Logger); } 方式二：直接使用注入器 heroService : any; constructor(private injector: Injector) {} ngOnInit() { this.heroService = this.injector.get(HeroService); } 4) 服务注入配置示意图服务注入的几个方面可以在下图得到体现 三.多级注入系统点击这里查看原文，这里只是作一些总结 1) 嵌套式注入器Angular多级依赖注入系统支持与组件树并行的嵌套式注入器，应用程序中有一个与组件树平行的注入器树，我们可以在组件树中的任何级别上重新配置注入器每个组件实例都有自己的注入器，也许说不对，组件可以没有注入器，但这时候说的组件的注入器可能是一个组件树中更高级的祖先注入器的代理，可以理解为组件存了上级注入器的一个指针，,这只是提升效率的实现细节，只要想象成每个组件都有自己的注入器就可以了。 2) 注入冒泡angular自下而上冒泡的方式匹配使用的服务依赖，具体来讲，当一个组件请求一个服务时，Angular 先尝试用本组件自己的注入器来满足它，如果在该组件的注入器没有找到对应的提供商，它就把这个请求转给它父组件的注入器来处理；如果父组件注入器也无法满足这个申请，则继续往上传递，一直到找到了一个能处理此请求的注入器，或者超出了组件树中的祖先位置还未找到，抛出一个错误 3) 不同层级再次提供同一个服务在应用实现中，可以在注入器树中的多个层次上为指定的依赖令牌重新注册提供商，即同一个服务可以在多个层级上重新配置，多个子注入器都具有该服务的实例，根据注入的冒泡匹配原则，遇到的第一个提供商实例会胜出因此，注入器树中间层注入器上的提供商，可以拦截来自底层的对特定服务的请求，导致它可以“重新配置”和者说“遮蔽”高层的注入器带来的好处： 服务隔离,服务范围限制在组件内，别的组件不可访问 组件特殊的提供商,下级组件可重新定义与上级同名的服务，定义自己特殊的实现 多重编辑会话，每个组件实例拥有自己的服务实例，可以存放处理自己的数据 最后，一些好东西：1 . 在一个注入器的范围内，依赖都是单例的,比如在应用范围内的根注入器，各个依赖值都是单例的 2 . 注入器同时会实例化Component这样的组件,为什么不标记他们为@Injectable()呢？因为没有必要，因为组件已经有@Component装饰器， 而@Component/@Directive/@Pipe等装饰器都是 @Injectable的子类 3 . 可选依赖，使用@Optional()定义可选依赖，这样即使在注入器里没有这个服务，像这样： import { Optional } from &apos;@angular/core&apos;; constructor(@Optional() private logger: Logger) { if (this.logger) { this.logger.log(some_message); } } 这样的话在providers数组里可以不声明Logger，不会出错。不过使用的时候需要处理空值，因为当注入找不到这个服务时会返回一个null 4 . 非类依赖服务当注入对象是一个字符串，函数或者接口对象时，没有对应的合适令牌可供使用，可采用InjectionToken作为提供商令牌，像这样： //注入对像 export interface AppConfig { apiEndpoint: string; title: string; } export const HERO_DI_CONFIG: AppConfig = { apiEndpoint: &apos;api.heroes.com&apos;, title: &apos;Dependency Injection&apos; }; //令牌 import { InjectionToken } from &apos;@angular/core&apos;; export let APP_CONFIG = new InjectionToken&lt;AppConfig&gt;(&apos;app.config&apos;); //提供商 providers: [{ provide: APP_CONFIG, useValue: HERO_DI_CONFIG }] //使用@Inject装饰器帮忙注入使用 constructor(@Inject(APP_CONFIG) config: AppConfig) { this.title = config.title; } 5 . getter值可直接作为变量应用于模板中，比如： get hero() {return service.getOneHero();} hero可直接作为变量应用于模板表达式中 6 . @host,用于组件的服务注入只能从上一级父组件查找实例，不再往更上一级的冒泡 constructor(@host() private logger: Logger) { if (this.logger) { this.logger.log(some_message); } } 7 . 在根组件和根模块提供服务的区别 根组件，注册的服务可在应用全局所有子组件内使用 根组件，注册的服务可在全应用范围内有效，并且可在应用启动前提供部分服务 8 . 不同级别的组件和模块可声明同名的服务，使用时注入器会根据冒泡的规则来进行第一匹配；通常，通过基类来作为令牌，派生的各个子类作为各级的真正供应商; export class loger { log : string; get log() { return this.log;} set log(); } export class Deploger extends loger { set log() {} } providers[{ provide: loger, useclass: Deploger}] providers[{ provide: loger, useExsiting: Deploger}] 使用这个方式还能控制服务API暴露的接口数 9 . 注入服务到子类 export class baseHero { constructor(private serviceA : ServiceA) { } } export class Hero extends baseHero { constructor(private service_A : ServiceA,private service_B : ServiceB) { super(service_A);//初始化基类服务参数 } } 初始化时OnInit()的调用顺序：子类 –&gt; 基类 10 . 子组件注入父组件先认识下面两点： 不能用基类注入父组件实例 组件总是优先在自身的注入器中添加组件自己的实例的，所以理论上子组件可从注入中获取任何组件实例，包括父组件 使用方式： //父组件通过前向引用声明自己 providers[{ provide: Parent, useExsiting: forwardRef(() =&gt; ParentComponent)}] constructor(@skipself() private parent: Parent) { if (this.parent) { this.parent.log(some_message); } } //子组件注入使用 constructor(@host() private parent: Parent) { if (this.parent) { this.parent.log(some_message); } } @skipself()忽略自己 可以使用const声名全局变量或或者方法： const MAX_NUM = 10000； //重构上面对父组件的注入声明 const provideParent = (component: any, parentType?: any) =&gt; { return { provide: parentType || Parent, useExisting: forwardRef(() =&gt; component) }; }; providers: [ provideParent(BethComponent, DifferentParent) ] 11 . 类接口令牌一个组件不能使用基类当做令牌，却可以使用类接口当做令牌，类接口是一个抽象类 export abstract class Parent { name: string; } @Component({ selector: &apos;barry&apos;, template: templateB, providers: [{ provide: Parent, useExisting: forwardRef(() =&gt; BarryComponent) }] }) export class BarryComponent implements Parent { name = &apos;Barry&apos;; constructor( @SkipSelf() @Optional() public parent: Parent ) { } } //这种使用方式不行 export class BarryComponent extends Parent { name = &apos;Barry&apos;; constructor( @SkipSelf() @Optional() public parent: Parent ) { } } 12 . 工厂提供商useFactory 提供了一个键，让你可以通过调用一个工厂函数来创建依赖实例，使用这项技术，可以用包含了一些依赖服务和本地状态输入的工厂函数来建立一个依赖对象,比如下面这个例子： export function runnersUpFactory(take: number) { return (winner: Hero, heroService: HeroService): string =&gt; { ... }; }; { provide: RUNNERS_UP, useFactory: runnersUpFactory(2), deps: [Hero, HeroService] } 注入器通过调用你用 useFactory 键指定的工厂函数来提供该依赖的值。 注意，提供商的这种形态还有第三个键 deps，它指定了供 useFactory 函数使用的那些依赖。 13 . 使用 @Inject 指定自定义提供商自定义提供商让你可以为隐式依赖提供一个具体的实现，比如下面这个例子，使用 InjectionToken 来提供 localStorage，将其作为 BrowserStorageService 的依赖项。 import { Inject, Injectable, InjectionToken } from &apos;@angular/core&apos;; export const BROWSER_STORAGE = new InjectionToken&lt;Storage&gt;(&apos;Browser Storage&apos;, { providedIn: &apos;root&apos;, factory: () =&gt; localStorage }); @Injectable({ providedIn: &apos;root&apos; }) export class BrowserStorageService { constructor(@Inject(BROWSER_STORAGE) public storage: Storage) {} get(key: string) { this.storage.getItem(key); } set(key: string, value: string) { this.storage.setItem(key, value); } remove(key: string) { this.storage.removeItem(key); } clear() { this.storage.clear(); } } 现在，就可以在测试期间使用 localStorage 的 Mock API 来覆盖这个提供商了，而不必与真实的浏览器 API 进行交互。 14 . @Self 装饰使用 @Self 装饰器时，注入器只在该组件的注入器中查找提供商。@SkipSelf 装饰器可以让你跳过局部注入器，并在注入器树中向上查找，以发现哪个提供商满足该依赖。这两个结合起来能组合很有趣的服务注入： providers: [ BrowserStorageService, { provide: BROWSER_STORAGE, useFactory: () =&gt; sessionStorage } ] constructor( @Self() private sessionStorageService: BrowserStorageService, @SkipSelf() private localStorageService: BrowserStorageService, ) { } 这样就会只使用当前层次声明的服务，但是要注意处理异常。在组件的继承中，当父子组件都拥有ngOnInit方法时，初始化的时候Angular 会先调用派生类的 ngOnInit，后调用基类的 ngOnInit","tags":[{"name":"Augular","slug":"Augular","permalink":"http://blueskyawen.com/tags/Augular/"}]},{"title":"Angular-模块","date":"2017-07-15T08:39:05.000Z","path":"2017/07/15/angular-module/","text":"Angular采用模块的形式来组织应用，将相关业务功能或者有内部联系的部分进行内聚化设计，封装成单独的模块，而整个应该则由多个模块来构成 应用模块化模块化是一种设计模式，有着明显的优点: 打包特定领域/工作流的功能,隔离功能实现 方便组织应用，多个模块可独立开发 方便导入使用外部控件，很多Angular库和第三方库都是以模块形式提供，例如：FormsModule、HttpModule、RouterModule等 方便把服务加到应用程序中 模块化带来应用设计的简易化，应用组织就像搭积木一样方便，像这样： 模块的组成模块在angular里只是由@NgModule装饰器提供元数据的类，这个元数据对象指示如何编译和运行该模块，基本构成： @NgModule({ imports:[], //导入其它模块 declarations: [], // 声明组件指令管道 providers: [] //声明服务提供商 exports: [] //公开某些类 }) export class ContactModule { } (1) imports模块导入支持模块，会发生几件事：1 . 被导入模块公开的组件/指令/管道将和导入目标模块declarations合并，并供目标模块使用，但导入的成员优先级没目标模块的高2 . 被导入模块的providers会累加到导入目标模块的提供商，追加到@NgModule.providers中，并把它们注入到目标模块一级的注入器，比如导入到根模块，则注入到根注入器3 . 被导入的模块的路由和导入目标模块路由将合并 (2) declarations[]该数组声明本模块所拥有的组件，指令，管道等成员，数组里成员有以下特点： 数组里声明的成员默认都是私有的，除非放进exports公开他们 一个组件/指令/管道只能属于一个模块，不能同时把一个类声明在几个模块中 数组里的成员可以公开给其他模块直接导入使用 (3) providers[]模块是为模块中所有成员提供服务的最佳途径，在模块中声明服务提供商有几个特点： 模块内声明的服务商是模块级的，可供模块所有组件或其他成员使用 如果此模块被直接导入到根模块时，服务商注册到根注入器，整个应用都可使用 如果此模块被导入到延迟模块，则注入到模块子注入器，可供延迟模块内使用 延迟加载模块是限制服务商在模块内生效的唯一途径 (3) exports[]设置公开成员，至于在公开数组里声明的成员才能其他模块导入使用，可供导出的成员类型有如下几种： declarations数组中的成员 imports数组中的模块 不在imports数组中的其他模块(可不导入就直接导出) 模块成员导入后有两种使用方式：1 . 通过选择器直接在模板中使用，使用于组件/指令/管道2 . 通过路由导航来使用，适用于导入的组件，不过更好的设计是将路由移至被导入模块，导入后合并路由即可 如果是在本模块路由到导入模块的某个组件时，该组件不必公开，私有属性直接导入即可 模块树模块树是组成angular的基本树之一，体现了应用的基本结构,angular一般可通过直接导入和懒加载两种方式来将各个模块联系在一起，下图是一个基本模块树的关联结构： 应用模块的组建方式一个angular应用一般有四种类型的模块： 引导模块(AppModule)，一般指根模块，用于引导和组织整个应用 核心模块(CoreModule)，用于封装一次性的类，隐藏它们的实现细节，一般包含只在应用启动时使用到的组件类和全应用级服务提供商，根模块导入它来获取相关能力 共享模块(ShareModule)，用于封装公共组件、指令和管道，共享给那些需要它们的模块， 特性模块(FeatrueModule)，用于封装工作流和业务功能 下图是一个应用中模块的典型组建方式 最后，一些需要注意的细节：1 . 根模块和特性模块共享着相同的执行环境和同一个依赖注入器，在某个模块中定义的服务在所有其他模块中也都能用。特性模块通过自己提供的服务和对外公开的组件、指令、管道来与其它模块进行协同工作 2 . 在根注入器注册的提供商，每个服务均为单例，在全应用范围的组件都可使用，无论组件时主动导入还是惰性加载的 3 . 共享模块中不应出现providers服务商，否则如果一个惰性加载模块导入了此共享模块，就会相应生成一份服务的实例，这个在设计中时不被期望的 4 . 导入目标模块不会继承被导入模块中对组件、指令或管道的访问权，两个模块的imports数组是互不相干的，除非被导入模块将导入模块重新导出。所以，对公共模块的使用，并不是在根模块导入一次就可以了，而应该在每一个需要使用的模块中都需要导入 5 . 被导入模块的公开指令的优先级小于导入目标模块的指令，渲染时先执行导入的后执行本模块的，如果有同名指令存在，本模块的覆盖导入的；而如果在本模块的declarations如果有同名指令，后申明的覆盖先申明的 6 . 多次导入同一个指令是没问题的，Angular 会移除重复的类，只注册一次。但如果有两个不同的类，只是恰好有相同的名字，angular认为并没有重复，会同时保留这两个指令，只是在使用的时候两个指令都会先后调用到，优先级高的获最后结果 7 . 显式添加到AppModule中的那些提供商在优先级上要优于从其它模块中导入的提供商 8 . 立即模块加载是直接导入，在应用启动时加载它的路由和组件；懒加载模块是通过路由进行惰性加载，指的是用户第一次访问时异步获取加载文件，加载速度取决于浏览器一次加载文件的数量，比如：谷歌一般一次8个，所以要规划好懒加载模块的大小，以免加载时间过长 9 . 对于惰性加载模块，一般不要直接导入使用，因为一般这种模块都会有自己的路由配置，导入的同时也会导入它的路由，会对目标模块的路由导航造成影响，因为路由匹配是第一次匹配到即胜出的原则，如果惰性模块的路由和目标模块相似，会引起不必要的错误 10 . 只能在根模块AppModule中导入BrowserModule,在其它任何模块中都不要导入BrowserModule。特性模块和惰性加载模块应该改成导入CommonModule, 它们需要通用的指令,它们不需要重新初始化全应用级的提供商。如果你在惰性加载模块中导入BrowserModule，Angular就会抛出一个错误, 特性模块中导入CommonModule可以让它能用在任何目标平台上。 11 . Angular不允许模块之间出现循环依赖，所以不要让模块’A’导入模块’B’，而模块’B’又导入模块’A’ 12 . 静态方法forRoot和forChild是一个约定，它可以让开发人员更轻松的配置模块的提供商。RouterModule.forRoot就是一个很好的例子,应用把一个Routes对象传给forRoot（），为的就是使用路由配置全应用级的Router服务。只能在应用的根模块AppModule中调用并导入.forRoot的结果。 在其它模块中导入它，特别是惰性加载模块中，是违反设计目标的并会导致一个运行时错误。RouterModule也提供了静态方法forChild，用于配置惰性加载模块的路由。 13 . 导入的提供商很容易被由其它导入模块中的提供商替换假设模块需要一个定制过的HttpBackend，它为所有的Http请求添加一个特别的请求头。 如果应用中其它地方的另一个模块也定制了HttpBackend或仅仅导入了HttpModule，它就会改写当前模块的HttpBackend提供商，丢掉了这个特别的请求头。 这样服务器就会拒绝来自该模块的请求。如果你必须防范这种“提供商腐化”现象，那就不要依赖于“启动时加载”模块的providers。 14 . 如何知道一个模块或服务是否已经加载过了？ src/app/core/core.module.ts (Constructor) constructor (@Optional() @SkipSelf() parentModule: CoreModule) { if (parentModule) { throw new Error( &apos;CoreModule is already loaded. Import it in the AppModule only&apos;); } } 15 . Angular总是会动态加载AppComponent,无论把它的类型列在了@NgModule.bootstrap函数中，还是命令式的调用该模块的ngDoBootstrap方法来引导它。在路由定义中用到的组件也同样是入口组件,路由定义根据类型来引用组件,忽略路由组件的选择器（即使它有选择器），并且把该组件动态加载到RouterOutlet中。编译器无法通过在其它组件的模板中查找来发现这些入口组件。 我们必须通过把它们加入entryComponents列表中来让编译器知道它们的存在。Angular会自动把下列类型的组件添加到模块的entryComponents(入口组件)中： 那些出现在@NgModule.bootstrap列表中的组件。 那些被路由定义引用的组件。 我们并不需要显式的引用这些组件,虽然引用了也没坏处。 16 . 引导组件是入口组件的一种。 它是被Angular的引导（应用启动）过程加载到DOM中的入口组件。 其它入口组件则是被其它方式动态加载的，比如被路由器加载。@NgModule.bootstrap属性告诉编译器这是一个入口组件，同时它应该生成一些代码来用该组件引导此应用。不需要把组件同时列在bootstrap和entryComponent列表中 —— 虽然这样做也没坏处 17 . 虽然你可以使用惰性加载模块来提供实例，但不是所有的服务都能惰性加载。比如，像路由之类的模块只能在根模块中使用。路由器需要使用浏览器中的全局对象 location 进行工作 18 . 在应用搭建中根据实际需要可作不同的划分 (1) 根据功能不同可分为：根模块，特性模块，懒加载模块，路由模块，服务模块，库模块(2) 根据代码组织不同还可以分为：根模块，核心模块，共享模块，路由模块，服务模块，特性模块","tags":[{"name":"Augular","slug":"Augular","permalink":"http://blueskyawen.com/tags/Augular/"}]},{"title":"Hexo博客添加评论模块","date":"2017-06-10T16:43:11.000Z","path":"2017/06/11/hexo-add-pinglun/","text":"写好的东西总希望和人一起讨论分享，下面来给博客增加评论系统Yilia组图集成了多说，网易云跟帖，畅言，Disqus等众多评论系统，只需要简单的设置即可实现功能在这以网易云跟帖为例子说明 注册账号点击这里到网易云跟帖网站，按照流程注册账号，登录之后进入后台管理，填写站点信息，网址时你申请的域名获取代码到主题的/themes/yilia/layout/_partial/post/wangyiyun.ejs文件下，替换其内容 配置主题文件在/themes/yilia/_config.yml中找到评论配置,将wangyiyun改成true #评论：1、多说；2、网易云跟帖；3、畅言；4、Disqus 不需要使用某项，直接设置值为false，或注释掉 #具体请参考wiki：https://github.com/litten/hexo-theme-yilia/wiki/ #1、多说 duoshuo: false #2、网易云跟帖 wangyiyun: true #3、畅言 changyan_appid: false changyan_conf: false #4、Disqus 在hexo根目录的config里也有disqus_shortname字段，优先使用yilia的 disqus: false 重新执行Hexo命令三件套，重新部署站点，查看效果","tags":[{"name":"hexo","slug":"hexo","permalink":"http://blueskyawen.com/tags/hexo/"}]},{"title":"Hexo博客绑定个人域名","date":"2017-06-10T16:28:14.000Z","path":"2017/06/11/hexo-bind-domain/","text":"之前搭建完博客并且部署到github上以后，已经可以通过github.io地址来访问我的博客页面但这个地址这是仓库地址，缺乏个性，也为注册其他插件带来问题我在想，如果有自己的域名就好了，说干就干，由于已经在阿里云有了账号，下面以阿里云为例描述绑定域名的过程 一.购买域名进入阿里云官网，登录到域名购买页面输入个性的域名，查询注册情况，只要没被注册即可使用 二.身份认证注册完域名后，进入到自己的域名列表后需要进行个人信息填写和实名认证，这一步很重要，不然不能进行解析，一段时间后会被挂起状态，不能正常使用，所以还是认证的好，认证步骤有详细的提示，这里就不赘述了 三.域名解析进入到自己的域名列表，点击域名操作的解析，进入域名解析页面点击添加解析，填写配置： 类型–选择CNAME主机记录--@线路–默认记录值–填写博客仓库的名字：”your_github_name.github.io” 点击保存即可 四.仓库配置回到github仓库，在别根目录下增加名为CNAME的文件，内容为刚刚申请的域名为了防止以后部署提交会覆盖这个文件，可以在本地机子增加这个文件，然后PUSH到仓库里去 五.配置文件修改这个主要是要修改我们根目录的_config.yml，设置站点为/，否则如果存在子目录的话，部署后的主题会失效 # URL ## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos; url: http://blueskyawen.com/ root: / 至此，域名更换和配置已经完全结束了，可以使用域名访问站点试试","tags":[{"name":"hexo","slug":"hexo","permalink":"http://blueskyawen.com/tags/hexo/"}]},{"title":"Hexo主题配置","date":"2017-06-10T16:19:19.000Z","path":"2017/06/11/hexo-theme/","text":"之前搭建的博客有自己默认的主题，个人不喜欢，觉得略丑，体验也不好，于是懂了更换主题的念头。Hexo主题非常多，官网上主题库里有很多优秀的主题，大家可以根据自己的喜好来选择合适的主题由于Hexo是一款非常优秀的开源博客系统，所以github上也有大量的主题可供选择下面是github上star数量最多的前10个主题： iissnan/hexo-theme-next， 3510个star。litten/hexo-theme-yilia， 1703个star。TryGhost/Casper， 679个star。wuchong/jacman， 503个star。A-limon/pacman， 431个star。daleanthony/uno， 416个star。orderedlist/modernist， 367个star。AlxMedia/hueman， 336个star。kathyqian/crisp-ghost-theme， 303个star。xiangming/landscape-plus， 287个star。 我用的就是hexo-theme-yilia，感觉这个主题页面简单，正合心意1.clone主题代码在博客目录下执行命令clone主题代码： $ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 完事在主题目录themes里增加yilia的主题代码 2.配置主题在博客根目录的_config.yml文件中，配置新主题 3.修改主题配置信息修改themes/yilia/_config.yml文件，修改的时候，每个冒号后面都需要留一个英文空格，不然报错，下面时我的配置文件，仅供参考 # Header menu: 主页: / 归档: /archives 随笔: /categories/随笔 相册: /photos # SubNav subnav: github: &quot;https://github.com/blueskyawen&quot; weibo: &quot;#&quot; rss: &quot;#&quot; zhihu: &quot;#&quot; qq: &quot;#&quot; #weixin: &quot;#&quot; #jianshu: &quot;#&quot; #mail: &quot;mailto:litten225@qq.com&quot; #facebook: &quot;#&quot; #google: &quot;#&quot; #twitter: &quot;#&quot; #linkedin: &quot;#&quot; rss: /atom.xml # 是否需要修改 root 路径 # 如果您的网站存放在子目录中，例如 http://yoursite.com/blog， # 请将您的 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/。 root: / # Content # 文章太长，截断按钮文字 excerpt_link: more # 文章卡片右下角常驻链接，不需要请设置为false show_all_link: &apos;展开全文&apos; # 数学公式 mathjax: false # 是否在新窗口打开链接 open_in_new: false fancybox: true top: true # 是否开启动画效果 animate: true # 打赏 # 请在需要打赏的文章的md文件头部，设置属性reward: true # 打赏基础设定：0-关闭打赏； 1-文章对应的md文件里有reward:true属性，才有打赏； 2-所有文章均有打赏 reward_type: 2 # 打赏wording reward_wording: &apos;请随意打赏&apos; # 支付宝二维码图片地址，跟你设置头像的方式一样。比如：/assets/img/alipay.jpg alipay: /images/IMG_zhifubao.jpg # 微信二维码图片地址 weixin: /images/IMG_weixin.jpg # Miscellaneous分析统计工具 baidu_analytics: &apos;&apos; #google_analytics: &apos;&apos; favicon: /images/favicon.jpg #你的头像url avatar: /images/touxiang.jpg #是否开启分享 share_jia: true share_addthis: false #评论：1、多说；2、网易云跟帖；3、畅言；4、Disqus 不需要使用某项，直接设置值为false，或注释掉 #具体请参考wiki：https://github.com/litten/hexo-theme-yilia/wiki/ #1、多说 duoshuo: false #2、网易云跟帖 wangyiyun: true #3、畅言 changyan_appid: false changyan_conf: false #4、Disqus 在hexo根目录的config里也有disqus_shortname字段，优先使用yilia的 disqus: false # 样式定制 - 一般不需要修改，除非有很强的定制欲望… style: # 头像上面的背景颜色 header: &apos;#003f80&apos; # 右滑板块背景 slider: &apos;linear-gradient(200deg,#a0cfe4,#e8c37e)&apos; # slider的设置 slider: # 是否默认展开tags板块 showTags: false # 智能菜单 # 如不需要，将该对应项置为false # 比如 #smart_menu: # friends: false smart_menu: innerArchive: &apos;所有文章&apos; friends: &apos;链接&apos; aboutme: &apos;关于我&apos; friends: 天猫商城: https://www.tmall.com 阿里云: https://www.aliyun.com 携程: http://www.ctrip.com ZTE: http://www.zte.com.cn aboutme: 前端菜鸟&lt;br&gt;正在学习的路上前行&lt;br&gt;现就职于某通讯企业&lt;br&gt;长路漫漫，渐行渐远 4.查看主题效果仍然使用命令三件套来重新生成和部署站点，效果如下：","tags":[{"name":"hexo","slug":"hexo","permalink":"http://blueskyawen.com/tags/hexo/"}]},{"title":"hexo搭建个人博客","date":"2017-05-31T16:21:20.000Z","path":"2017/06/01/hexo-build-blok/","text":"一直想有一个自己的站点，用来写点东西，记录学习和生活偶然的机会，见识到了同事的博客，体验甚好，更加触动了自己搭建个人站点的想法从同事了解了下是用Hexo来搭建的，Hexo是一个超轻量级的博客系统，搭建起来很方便，我时自己百度各种资料，上官网学习，一步步搭建起来的，过程中也遇到各种问题，现总结一下，希望有所用。 一. 安装node.js和npm网上的安装指导教程很多，根据机器系统的不同有所不同，我的机子时ubuntu的，我是使用apt-get命令安装的 $ sudo apt-get install nodejs $ sudo apt-get install npm 看版本号有东西说明安装成功了 $ node -v v7.10.0 $ npm -v 4.2.0 推荐在线教程：菜鸟教程-Node.js 安装配置 二. 安装gitgit的安装方式也较多，可以百度搜一下，我是用apt-get安装的 $ apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \\ libz-dev libssl-dev $ apt-get install git-core $ git --version git version 2.9.3 推荐在线教程：菜鸟教程-Git 安装配置 三. 注册github点击上github官网，按照网站提示注册就可以了，注册成功后要去自己的邮箱验证接下来设置SSH-Key链接 ssh-keygen -t rsa -C &quot;email_name@163.com&quot; Generating public/private rsa key pair. Enter file in which to save the key (/Users/root/.ssh/id_rsa): -&gt;按回车 Enter passphrase (empty for no passphrase): -&gt;输入密码 Enter same passphrase again: -&gt;再次输入密码 然后在个人账号的setting-&gt;SSH and GPG keys里点击Add SSH Key添加公开密钥即可，密钥为刚刚生成的id_rsa.pub文件里的内容，官网里也有添加SSH指导 四. 建立blog仓库官网有个给初学者提供的github的hello-world指导文档，可以先熟悉仓库的建设和分支管理创建博客仓库主要是创建和用户名对于的仓库，比如github用户名时blueskyawen,仓库名就叫blueskyawen.github.io创建github page进入刚刚创建的博客代理仓库，选择Settings进入设置页面，在GitHub Pages配置页面和主题,然后既可以通过地址:’your_name.github.io’来访问站点页面了 五. 安装配置Hexo这里时核心也是最重要的部分，有时间的人可以阅读hexo官网文档来学习全局安装hexo npm install hexo-cli -g 或 npm install -g hexo-cli 查看版本，有说明安装成功 hexo -v hexo-cli: 1.0.2 os: Linux 4.8.0-52-generic linux x64 http_parser: 2.7.0 node: 7.10.0 v8: 5.5.372.43 uv: 1.11.0 zlib: 1.2.11 ares: 1.10.1-DEV modules: 51 openssl: 1.0.2k icu: 58.2 unicode: 9.0 cldr: 30.0.3 tz: 2016j 初始化hexo hexo init blog cd blog npm install 启动服务，正常时这样的 hexo server INFO Start processing INFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 在浏览器里输入以下地址访问页面：http://localhost:4000/ 部署到github先安装hexo-deployer npm install hexo-deployer-git --save 然后到博客根目录的_config.yml文件，找到deploy配置位置，填写上仓库地址，地址就是刚刚创建的那个github仓库的地址，可以从仓库首页面clone or download下拉框里直接拷贝然后出入下面的命令三件套，每一次修改都可以使用这三件套来部署 hexo clean hexo g hexo d 提示你输入github的用户名和密码，就OK了，然后你就可以使用your_githubName.github.io来访问自己的站点了，效果和本地跑的一样 六. Hexo常用命令下面时一Hexo常用的命令，平时可能会经常用到，也可以使用hexo -help自己查看各种命令的使用方法，括号内时简写 hexo clean -- 清理缓存文件 hexo generate(g) -- 生成静态文件 hexo server(s) -- 启动服务 hexo deploy(d) -- 部署站点 hexo d -g -- 生成加部署 hexo new &quot;Name&quot; -- 新建文章 hexo new draft &quot;Name&quot; -- 新建草稿文档 hexo --draft -- 显示草稿 hexo publish [layout] filename -- 发布草稿","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://blueskyawen.com/tags/Hexo/"}]},{"title":"Markdown语法及编辑工具","date":"2017-05-29T09:19:02.000Z","path":"2017/05/29/markdown/","text":"花了好几天时间，终于把博客搭建好了。搭建博客是为了写点东西，记录下平时学习和生活的点滴，便于积累知识和查看。然而发现，记录文章是基于Markdown语法来书写的，所以在开始博客前先熟悉了下markdown语法，并对常用的一些语法作了下总结，基本可以满足平常的写作需求。 一. Markdown语法其实就是一种text to html的微语法，文本化的书写方式，最终还是由工具转化成html文档加以展示。 HTML兼容markdown语法对html标签是兼容的，在写作时可以随意使用html标签组织内容，但对于块级元素(比如:div)和行内元素标签(比如:span)和微语法的结合效果是不一样的:块级元素标签内markdown语法无效;而行内元素标签内markdown语法有效。 特殊字符的自动转化对于&amp; &lt; 这样的符号在html文档里有特殊意义的，但markdown会根据它们的使用场景进行自动转换，比如:当&lt;用于标签表示时工具不去理会，但是当只用于普通场景(3&lt;5)时会自动转化成对应的实体。 段落段落前后默认会有空行，如果需要在段落内换行，可敲2个空格加回车 标题markdown里有两种标题形式: 1). Setext # 标题1 ## 标题2 ### 标题3 #### 标题4 ##### 标题5 ###### 标题6 6级标题，#号越少，标题越高 2). atx 一级标题 ==== 二级标题 ---- 区块引用使用&gt;符号定义应用，可以多层嵌套 &gt; 外文引用 &gt; &gt; 外文引用 效果如下： 外文引用 外文引用 列表1). 无序列表:使用* + - 来构造无序列表 * 列表项目1 * 列表项目2 + 列表项目1 + 列表项目2 - 列表项目1 - 列表项目2 效果如下： 列表项目1 列表项目2 2). 有序列表:使用数字.来构造有序列表 1 列表项目1 2 列表项目2 效果如下： 列表项目1 列表项目2 注意：列表标记符号和项目内容之间须至少1个空格，最多3个空格 代码区块使用反引号`包围代码块，或者缩进4个空格来构造代码块，当代码块作为列表或引用的子元素时，可缩进到5个空格注意：代码块前后须加空行 分割线使用多个* - _ 来制造分隔线 *** --- ___ 效果如下：插入链接(1) 行内形式 [百度一下，你就知道](http://www.baidu.com &quot;baidu&quot;) 效果如下：百度一下，你就知道 (2) 参考形式 [百度一下，你就知道](1) [淘宝]() [1]: http://www.baidu.com &quot;baidu&quot; [淘宝]: http://www.taobao.com &quot;taobao&quot; 效果如下：百度一下，你就知道淘宝 注意：参考形式的url定义处和使用处须有空行，一般放在段落后面或文章最尾部 插入图像与链接类似，也分行内形式和参考形式 ![text](url &quot;title&quot;) ![text][id] [id]: url &quot;title&quot; 效果如下: 字体单个*斜体，俩个粗体 *斜体* **粗体** ***斜体+粗体*** 效果如下：斜体粗体斜体+粗体 表格| Left-Aligned | Center Aligned | Right Aligned | | :------------ |:---------------:| -----:| | col 3 is | some wordy text | $1600 | | col 2 is | centered | $12 | 效果如下： Left-Aligned Center Aligned Right Aligned col 3 is some wordy text $1600 col 2 is centered $12 其中，:—左对齐，:—:中间对齐，—:左对齐， 二. Markdown工具有许多的markdown语法转换工具，提供便捷书写和实时预览的功能，帮助方便的编辑文档，个人推荐以下，可在线编辑: Markdown plus: Markdown编辑器，可以支持添加任务列表、emoji、流程图等 作业部落: 在线 Markdown 编辑器推出桌面版客户端啦，全平台支援。 参考： Markdown 语法说明(简体中文版)-http://www.appinn.com/markdown/","tags":[{"name":"写作","slug":"写作","permalink":"http://blueskyawen.com/tags/写作/"}]}]